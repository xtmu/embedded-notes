{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/res/IMX6UL-BD.png","path":"res/IMX6UL-BD.png","modified":0,"renderable":0},{"_id":"source/res/https通讯过程.png","path":"res/https通讯过程.png","modified":0,"renderable":0},{"_id":"source/res/cortex-m3系统框图.png","path":"res/cortex-m3系统框图.png","modified":0,"renderable":0},{"_id":"source/res/tcp协议图解.jpg","path":"res/tcp协议图解.jpg","modified":0,"renderable":0},{"_id":"source/res/cortex-m0系统框图.png","path":"res/cortex-m0系统框图.png","modified":0,"renderable":0},{"_id":"source/res/sort/sort.png","path":"res/sort/sort.png","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","path":"images/favicon_cactus.ico","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/res/sort/radixSort.gif","path":"res/sort/radixSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":0,"renderable":1},{"_id":"source/res/sort/countingSort.gif","path":"res/sort/countingSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"source/res/sort/quickSort.gif","path":"res/sort/quickSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"source/res/sort/bubbleSort.gif","path":"res/sort/bubbleSort.gif","modified":0,"renderable":0},{"_id":"source/res/sort/insertionSort.gif","path":"res/sort/insertionSort.gif","modified":0,"renderable":0},{"_id":"source/res/sort/mergeSort.gif","path":"res/sort/mergeSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/res/sort/selectionSort.gif","path":"res/sort/selectionSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"source/res/sort/heapSort.gif","path":"res/sort/heapSort.gif","modified":0,"renderable":0},{"_id":"themes/cactus-white/source/images/theme overview.psd","path":"images/theme overview.psd","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519782125326},{"_id":"themes/cactus-white/LICENSE","hash":"6c2233da6ccbf42c2d2fdd8a137c8a050cb97e21","modified":1519605610000},{"_id":"themes/cactus-white/README.md","hash":"2f1a95efb2236d996a25a3697cb226cbb6584a5a","modified":1519605610000},{"_id":"themes/cactus-white/_config.yml","hash":"83012f105a69bc24bdb7d4fbd57b51e277744680","modified":1519605610000},{"_id":"source/_posts/cortex.md","hash":"333e70f599fca2d0a803503f2a5ad38375497a94","modified":1519780639305},{"_id":"source/_posts/c基础.md","hash":"a5ffbfe2b6d77bdac310efa3c6df7a5ff281c0f8","modified":1519780653212},{"_id":"source/_posts/driver.md","hash":"e8e7c8df52e2e86ab0e5dd03ba78fc2cc9d44a50","modified":1519780312942},{"_id":"source/_posts/freertos-inside.md","hash":"e10f74db43a03a7ed7d02752edc001c3807d587b","modified":1519780337724},{"_id":"source/_posts/git.md","hash":"e87d444766600d42bb9034c8bcb2dcde77cfa0a8","modified":1519781365663},{"_id":"source/_posts/gpu.md","hash":"555bfe1659948d99e3ae87aa213d3b93a38413e8","modified":1519780382254},{"_id":"source/_posts/linux.md","hash":"253d2c2dcf232a1c81f8eb71041cffa6f2991a6e","modified":1519780399785},{"_id":"source/_posts/makefile.md","hash":"92921cea8e2c9325d71a4c8efdd86990fba0d545","modified":1519780420656},{"_id":"source/_posts/shell.md","hash":"a6f407792791d10a92e757e0b1ad26d5b927333e","modified":1519781819506},{"_id":"source/_posts/tcpip协议栈.md","hash":"165a7bf181b55dfcc9aa073fa48e8ea25dfc5825","modified":1519780462242},{"_id":"source/_posts/uboot.md","hash":"ea17873ab39b4dfa3233731d740d1d477dc44c9f","modified":1519780482653},{"_id":"source/_posts/阿里Q.md","hash":"51fb5ad66d6123881b3fe919e303d590a3b839f4","modified":1520170641734},{"_id":"source/res/IMX6UL-BD.png","hash":"d29b2bc3e1898d5cc542547df5a2bc02b01bd628","modified":1519780148254},{"_id":"source/res/https通讯过程.png","hash":"fb88d94d5372a21881e14ed959623c046d01c4d6","modified":1519780158850},{"_id":"themes/cactus-white/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1519605610000},{"_id":"themes/cactus-white/layout/index.ejs","hash":"d60d93d16cd18484ff90013821730c2f10b0e09c","modified":1519605610000},{"_id":"themes/cactus-white/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1519605610000},{"_id":"themes/cactus-white/layout/page.ejs","hash":"d14964cac07f5db45d83af682a7924413f7dd3b6","modified":1519605610000},{"_id":"themes/cactus-white/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1519605610000},{"_id":"themes/cactus-white/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1519605610000},{"_id":"themes/cactus-white/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1519605610000},{"_id":"source/res/cortex-m3系统框图.png","hash":"f748b461745776618da7de8c0ed39ff162e4e1eb","modified":1519780158850},{"_id":"source/res/tcp协议图解.jpg","hash":"bb3c1bc20dff07c9643ae5a99547a27633224cf6","modified":1519780148274},{"_id":"source/res/cortex-m0系统框图.png","hash":"bf12f964e1c5c1818c996d55dfc4e4d012ef19c2","modified":1519780158850},{"_id":"source/res/sort/sort.png","hash":"d56b4ee34471bc6000647878aa93c6c5eb0fe6df","modified":1519780148274},{"_id":"themes/cactus-white/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/scripts.ejs","hash":"61b9d9517d07c18360da6177e40436260224eccc","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/search.ejs","hash":"1812a10645f635fa8467bf71eed57e704fa3b7cd","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/styles.ejs","hash":"6eb7189f05783e7044c7dab16e671176329e7cd3","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_extend.styl","hash":"13e3792845e219246ce9e8b92da26f6c65f4c5c1","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_variables.styl","hash":"66cdadb8c13eb08a33dac135be9486d28eec6e79","modified":1519605610000},{"_id":"themes/cactus-white/source/css/style.styl","hash":"4dc2093b87c76fcc1225103145549fe35d22b80a","modified":1519605610000},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1519605610000},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1519605610000},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1519605610000},{"_id":"themes/cactus-white/source/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1519605610000},{"_id":"themes/cactus-white/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1519605610000},{"_id":"themes/cactus-white/source/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1519605610000},{"_id":"source/res/sort/radixSort.gif","hash":"b0c0244dc01eda00d0b92572b6c0eaf088ae3dee","modified":1519780148274},{"_id":"themes/cactus-white/layout/_partial/post/actions_desktop.ejs","hash":"063ae931a6902f192e086fe5cceae587d27ed196","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/actions_mobile.ejs","hash":"64d0f85480997a4fa53c99954e9454c189595e9c","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1519605610000},{"_id":"themes/cactus-white/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/arta.styl","hash":"25f4d37cbb65409b2245c7c1bd830f18f5cb4227","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/article.styl","hash":"20c222152f6775602815d107a11d2bda512e4c18","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/footer.styl","hash":"9828b9c71781768f2ec74d0535d17966ef020b36","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/header.styl","hash":"ba27c6e702e60c3eecb998714ab61284efa4a09b","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/index.styl","hash":"e78a3d6254ea6acb339c177692f4d3df7fab87bd","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/search.styl","hash":"4bf70f1ecc5f2c41003ca51a8b0255e32c8c6eba","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1519605610000},{"_id":"source/res/sort/countingSort.gif","hash":"dda8c95e868f3ffa28663140a5fac5fa3bc746b2","modified":1519780148258},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519605610000},{"_id":"source/res/sort/quickSort.gif","hash":"9d0e7c1b3d02e77e41dfbba78ae9c02daec2744f","modified":1519780148270},{"_id":"themes/cactus-white/source/css/_partial/post/actions_desktop.styl","hash":"fb5106e42ab607181145e5f4fb78b8ae717ac263","modified":1519605610000},{"_id":"themes/cactus-white/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1519605610000},{"_id":"source/res/sort/bubbleSort.gif","hash":"e3316329fee9b7906fa857af53e2dcd053a039cd","modified":1519780148258},{"_id":"source/res/sort/insertionSort.gif","hash":"29e9d8b18a7bac20f4e642968598fa48eb9f6199","modified":1519780148270},{"_id":"source/res/sort/mergeSort.gif","hash":"0fb0ff4cc92da6d0a0f3d3a0742bbedac7c16c2a","modified":1519780148270},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1519605610000},{"_id":"source/res/sort/selectionSort.gif","hash":"8e3b36259e7aeaf6a479aaef6165c247658b11e3","modified":1519780148274},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1519605610000},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1519605610000},{"_id":"source/res/sort/heapSort.gif","hash":"ab035888029355dd0e6b8de927d913fa0523f4f1","modified":1519780148266},{"_id":"themes/cactus-white/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1519605610000},{"_id":"public/2018/02/28/uboot/index.html","hash":"395255ee9096629f9f6736c980d700836268ab27","modified":1520211833529},{"_id":"public/archives/index.html","hash":"783538169dcd1d3256f06e4f8c6da870aaedcf80","modified":1520211833529},{"_id":"public/archives/page/2/index.html","hash":"9ebdeba10f69bb96d4579b3d6cfefa1cfdd2edfe","modified":1520211833529},{"_id":"public/archives/2018/index.html","hash":"c2c172254229398707dfc6cd78b92d92f175a018","modified":1520211833529},{"_id":"public/archives/2018/page/2/index.html","hash":"8af506d3d33de07af299044dd91cf37f3dd16804","modified":1520211833529},{"_id":"public/archives/2018/02/index.html","hash":"1b788d6666adbd67ec0dee28bcdf7ff4796d9e4e","modified":1520211833529},{"_id":"public/archives/2018/02/page/2/index.html","hash":"56c4f1e48b73a1dd5b78cb14d39b89c9c0028d26","modified":1520211833530},{"_id":"public/archives/2018/03/index.html","hash":"c996363556ca50368815c2715b0cbd9bfe5a1ea7","modified":1520211833530},{"_id":"public/index.html","hash":"ca1dcd2b36e806b7e1cc4a47b907eeb2975a7843","modified":1520211833530},{"_id":"public/page/2/index.html","hash":"7f33f5e1e6b08d71a264ace53232af4810e488e7","modified":1520211833530},{"_id":"public/2018/03/03/阿里Q/index.html","hash":"f380e32aad8c6fef7aa195efc35dc75d8156bc1e","modified":1520211833530},{"_id":"public/2018/02/28/shell/index.html","hash":"7b8f814a2bb67ad9749044da23250baa15341f81","modified":1520211833530},{"_id":"public/2018/02/28/git/index.html","hash":"bd4738cdc03630864097d0d868c3f992a954d969","modified":1520211833530},{"_id":"public/2018/02/28/makefile/index.html","hash":"745268c6a64b8066e556cff9f0f7eb8950155dac","modified":1520211833530},{"_id":"public/2018/02/28/tcpip协议栈/index.html","hash":"66365272fc24bed43d2a0836689c5620dd07170d","modified":1520211833530},{"_id":"public/2018/02/28/linux/index.html","hash":"665622b7c21269b6bdda97ecd90db9eba3f28bfa","modified":1520211833530},{"_id":"public/2018/02/28/gpu/index.html","hash":"dd543dc76a4f701ef3d410b84389e036a8d3fb59","modified":1520211833531},{"_id":"public/2018/02/28/freertos-inside/index.html","hash":"a49bd3c66215fdd73d853349fc9aa471aa5dcce3","modified":1520211833531},{"_id":"public/2018/02/28/c基础/index.html","hash":"944f00e5d6043cae7184a2d71487552e8ce586f6","modified":1520211833531},{"_id":"public/2018/02/28/driver/index.html","hash":"a4feb9eb34b1b8743885aab9415a37b75b831c7f","modified":1520211833531},{"_id":"public/2018/02/28/cortex/index.html","hash":"ba888f50e2d74c46af8bf518ba685b1ee6600ac2","modified":1520211833531},{"_id":"public/CNAME","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1520211833539},{"_id":"public/res/https通讯过程.png","hash":"fb88d94d5372a21881e14ed959623c046d01c4d6","modified":1520211833539},{"_id":"public/res/IMX6UL-BD.png","hash":"d29b2bc3e1898d5cc542547df5a2bc02b01bd628","modified":1520211833539},{"_id":"public/res/sort/sort.png","hash":"d56b4ee34471bc6000647878aa93c6c5eb0fe6df","modified":1520211833539},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1520211833539},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1520211833539},{"_id":"public/images/favicon_cactus.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1520211833540},{"_id":"public/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1520211833540},{"_id":"public/css/prism-tomorrow.css","hash":"2eb468e82b669045d37cb6b503af97dabc0a9eb2","modified":1520211833540},{"_id":"public/css/prism-line-numbers.css","hash":"3e9c86e826e350927eeb299e53ac7daa3ce19ffc","modified":1520211833540},{"_id":"public/res/cortex-m3系统框图.png","hash":"f748b461745776618da7de8c0ed39ff162e4e1eb","modified":1520211833792},{"_id":"public/res/tcp协议图解.jpg","hash":"bb3c1bc20dff07c9643ae5a99547a27633224cf6","modified":1520211833792},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1520211833794},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1520211833794},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1520211833800},{"_id":"public/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1520211833800},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1520211833800},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1520211833800},{"_id":"public/css/style.css","hash":"1918b9589c9aca683c9e076c18345a803a823871","modified":1520211833800},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1520211833801},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1520211833801},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1520211833801},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1520211833801},{"_id":"public/res/cortex-m0系统框图.png","hash":"bf12f964e1c5c1818c996d55dfc4e4d012ef19c2","modified":1520211833801},{"_id":"public/res/sort/radixSort.gif","hash":"b0c0244dc01eda00d0b92572b6c0eaf088ae3dee","modified":1520211833801},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1520211833801},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1520211833801},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1520211833802},{"_id":"public/res/sort/countingSort.gif","hash":"dda8c95e868f3ffa28663140a5fac5fa3bc746b2","modified":1520211833809},{"_id":"public/res/sort/quickSort.gif","hash":"9d0e7c1b3d02e77e41dfbba78ae9c02daec2744f","modified":1520211833814},{"_id":"public/res/sort/bubbleSort.gif","hash":"e3316329fee9b7906fa857af53e2dcd053a039cd","modified":1520211833819},{"_id":"public/res/sort/mergeSort.gif","hash":"0fb0ff4cc92da6d0a0f3d3a0742bbedac7c16c2a","modified":1520211833819},{"_id":"public/res/sort/insertionSort.gif","hash":"29e9d8b18a7bac20f4e642968598fa48eb9f6199","modified":1520211833819},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1520211833826},{"_id":"public/res/sort/selectionSort.gif","hash":"8e3b36259e7aeaf6a479aaef6165c247658b11e3","modified":1520211833830},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1520211833835},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1520211833835},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1520211833835},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1520211833839},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1520211833839},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1520211833840},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1520211833840},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1520211833841},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1520211833841},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1520211833841},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1520211833842},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1520211833842},{"_id":"public/res/sort/heapSort.gif","hash":"ab035888029355dd0e6b8de927d913fa0523f4f1","modified":1520211833864},{"_id":"public/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1520211833869}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"嵌入式笔记：linux驱动","_content":"嵌入式笔记：linux驱动\n\n## 驱动开发注意事项\n1. 不能访问C库\n2. 只有一个很小的定长堆栈\n3. 没有内存保护机制\n4. 浮点数很难使用，应该使用整型数\n\n## Kconfig\n> 描述了所属目录源文档相关的内核配置菜单，用于make menuconfig中的配置\n\n示例：\n```sh\nmenu \"Network device support\"\nconfig NETDEVICES\n    bool \"Enable Net Devices\"  菜单类型\n    depends on NET             该项依赖项，如果没有选中NET，则不会显示这项菜单。\n        default y              默认yes\n        help                   帮助信息\n            This is help desciption。\n    ...\n    endmenu\n```\n\n### 菜单类型\n菜单类型有：\n* `bool` []\n* `tristate` <>   三态（内建 模块 移除）\n* `string`        字符串\n* `hex` ()        十六进制\n* `integer`       整型\n\n\n## .config\n> make menuconfig之后保存的文件\n\n## Makefile\n```makefile\n    obj-y += foo.o  # 默认由foo.c或者foo.s 编译得到\n    obj-m += foo.o  # 默认编译成模块\n```\n## vmlinux\n> 是由linux源码编译后未压缩的内核\n\n## linux内核Makefile\n由5部分组成:\n1. `Makefile` : 顶层Makefile。\n2. `.config`: kernel配置文件。\n3. `arch/xxx/Makefile`: 具体架构的Makefile。\n4. `scripts/Makefile.xxx` : 通用规则。\n5. `kbuild Makefile`: 整个kernel中大约有数百个这种文件。\n\n`arch/$ARCH/configs` 默认的配置文件\n`/driver/vidio` 对应Graphics support 代表显卡\t\n\n## file_operations\n> 驱动程序操作功能结构体\n\n|函数|说明|\n|-|-|\n|`open()`|打开设备|\n|`release()`|释放设备|\n|`read()`|读设备|\n|`write()`|写设备|\n|`ioctl()`|对设备设置控制参数|\n|`llseek()`|修改文件当前的读写位置|\n|`poll()`|查询设备是否可读可写|\n\n\n## linux内核编译操作\n\n```sh\nmake bzImage                    # 编译生成压缩的内核二进制文件\nmake vmlinux                    # 编译生成二进制内核文件\nmake modules                    # 编译生成内核模块\nmake modules_install # 安装模块\nmake bzdisk|fdimage|isoimage    # 编译生成启动软盘镜像或者光盘镜像\nmake install                    # 安装内核文件\nmake all                        # 相当于vmlinux+modules+bzImage\nmake rpm                        # 构建内核rpm包\nmake foo/bar/foobar.ko          # 编译单个驱动\nmake header_install             # 安装内核头文件\nmake M=some/sub/dir             # 编译指定目录\nmake O=/path/to/some/dir        # 指定生成的文件放到该目录\nmake kernelversion              # 输出内核版本信息\nmake kernelrelease              # 输出内核发行标识\nmake rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg   # 构建这种格式的内核包\nmake clean                      # 清除生成文件（保留.config和部分模块文件）\nmake mrproper                   # 清除全部文件（包括.config和备份文件）\nmake distclean                  # 在make mrproper上还清除编辑器其他的备份文件\n```\n\n## modules.order\n    记录了Makefile中模块出现的顺序\n## .o.cmd\n    表示生成该对象的具体命令\n\n\n\n","source":"_posts/driver.md","raw":"---\ntitle: 嵌入式笔记：linux驱动\n---\n嵌入式笔记：linux驱动\n\n## 驱动开发注意事项\n1. 不能访问C库\n2. 只有一个很小的定长堆栈\n3. 没有内存保护机制\n4. 浮点数很难使用，应该使用整型数\n\n## Kconfig\n> 描述了所属目录源文档相关的内核配置菜单，用于make menuconfig中的配置\n\n示例：\n```sh\nmenu \"Network device support\"\nconfig NETDEVICES\n    bool \"Enable Net Devices\"  菜单类型\n    depends on NET             该项依赖项，如果没有选中NET，则不会显示这项菜单。\n        default y              默认yes\n        help                   帮助信息\n            This is help desciption。\n    ...\n    endmenu\n```\n\n### 菜单类型\n菜单类型有：\n* `bool` []\n* `tristate` <>   三态（内建 模块 移除）\n* `string`        字符串\n* `hex` ()        十六进制\n* `integer`       整型\n\n\n## .config\n> make menuconfig之后保存的文件\n\n## Makefile\n```makefile\n    obj-y += foo.o  # 默认由foo.c或者foo.s 编译得到\n    obj-m += foo.o  # 默认编译成模块\n```\n## vmlinux\n> 是由linux源码编译后未压缩的内核\n\n## linux内核Makefile\n由5部分组成:\n1. `Makefile` : 顶层Makefile。\n2. `.config`: kernel配置文件。\n3. `arch/xxx/Makefile`: 具体架构的Makefile。\n4. `scripts/Makefile.xxx` : 通用规则。\n5. `kbuild Makefile`: 整个kernel中大约有数百个这种文件。\n\n`arch/$ARCH/configs` 默认的配置文件\n`/driver/vidio` 对应Graphics support 代表显卡\t\n\n## file_operations\n> 驱动程序操作功能结构体\n\n|函数|说明|\n|-|-|\n|`open()`|打开设备|\n|`release()`|释放设备|\n|`read()`|读设备|\n|`write()`|写设备|\n|`ioctl()`|对设备设置控制参数|\n|`llseek()`|修改文件当前的读写位置|\n|`poll()`|查询设备是否可读可写|\n\n\n## linux内核编译操作\n\n```sh\nmake bzImage                    # 编译生成压缩的内核二进制文件\nmake vmlinux                    # 编译生成二进制内核文件\nmake modules                    # 编译生成内核模块\nmake modules_install # 安装模块\nmake bzdisk|fdimage|isoimage    # 编译生成启动软盘镜像或者光盘镜像\nmake install                    # 安装内核文件\nmake all                        # 相当于vmlinux+modules+bzImage\nmake rpm                        # 构建内核rpm包\nmake foo/bar/foobar.ko          # 编译单个驱动\nmake header_install             # 安装内核头文件\nmake M=some/sub/dir             # 编译指定目录\nmake O=/path/to/some/dir        # 指定生成的文件放到该目录\nmake kernelversion              # 输出内核版本信息\nmake kernelrelease              # 输出内核发行标识\nmake rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg   # 构建这种格式的内核包\nmake clean                      # 清除生成文件（保留.config和部分模块文件）\nmake mrproper                   # 清除全部文件（包括.config和备份文件）\nmake distclean                  # 在make mrproper上还清除编辑器其他的备份文件\n```\n\n## modules.order\n    记录了Makefile中模块出现的顺序\n## .o.cmd\n    表示生成该对象的具体命令\n\n\n\n","slug":"driver","published":1,"date":"2018-02-28T01:20:44.965Z","updated":"2018-02-28T01:11:52.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhaz00009vf7tcllu504","content":"<p>嵌入式笔记：linux驱动</p>\n<h2 id=\"驱动开发注意事项\"><a href=\"#驱动开发注意事项\" class=\"headerlink\" title=\"驱动开发注意事项\"></a>驱动开发注意事项</h2><ol>\n<li>不能访问C库</li>\n<li>只有一个很小的定长堆栈</li>\n<li>没有内存保护机制</li>\n<li>浮点数很难使用，应该使用整型数</li>\n</ol>\n<h2 id=\"Kconfig\"><a href=\"#Kconfig\" class=\"headerlink\" title=\"Kconfig\"></a>Kconfig</h2><blockquote>\n<p>描述了所属目录源文档相关的内核配置菜单，用于make menuconfig中的配置</p>\n</blockquote>\n<p>示例：</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">menu \"Network device support\"\nconfig NETDEVICES\n    bool \"Enable Net Devices\"  菜单类型\n    depends on NET             该项依赖项，如果没有选中NET，则不会显示这项菜单。\n        default y              默认yes\n        help                   帮助信息\n            This is help desciption。\n    ...\n    endmenu\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"菜单类型\"><a href=\"#菜单类型\" class=\"headerlink\" title=\"菜单类型\"></a>菜单类型</h3><p>菜单类型有：</p>\n<ul>\n<li><code>bool</code> []</li>\n<li><code>tristate</code> &lt;&gt;   三态（内建 模块 移除）</li>\n<li><code>string</code>        字符串</li>\n<li><code>hex</code> ()        十六进制</li>\n<li><code>integer</code>       整型</li>\n</ul>\n<h2 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\".config\"></a>.config</h2><blockquote>\n<p>make menuconfig之后保存的文件</p>\n</blockquote>\n<h2 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h2><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">    obj-y <span class=\"token operator\">+=</span> foo.o  <span class=\"token comment\" spellcheck=\"true\"># 默认由foo.c或者foo.s 编译得到</span>\n    obj-m <span class=\"token operator\">+=</span> foo.o  <span class=\"token comment\" spellcheck=\"true\"># 默认编译成模块</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"vmlinux\"><a href=\"#vmlinux\" class=\"headerlink\" title=\"vmlinux\"></a>vmlinux</h2><blockquote>\n<p>是由linux源码编译后未压缩的内核</p>\n</blockquote>\n<h2 id=\"linux内核Makefile\"><a href=\"#linux内核Makefile\" class=\"headerlink\" title=\"linux内核Makefile\"></a>linux内核Makefile</h2><p>由5部分组成:</p>\n<ol>\n<li><code>Makefile</code> : 顶层Makefile。</li>\n<li><code>.config</code>: kernel配置文件。</li>\n<li><code>arch/xxx/Makefile</code>: 具体架构的Makefile。</li>\n<li><code>scripts/Makefile.xxx</code> : 通用规则。</li>\n<li><code>kbuild Makefile</code>: 整个kernel中大约有数百个这种文件。</li>\n</ol>\n<p><code>arch/$ARCH/configs</code> 默认的配置文件<br><code>/driver/vidio</code> 对应Graphics support 代表显卡    </p>\n<h2 id=\"file-operations\"><a href=\"#file-operations\" class=\"headerlink\" title=\"file_operations\"></a>file_operations</h2><blockquote>\n<p>驱动程序操作功能结构体</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>open()</code></td>\n<td>打开设备</td>\n</tr>\n<tr>\n<td><code>release()</code></td>\n<td>释放设备</td>\n</tr>\n<tr>\n<td><code>read()</code></td>\n<td>读设备</td>\n</tr>\n<tr>\n<td><code>write()</code></td>\n<td>写设备</td>\n</tr>\n<tr>\n<td><code>ioctl()</code></td>\n<td>对设备设置控制参数</td>\n</tr>\n<tr>\n<td><code>llseek()</code></td>\n<td>修改文件当前的读写位置</td>\n</tr>\n<tr>\n<td><code>poll()</code></td>\n<td>查询设备是否可读可写</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"linux内核编译操作\"><a href=\"#linux内核编译操作\" class=\"headerlink\" title=\"linux内核编译操作\"></a>linux内核编译操作</h2><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">make bzImage                    # 编译生成压缩的内核二进制文件\nmake vmlinux                    # 编译生成二进制内核文件\nmake modules                    # 编译生成内核模块\nmake modules_install # 安装模块\nmake bzdisk|fdimage|isoimage    # 编译生成启动软盘镜像或者光盘镜像\nmake install                    # 安装内核文件\nmake all                        # 相当于vmlinux+modules+bzImage\nmake rpm                        # 构建内核rpm包\nmake foo/bar/foobar.ko          # 编译单个驱动\nmake header_install             # 安装内核头文件\nmake M=some/sub/dir             # 编译指定目录\nmake O=/path/to/some/dir        # 指定生成的文件放到该目录\nmake kernelversion              # 输出内核版本信息\nmake kernelrelease              # 输出内核发行标识\nmake rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg   # 构建这种格式的内核包\nmake clean                      # 清除生成文件（保留.config和部分模块文件）\nmake mrproper                   # 清除全部文件（包括.config和备份文件）\nmake distclean                  # 在make mrproper上还清除编辑器其他的备份文件\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"modules-order\"><a href=\"#modules-order\" class=\"headerlink\" title=\"modules.order\"></a>modules.order</h2><pre><code>记录了Makefile中模块出现的顺序\n</code></pre><h2 id=\"o-cmd\"><a href=\"#o-cmd\" class=\"headerlink\" title=\".o.cmd\"></a>.o.cmd</h2><pre><code>表示生成该对象的具体命令\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：linux驱动</p>\n<h2 id=\"驱动开发注意事项\"><a href=\"#驱动开发注意事项\" class=\"headerlink\" title=\"驱动开发注意事项\"></a>驱动开发注意事项</h2><ol>\n<li>不能访问C库</li>\n<li>只有一个很小的定长堆栈</li>\n<li>没有内存保护机制</li>\n<li>浮点数很难使用，应该使用整型数</li>\n</ol>\n<h2 id=\"Kconfig\"><a href=\"#Kconfig\" class=\"headerlink\" title=\"Kconfig\"></a>Kconfig</h2><blockquote>\n<p>描述了所属目录源文档相关的内核配置菜单，用于make menuconfig中的配置</p>\n</blockquote>\n<p>示例：</p>\n<pre><code class=\"sh\">menu &quot;Network device support&quot;\nconfig NETDEVICES\n    bool &quot;Enable Net Devices&quot;  菜单类型\n    depends on NET             该项依赖项，如果没有选中NET，则不会显示这项菜单。\n        default y              默认yes\n        help                   帮助信息\n            This is help desciption。\n    ...\n    endmenu\n</code></pre>\n<h3 id=\"菜单类型\"><a href=\"#菜单类型\" class=\"headerlink\" title=\"菜单类型\"></a>菜单类型</h3><p>菜单类型有：</p>\n<ul>\n<li><code>bool</code> []</li>\n<li><code>tristate</code> &lt;&gt;   三态（内建 模块 移除）</li>\n<li><code>string</code>        字符串</li>\n<li><code>hex</code> ()        十六进制</li>\n<li><code>integer</code>       整型</li>\n</ul>\n<h2 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\".config\"></a>.config</h2><blockquote>\n<p>make menuconfig之后保存的文件</p>\n</blockquote>\n<h2 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h2><pre><code class=\"makefile\">    obj-y += foo.o  # 默认由foo.c或者foo.s 编译得到\n    obj-m += foo.o  # 默认编译成模块\n</code></pre>\n<h2 id=\"vmlinux\"><a href=\"#vmlinux\" class=\"headerlink\" title=\"vmlinux\"></a>vmlinux</h2><blockquote>\n<p>是由linux源码编译后未压缩的内核</p>\n</blockquote>\n<h2 id=\"linux内核Makefile\"><a href=\"#linux内核Makefile\" class=\"headerlink\" title=\"linux内核Makefile\"></a>linux内核Makefile</h2><p>由5部分组成:</p>\n<ol>\n<li><code>Makefile</code> : 顶层Makefile。</li>\n<li><code>.config</code>: kernel配置文件。</li>\n<li><code>arch/xxx/Makefile</code>: 具体架构的Makefile。</li>\n<li><code>scripts/Makefile.xxx</code> : 通用规则。</li>\n<li><code>kbuild Makefile</code>: 整个kernel中大约有数百个这种文件。</li>\n</ol>\n<p><code>arch/$ARCH/configs</code> 默认的配置文件<br><code>/driver/vidio</code> 对应Graphics support 代表显卡    </p>\n<h2 id=\"file-operations\"><a href=\"#file-operations\" class=\"headerlink\" title=\"file_operations\"></a>file_operations</h2><blockquote>\n<p>驱动程序操作功能结构体</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>open()</code></td>\n<td>打开设备</td>\n</tr>\n<tr>\n<td><code>release()</code></td>\n<td>释放设备</td>\n</tr>\n<tr>\n<td><code>read()</code></td>\n<td>读设备</td>\n</tr>\n<tr>\n<td><code>write()</code></td>\n<td>写设备</td>\n</tr>\n<tr>\n<td><code>ioctl()</code></td>\n<td>对设备设置控制参数</td>\n</tr>\n<tr>\n<td><code>llseek()</code></td>\n<td>修改文件当前的读写位置</td>\n</tr>\n<tr>\n<td><code>poll()</code></td>\n<td>查询设备是否可读可写</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"linux内核编译操作\"><a href=\"#linux内核编译操作\" class=\"headerlink\" title=\"linux内核编译操作\"></a>linux内核编译操作</h2><pre><code class=\"sh\">make bzImage                    # 编译生成压缩的内核二进制文件\nmake vmlinux                    # 编译生成二进制内核文件\nmake modules                    # 编译生成内核模块\nmake modules_install # 安装模块\nmake bzdisk|fdimage|isoimage    # 编译生成启动软盘镜像或者光盘镜像\nmake install                    # 安装内核文件\nmake all                        # 相当于vmlinux+modules+bzImage\nmake rpm                        # 构建内核rpm包\nmake foo/bar/foobar.ko          # 编译单个驱动\nmake header_install             # 安装内核头文件\nmake M=some/sub/dir             # 编译指定目录\nmake O=/path/to/some/dir        # 指定生成的文件放到该目录\nmake kernelversion              # 输出内核版本信息\nmake kernelrelease              # 输出内核发行标识\nmake rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg   # 构建这种格式的内核包\nmake clean                      # 清除生成文件（保留.config和部分模块文件）\nmake mrproper                   # 清除全部文件（包括.config和备份文件）\nmake distclean                  # 在make mrproper上还清除编辑器其他的备份文件\n</code></pre>\n<h2 id=\"modules-order\"><a href=\"#modules-order\" class=\"headerlink\" title=\"modules.order\"></a>modules.order</h2><pre><code>记录了Makefile中模块出现的顺序\n</code></pre><h2 id=\"o-cmd\"><a href=\"#o-cmd\" class=\"headerlink\" title=\".o.cmd\"></a>.o.cmd</h2><pre><code>表示生成该对象的具体命令\n</code></pre>"},{"title":"嵌入式笔记：git操作","_content":"嵌入式笔记：git操作\n\n# 目录\n## 说明\ngit操作笔记\n\n### 添加文件\n```sh\ngit add .\n```\n### 删除文件\n```sh\ngit rm .\n```\n### 提交改动到本地\n```sh\ngit commit -m \"first commit\"\n```\n### 上传改动到服务器\n```sh\ngit push\n```\n### 列出当前分支\n```sh\ngit branch\n```\n### 列出所有分支，包括远程分支\n```sh\ngit branch -a\n```\n### 从已有的分支创建新的分支(如从master分支),创建一个dev分支\n```sh\ngit checkout -b dev\n```\n### 从服务器拉取分支到本地分支\n```sh\ngit pull origin gh-pages:gh-pages\n```\n> 需要本地没有gh-pages分支，否则会提示已拒绝\n### 上传本地分支到远程分支\n```sh\ngit branch --set-upstream-to=gh-pages\ngit push origin gh-pages\n```\n","source":"_posts/git.md","raw":"---\ntitle: 嵌入式笔记：git操作\n---\n嵌入式笔记：git操作\n\n# 目录\n## 说明\ngit操作笔记\n\n### 添加文件\n```sh\ngit add .\n```\n### 删除文件\n```sh\ngit rm .\n```\n### 提交改动到本地\n```sh\ngit commit -m \"first commit\"\n```\n### 上传改动到服务器\n```sh\ngit push\n```\n### 列出当前分支\n```sh\ngit branch\n```\n### 列出所有分支，包括远程分支\n```sh\ngit branch -a\n```\n### 从已有的分支创建新的分支(如从master分支),创建一个dev分支\n```sh\ngit checkout -b dev\n```\n### 从服务器拉取分支到本地分支\n```sh\ngit pull origin gh-pages:gh-pages\n```\n> 需要本地没有gh-pages分支，否则会提示已拒绝\n### 上传本地分支到远程分支\n```sh\ngit branch --set-upstream-to=gh-pages\ngit push origin gh-pages\n```\n","slug":"git","published":1,"date":"2018-02-28T01:29:25.663Z","updated":"2018-02-28T01:29:25.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhb400019vf76itnjxcy","content":"<p>嵌入式笔记：git操作</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>git操作笔记</p>\n<h3 id=\"添加文件\"><a href=\"#添加文件\" class=\"headerlink\" title=\"添加文件\"></a>添加文件</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git add .\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git rm .\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"提交改动到本地\"><a href=\"#提交改动到本地\" class=\"headerlink\" title=\"提交改动到本地\"></a>提交改动到本地</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git commit -m \"first commit\"\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"上传改动到服务器\"><a href=\"#上传改动到服务器\" class=\"headerlink\" title=\"上传改动到服务器\"></a>上传改动到服务器</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git push\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"列出当前分支\"><a href=\"#列出当前分支\" class=\"headerlink\" title=\"列出当前分支\"></a>列出当前分支</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git branch\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"列出所有分支，包括远程分支\"><a href=\"#列出所有分支，包括远程分支\" class=\"headerlink\" title=\"列出所有分支，包括远程分支\"></a>列出所有分支，包括远程分支</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git branch -a\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"从已有的分支创建新的分支-如从master分支-创建一个dev分支\"><a href=\"#从已有的分支创建新的分支-如从master分支-创建一个dev分支\" class=\"headerlink\" title=\"从已有的分支创建新的分支(如从master分支),创建一个dev分支\"></a>从已有的分支创建新的分支(如从master分支),创建一个dev分支</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git checkout -b dev\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"从服务器拉取分支到本地分支\"><a href=\"#从服务器拉取分支到本地分支\" class=\"headerlink\" title=\"从服务器拉取分支到本地分支\"></a>从服务器拉取分支到本地分支</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git pull origin gh-pages:gh-pages\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>需要本地没有gh-pages分支，否则会提示已拒绝</p>\n</blockquote>\n<h3 id=\"上传本地分支到远程分支\"><a href=\"#上传本地分支到远程分支\" class=\"headerlink\" title=\"上传本地分支到远程分支\"></a>上传本地分支到远程分支</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">git branch --set-upstream-to=gh-pages\ngit push origin gh-pages\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：git操作</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>git操作笔记</p>\n<h3 id=\"添加文件\"><a href=\"#添加文件\" class=\"headerlink\" title=\"添加文件\"></a>添加文件</h3><pre><code class=\"sh\">git add .\n</code></pre>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><pre><code class=\"sh\">git rm .\n</code></pre>\n<h3 id=\"提交改动到本地\"><a href=\"#提交改动到本地\" class=\"headerlink\" title=\"提交改动到本地\"></a>提交改动到本地</h3><pre><code class=\"sh\">git commit -m &quot;first commit&quot;\n</code></pre>\n<h3 id=\"上传改动到服务器\"><a href=\"#上传改动到服务器\" class=\"headerlink\" title=\"上传改动到服务器\"></a>上传改动到服务器</h3><pre><code class=\"sh\">git push\n</code></pre>\n<h3 id=\"列出当前分支\"><a href=\"#列出当前分支\" class=\"headerlink\" title=\"列出当前分支\"></a>列出当前分支</h3><pre><code class=\"sh\">git branch\n</code></pre>\n<h3 id=\"列出所有分支，包括远程分支\"><a href=\"#列出所有分支，包括远程分支\" class=\"headerlink\" title=\"列出所有分支，包括远程分支\"></a>列出所有分支，包括远程分支</h3><pre><code class=\"sh\">git branch -a\n</code></pre>\n<h3 id=\"从已有的分支创建新的分支-如从master分支-创建一个dev分支\"><a href=\"#从已有的分支创建新的分支-如从master分支-创建一个dev分支\" class=\"headerlink\" title=\"从已有的分支创建新的分支(如从master分支),创建一个dev分支\"></a>从已有的分支创建新的分支(如从master分支),创建一个dev分支</h3><pre><code class=\"sh\">git checkout -b dev\n</code></pre>\n<h3 id=\"从服务器拉取分支到本地分支\"><a href=\"#从服务器拉取分支到本地分支\" class=\"headerlink\" title=\"从服务器拉取分支到本地分支\"></a>从服务器拉取分支到本地分支</h3><pre><code class=\"sh\">git pull origin gh-pages:gh-pages\n</code></pre>\n<blockquote>\n<p>需要本地没有gh-pages分支，否则会提示已拒绝</p>\n</blockquote>\n<h3 id=\"上传本地分支到远程分支\"><a href=\"#上传本地分支到远程分支\" class=\"headerlink\" title=\"上传本地分支到远程分支\"></a>上传本地分支到远程分支</h3><pre><code class=\"sh\">git branch --set-upstream-to=gh-pages\ngit push origin gh-pages\n</code></pre>\n"},{"title":"嵌入式笔记：cortex内核","_content":"嵌入式笔记：cortex内核\n\n# 目录\n* [arm内核发展历史](#arm内核发展历史)\n* [cortexM0系列芯片系统框图](#cortexM0系列芯片系统框图)\n* [通用寄存器](#通用寄存器)\n* [m0特殊寄存器](#m0特殊寄存器)\n* [m3/m4/m7特殊寄存器](#m3/m4/m7特殊寄存器)\n    * [MSP和PSP](#MSP和PSP)\n    * [xPSR](#xPSR)\n    * [PRIMASK](#PRIMASK)\n    * [CONTROL](#CONTROL)\n    * [FAULTMASK](#FAULTMASK)\n    * [BASEPRI](#BASEPRI)\n* [栈空间操作](#栈空间操作)\n* [异常和中断](#异常和中断)\n    * [系统异常](#系统异常)\n* [NVIC可嵌套向量中断控制器](#NVIC可嵌套向量中断控制器)\n* [系统操作寄存器](#系统操作寄存器)\n    * [NVIC寄存器](#NVIC寄存器)\n    * [系统控制块SCB寄存器](#系统控制块SCB寄存器)\n    * [SysTick寄存器](#SysTick寄存器)\n* [cortex-m0启动流程](#cortex-m0启动流程)\n* [中断向量表](#中断向量表)\n* [大小端](#大小端)\n* [堆栈](#堆栈)\n    * [压栈的寄存器](#压栈的寄存器)\n* [杂项指令集](#杂项指令集)\n* [M0/M3/M4/M7区别](#M0/M3/M4/M7区别)\n* [M3系统框图](#M3系统框图)\n* [M3快速开关中断汇编指令](#M3快速开关中断汇编指令)\n* [M3内核CONTROL寄存器](#M3内核CONTROL寄存器)\n* [异常和中断](#异常和中断)\n* [MPU存储器保护单元](#MPU存储器保护单元)\n\n## arm内核发展历史\n|arm内核|架构|\n|--|---|\n|arm7|armv6|\n|cortex-m0|armv6-m|\n|cortex-m0+|armv6-m|\n|cortex-m3|armv7-m|\n|cortex-m4|armv7-m|\n|cortex-m7|armv7-m|\n|arm9|ARMv6|\n|arm11|ARMv6|\n|arm12|ARMv6|\n|cortex-a7|armv7-a|\n|cortex-a8|armv7-a|\n|cortex-a9|armv7-a|\n|cortex-a15|armv7-a|\n|cortex-A17|armv7-a|\n|cortex-A53|armv8|\n|cortex-A57|armv8|\n|cortex-A72|armv8|\n\n## cortexM0系列芯片系统框图\n![M0系统框图](../res/cortex-m0系统框图.png)\n系统中包括：\n* 中断控制器\n* M0内核\n* AHB总线\n* 存储器和外设\n* 电源管理\n* 时钟树\n* 调试系统\n\n## 通用寄存器\n<table>\n    <tr>\n        <td>R0</td>\n        <td>R1</td>\n        <td>R2</td>\n        <td>R3</td>\n        <td>R4</td>\n        <td>R5</td>\n        <td>R6</td>\n        <td>R7</td>\n        <td>R8</td>\n        <td>R9</td>\n        <td>R10</td>\n        <td>R11</td>\n        <td>R12</td>\n    </tr>\n</table>\n\n## m0特殊寄存器\n<table>\n    <tr>\n        <td>SP(R13)</td>\n        <td>LR(R14)</td>\n        <td>PC(R15)</td>\n        <td>CONTROL</td>\n        <td>xPSR</td>\n        <td>PRIMASK</td>\n    </tr>\n</table>\n\n## m3/m4/m7特殊寄存器\n<table>\n    <tr>\n        <td>SP(R13)</td>\n        <td>LR(R14)</td>\n        <td>PC(R15)</td>\n        <td>CONTROL</td>\n        <td>xPSR</td>\n        <td>PRIMASK</td>\n        <td>FAULTMASK</td>\n        <td>BASEPRI</td>\n    </tr>\n</table>\n\n### MSP和PSP\n    msp中断中会使用，psp用于线程栈使用，通过配置CONTROL寄存器切换。\n    系统复位后默认使用msp，中断中也使用msp。\n\n### xPSR\n    IPSR可以用来判断当前处于什么中断。\n\n### PRIMASK\n    中断屏蔽寄存器，写1屏蔽所有中断(除了不可屏蔽中断和hardfault)\n\n### CONTROL\n    第1bit写1表示切换成PSP\n\n### FAULTMASK\n屏蔽所有的fault (NMI不受影响)\n\n### BASEPRI\n屏蔽所有优先级不高于某个具体数值的中断\n\n## 栈空间操作\n    栈向下递减\n    栈指针始终指向栈的最后一个数据，每次执行数据存储前(push)，SP会首先减小\n\n## 异常和中断\n> m0最多支持32个外部中断\n### 系统异常\n> 主要用于操作系统和错误处理\n\n|异常类型|异常编号|说明|\n|---|:---:|---|\n|reset      |1 |上电复位、系统复位 |\n|NMI        |2 |不可屏蔽中断      |\n|hardfault  |3 |硬件错误        |\n|SVCall     |11|系统调用        |\n|PendSV     |13|挂起系统调用    |\n|systick    |15|系统滴答        |\n\n## NVIC可嵌套向量中断控制器\n* 中断可嵌套\n* 相同优先级的中断不可嵌套\n* 相同中断不可嵌套\n\n## 系统操作寄存器\n实际上是许多的系统管理的寄存器\n|地址范围|寄存器说明|\n|---|----|\n|0xE000E008 - 0xE000E00F|System Control Block Table|\n|0xE000E010 - 0xE000E01F|预留|\n|0xE000E010 - 0xE000E01F|SysTick操作寄存器|\n|0xE000E100 - 0xE000E4EF|NVIC操作寄存器|\n|0xE000ED00 - 0xE000ED3F|系统控制块|\n|0xE000EF00 - 0xE000EF03|NVIC|\n\n### NVIC寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000E100 |ISER |中断使能寄存器|\n|0xE000E180 |ICER |中断失能寄存器|\n|0xE000E200 |ISPR |中断挂起寄存器|\n|0xE000E280 |ICPR |清除挂起中断的寄存器|\n|0xE000E400 - 0xE000E41C |IPR0-7 |中断优先级配置寄存器|\n\n### 系统控制块SCB寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000ED00 |CPUID |CPUID|\n|0xE000ED04 |ICSR |中断控制和状态寄存器|\n|0xE000ED0C |AIRCR |应用中断和复位的寄存器|\n|0xE000ED10 |SCR |系统控制寄存器|\n|0xE000ED14 |CCR |配置控制寄存器|\n|0xE000ED1C |SHPR2 |System Handler Priority Register 2|\n|0xE000ED20 |SHPR3 |System Handler Priority Register 3|\n\n### SysTick寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000E010 |SYST_CSR |SysTick控制和状态寄存器|\n|0xE000E014 |SYST_RVR |SysTick重载寄存器|\n|0xE000E018 |SYST_CVR |SysTick当前值寄存器|\n|0xE000E01C |SYST_CALIB |SysTick校准寄存器|\n\n## cortex-m0启动流程\n1. 程序从0x00000000地址开始执行\n2. m0从程序bin文件的开始处第2个word运行reset_handler\n3. reset_handler函数开始执行一些必要的初始化（ramfunc函数复制，堆初始化，全局、静态变量初始化等）\n4. 跳转到main函数中\n\n## 中断向量表\n<table>\n    <tr><td>sp指针</td></tr>\n    <tr><td>resetHandler地址</td></tr>\n    <tr><td>NMIHandler地址</td></tr>\n    <tr><td>hardfault地址</td></tr>\n    <tr><td>reserved</td></tr>\n    <tr><td>systickHandler地址</td></tr>\n    <tr><td>......</td></tr>\n</table>\n\n## 大小端\n    m0支持大端模式和小端模式，不过一般芯片公司选择小端模式。\n\n## 堆栈\n    堆向上增长\n    栈向下增长\n\n### 压栈的寄存器\n\n<table>\n    <tr><td>xPSR</td></tr>\n    <tr><td>PC</td></tr>\n    <tr><td>LR</td></tr>\n    <tr><td>R12</td></tr>\n    <tr><td>R3</td></tr>\n    <tr><td>R2</td></tr>\n    <tr><td>R1</td></tr>\n    <tr><td>R0</td></tr>\n</table>\n\n## 杂项指令集\n|指令| 说明|\n|:--:|---|\n|BKPT|断点|\n|CPSID|关闭总中断|\n|CPSIE|打开总中断|\n|DMB|数据存储器隔离 仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的存储器访问操作|\n|DSB|数据同步隔离，比DMB更严格:仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的指令|\n|ISB|指令同步隔离，最严格: 会清洗流水线，保证所有它前面的指令都执行完毕之后，才执行后面的指令。|\n|MRS|从特殊寄存器读取数据到通用寄存器|\n|MSR|从通用寄存器读取数据到特殊寄存器|\n|NOP|空转指令|\n|SEV|产生event|\n|SVC|产生SVC系统调用中断|\n|WFE|等待event|\n|WFI|等待中断|\n\n## M0/M3/M4/M7区别\nM0 armv6-M架构\n\nM3 armv7-M架构\n多了basepri寄存器可以阻止某优先级或更低的优先级的中断。\nfaultmask寄存器提供了更多的错误管理特性。\nCONTROL寄存器的bit0用于决定是特权模式还是用户线程模式\n32为thumb指令\n位段特性\n位域处理\n多处理器支持\n最多240个中断\n硬件除法\n存储器保护单元\n更多的调试和跟踪特性\n\n\nM4 armv7-M架构\n浮点特性\nSIMD指令(单周期多指令)\n饱和算法\n单周期MAC(MAC乘法累加)\n\n|特性|M0|M3|M4|M7|\n|-|-|-|-|-|\n|basepr|||||\n\n## M3系统框图\n![M3系统框图](../res/cortex-m3系统框图.png)\n\n## M3快速开关中断汇编指令\n|指令|效果|说明|\n|--|--|--|\n|CPSID I|PRIMASK=1|关中断|\n|CPSIE I|PRIMASK=0|开中断|\n|CPSID F|FAULTMASK=1|关异常|\n|CPSIE F|FAULTMASK=0|开异常|\n\n## M3内核CONTROL寄存器\n* CONTROL[1]\n    堆栈指针选择\n    0=选择主堆栈指针 MSP(复位后缺省值) \n    1=选择进程堆栈指针 PSP \n    在线程或基础级(没有在响应异常——译注),可以使用 PSP。在 handler 模式下,只允许使用 MSP,所以此时不得往该位写 1。 \n* CONTROL[0]\n    0=特权级的线程模式 \n    1=用户级的线程模式 \n    Handler 模式永远都是特权级的。 \n\n## 异常和中断\n> Cortex‐M3 支持大量异常,包括 16‐4‐1=11 个系统异常,和最多 240 个外部中断——简称 IRQ。\n\n|编号|类型|优先级|简介|\n|-|-|-|-|\n|0 |N/A |N/A |没有异常在运行|\n|1 |复位 |-3(最高) |复位|\n|2 |NMI |-2 |不可屏蔽中断(来自外部 NMI 输入脚)|\n|3 |硬(hard) fault| -1 |所有被除能的 fault,都将“上访”成硬 fault。除能的原因包括当前被禁用,或者 FAULTMASK 被置位。\n|4|MemManage|可编程|fault\n|5|存储器管理fault|可编程|MPU 访问犯规以及访问非法位置均可引发。企图在“非执行区”取指也会引发此 fault总线 fault从总线系统收到了错误响应,原因可以是预取流产(Abort)或数据流产,或者企图访问协处理器\n|6|用法(usage)|可编程|Fault|由于程序错误导致的异常。通常是使用了一条无效指令,或者是非法的状态转换,例如尝试切换到 ARM 状态\n|7-10 |保留 |N/A |N/A|\n|11 |SVCall |可编程 |执行系统服务调用指令(SVC)引发的异常|\n|12 |调试监视器 |可编程 |调试监视器(断点,数据观察点,或者是外部调试请求|\n|13 |保留 |N/A |N/A|\n|14 |PendSV |可编程 |为系统设备而设的“可悬挂请求”(pendable request)|\n|15 |SysTick |可编程 |系统滴答定时器(也就是周期性溢出的时基定时器——译注)|\n|16 |IRQ |#0 |可编程 |外中断#0|\n|17 |IRQ |#1 |可编程 |外中断#1|\n|... |... |... |... |\n|255 |IRQ |#239 |可编程 |外中断#239|\n\n## MPU存储器保护单元\nCortex‐M3 有一个可选的存储器保护单元。配上它之后,就可以对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规(violated)时,MPU 就会产生一个 fault 异常,可以由 fault异常的服务例程来分析该错误,并且在可能时改正它。MPU 有很多玩法。最常见的就是由操作系统使用 MPU,以使特权级代码的数据,包括操作系统本身的数据不被其它用户程序弄坏。MPU 在保护内存时是按区管理的(“区”的原文是 region,以后不再中译此名词——译注)。它可以把某些内存 region 设置成只读,从而避免了那里的内容意外被更改;还可以在多任务系统中把不同任务之间的数据区隔离。一句话,它会使嵌入式系统变得更加健壮,更加可靠(很多行业标准,尤其是航空的,就规定了必须使用 MPU 来行使保护职能——译注)。\n","source":"_posts/cortex.md","raw":"---\ntitle: 嵌入式笔记：cortex内核\n---\n嵌入式笔记：cortex内核\n\n# 目录\n* [arm内核发展历史](#arm内核发展历史)\n* [cortexM0系列芯片系统框图](#cortexM0系列芯片系统框图)\n* [通用寄存器](#通用寄存器)\n* [m0特殊寄存器](#m0特殊寄存器)\n* [m3/m4/m7特殊寄存器](#m3/m4/m7特殊寄存器)\n    * [MSP和PSP](#MSP和PSP)\n    * [xPSR](#xPSR)\n    * [PRIMASK](#PRIMASK)\n    * [CONTROL](#CONTROL)\n    * [FAULTMASK](#FAULTMASK)\n    * [BASEPRI](#BASEPRI)\n* [栈空间操作](#栈空间操作)\n* [异常和中断](#异常和中断)\n    * [系统异常](#系统异常)\n* [NVIC可嵌套向量中断控制器](#NVIC可嵌套向量中断控制器)\n* [系统操作寄存器](#系统操作寄存器)\n    * [NVIC寄存器](#NVIC寄存器)\n    * [系统控制块SCB寄存器](#系统控制块SCB寄存器)\n    * [SysTick寄存器](#SysTick寄存器)\n* [cortex-m0启动流程](#cortex-m0启动流程)\n* [中断向量表](#中断向量表)\n* [大小端](#大小端)\n* [堆栈](#堆栈)\n    * [压栈的寄存器](#压栈的寄存器)\n* [杂项指令集](#杂项指令集)\n* [M0/M3/M4/M7区别](#M0/M3/M4/M7区别)\n* [M3系统框图](#M3系统框图)\n* [M3快速开关中断汇编指令](#M3快速开关中断汇编指令)\n* [M3内核CONTROL寄存器](#M3内核CONTROL寄存器)\n* [异常和中断](#异常和中断)\n* [MPU存储器保护单元](#MPU存储器保护单元)\n\n## arm内核发展历史\n|arm内核|架构|\n|--|---|\n|arm7|armv6|\n|cortex-m0|armv6-m|\n|cortex-m0+|armv6-m|\n|cortex-m3|armv7-m|\n|cortex-m4|armv7-m|\n|cortex-m7|armv7-m|\n|arm9|ARMv6|\n|arm11|ARMv6|\n|arm12|ARMv6|\n|cortex-a7|armv7-a|\n|cortex-a8|armv7-a|\n|cortex-a9|armv7-a|\n|cortex-a15|armv7-a|\n|cortex-A17|armv7-a|\n|cortex-A53|armv8|\n|cortex-A57|armv8|\n|cortex-A72|armv8|\n\n## cortexM0系列芯片系统框图\n![M0系统框图](../res/cortex-m0系统框图.png)\n系统中包括：\n* 中断控制器\n* M0内核\n* AHB总线\n* 存储器和外设\n* 电源管理\n* 时钟树\n* 调试系统\n\n## 通用寄存器\n<table>\n    <tr>\n        <td>R0</td>\n        <td>R1</td>\n        <td>R2</td>\n        <td>R3</td>\n        <td>R4</td>\n        <td>R5</td>\n        <td>R6</td>\n        <td>R7</td>\n        <td>R8</td>\n        <td>R9</td>\n        <td>R10</td>\n        <td>R11</td>\n        <td>R12</td>\n    </tr>\n</table>\n\n## m0特殊寄存器\n<table>\n    <tr>\n        <td>SP(R13)</td>\n        <td>LR(R14)</td>\n        <td>PC(R15)</td>\n        <td>CONTROL</td>\n        <td>xPSR</td>\n        <td>PRIMASK</td>\n    </tr>\n</table>\n\n## m3/m4/m7特殊寄存器\n<table>\n    <tr>\n        <td>SP(R13)</td>\n        <td>LR(R14)</td>\n        <td>PC(R15)</td>\n        <td>CONTROL</td>\n        <td>xPSR</td>\n        <td>PRIMASK</td>\n        <td>FAULTMASK</td>\n        <td>BASEPRI</td>\n    </tr>\n</table>\n\n### MSP和PSP\n    msp中断中会使用，psp用于线程栈使用，通过配置CONTROL寄存器切换。\n    系统复位后默认使用msp，中断中也使用msp。\n\n### xPSR\n    IPSR可以用来判断当前处于什么中断。\n\n### PRIMASK\n    中断屏蔽寄存器，写1屏蔽所有中断(除了不可屏蔽中断和hardfault)\n\n### CONTROL\n    第1bit写1表示切换成PSP\n\n### FAULTMASK\n屏蔽所有的fault (NMI不受影响)\n\n### BASEPRI\n屏蔽所有优先级不高于某个具体数值的中断\n\n## 栈空间操作\n    栈向下递减\n    栈指针始终指向栈的最后一个数据，每次执行数据存储前(push)，SP会首先减小\n\n## 异常和中断\n> m0最多支持32个外部中断\n### 系统异常\n> 主要用于操作系统和错误处理\n\n|异常类型|异常编号|说明|\n|---|:---:|---|\n|reset      |1 |上电复位、系统复位 |\n|NMI        |2 |不可屏蔽中断      |\n|hardfault  |3 |硬件错误        |\n|SVCall     |11|系统调用        |\n|PendSV     |13|挂起系统调用    |\n|systick    |15|系统滴答        |\n\n## NVIC可嵌套向量中断控制器\n* 中断可嵌套\n* 相同优先级的中断不可嵌套\n* 相同中断不可嵌套\n\n## 系统操作寄存器\n实际上是许多的系统管理的寄存器\n|地址范围|寄存器说明|\n|---|----|\n|0xE000E008 - 0xE000E00F|System Control Block Table|\n|0xE000E010 - 0xE000E01F|预留|\n|0xE000E010 - 0xE000E01F|SysTick操作寄存器|\n|0xE000E100 - 0xE000E4EF|NVIC操作寄存器|\n|0xE000ED00 - 0xE000ED3F|系统控制块|\n|0xE000EF00 - 0xE000EF03|NVIC|\n\n### NVIC寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000E100 |ISER |中断使能寄存器|\n|0xE000E180 |ICER |中断失能寄存器|\n|0xE000E200 |ISPR |中断挂起寄存器|\n|0xE000E280 |ICPR |清除挂起中断的寄存器|\n|0xE000E400 - 0xE000E41C |IPR0-7 |中断优先级配置寄存器|\n\n### 系统控制块SCB寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000ED00 |CPUID |CPUID|\n|0xE000ED04 |ICSR |中断控制和状态寄存器|\n|0xE000ED0C |AIRCR |应用中断和复位的寄存器|\n|0xE000ED10 |SCR |系统控制寄存器|\n|0xE000ED14 |CCR |配置控制寄存器|\n|0xE000ED1C |SHPR2 |System Handler Priority Register 2|\n|0xE000ED20 |SHPR3 |System Handler Priority Register 3|\n\n### SysTick寄存器\n|地址|寄存器名称|说明|\n|----|:-----:|-----|\n|0xE000E010 |SYST_CSR |SysTick控制和状态寄存器|\n|0xE000E014 |SYST_RVR |SysTick重载寄存器|\n|0xE000E018 |SYST_CVR |SysTick当前值寄存器|\n|0xE000E01C |SYST_CALIB |SysTick校准寄存器|\n\n## cortex-m0启动流程\n1. 程序从0x00000000地址开始执行\n2. m0从程序bin文件的开始处第2个word运行reset_handler\n3. reset_handler函数开始执行一些必要的初始化（ramfunc函数复制，堆初始化，全局、静态变量初始化等）\n4. 跳转到main函数中\n\n## 中断向量表\n<table>\n    <tr><td>sp指针</td></tr>\n    <tr><td>resetHandler地址</td></tr>\n    <tr><td>NMIHandler地址</td></tr>\n    <tr><td>hardfault地址</td></tr>\n    <tr><td>reserved</td></tr>\n    <tr><td>systickHandler地址</td></tr>\n    <tr><td>......</td></tr>\n</table>\n\n## 大小端\n    m0支持大端模式和小端模式，不过一般芯片公司选择小端模式。\n\n## 堆栈\n    堆向上增长\n    栈向下增长\n\n### 压栈的寄存器\n\n<table>\n    <tr><td>xPSR</td></tr>\n    <tr><td>PC</td></tr>\n    <tr><td>LR</td></tr>\n    <tr><td>R12</td></tr>\n    <tr><td>R3</td></tr>\n    <tr><td>R2</td></tr>\n    <tr><td>R1</td></tr>\n    <tr><td>R0</td></tr>\n</table>\n\n## 杂项指令集\n|指令| 说明|\n|:--:|---|\n|BKPT|断点|\n|CPSID|关闭总中断|\n|CPSIE|打开总中断|\n|DMB|数据存储器隔离 仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的存储器访问操作|\n|DSB|数据同步隔离，比DMB更严格:仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的指令|\n|ISB|指令同步隔离，最严格: 会清洗流水线，保证所有它前面的指令都执行完毕之后，才执行后面的指令。|\n|MRS|从特殊寄存器读取数据到通用寄存器|\n|MSR|从通用寄存器读取数据到特殊寄存器|\n|NOP|空转指令|\n|SEV|产生event|\n|SVC|产生SVC系统调用中断|\n|WFE|等待event|\n|WFI|等待中断|\n\n## M0/M3/M4/M7区别\nM0 armv6-M架构\n\nM3 armv7-M架构\n多了basepri寄存器可以阻止某优先级或更低的优先级的中断。\nfaultmask寄存器提供了更多的错误管理特性。\nCONTROL寄存器的bit0用于决定是特权模式还是用户线程模式\n32为thumb指令\n位段特性\n位域处理\n多处理器支持\n最多240个中断\n硬件除法\n存储器保护单元\n更多的调试和跟踪特性\n\n\nM4 armv7-M架构\n浮点特性\nSIMD指令(单周期多指令)\n饱和算法\n单周期MAC(MAC乘法累加)\n\n|特性|M0|M3|M4|M7|\n|-|-|-|-|-|\n|basepr|||||\n\n## M3系统框图\n![M3系统框图](../res/cortex-m3系统框图.png)\n\n## M3快速开关中断汇编指令\n|指令|效果|说明|\n|--|--|--|\n|CPSID I|PRIMASK=1|关中断|\n|CPSIE I|PRIMASK=0|开中断|\n|CPSID F|FAULTMASK=1|关异常|\n|CPSIE F|FAULTMASK=0|开异常|\n\n## M3内核CONTROL寄存器\n* CONTROL[1]\n    堆栈指针选择\n    0=选择主堆栈指针 MSP(复位后缺省值) \n    1=选择进程堆栈指针 PSP \n    在线程或基础级(没有在响应异常——译注),可以使用 PSP。在 handler 模式下,只允许使用 MSP,所以此时不得往该位写 1。 \n* CONTROL[0]\n    0=特权级的线程模式 \n    1=用户级的线程模式 \n    Handler 模式永远都是特权级的。 \n\n## 异常和中断\n> Cortex‐M3 支持大量异常,包括 16‐4‐1=11 个系统异常,和最多 240 个外部中断——简称 IRQ。\n\n|编号|类型|优先级|简介|\n|-|-|-|-|\n|0 |N/A |N/A |没有异常在运行|\n|1 |复位 |-3(最高) |复位|\n|2 |NMI |-2 |不可屏蔽中断(来自外部 NMI 输入脚)|\n|3 |硬(hard) fault| -1 |所有被除能的 fault,都将“上访”成硬 fault。除能的原因包括当前被禁用,或者 FAULTMASK 被置位。\n|4|MemManage|可编程|fault\n|5|存储器管理fault|可编程|MPU 访问犯规以及访问非法位置均可引发。企图在“非执行区”取指也会引发此 fault总线 fault从总线系统收到了错误响应,原因可以是预取流产(Abort)或数据流产,或者企图访问协处理器\n|6|用法(usage)|可编程|Fault|由于程序错误导致的异常。通常是使用了一条无效指令,或者是非法的状态转换,例如尝试切换到 ARM 状态\n|7-10 |保留 |N/A |N/A|\n|11 |SVCall |可编程 |执行系统服务调用指令(SVC)引发的异常|\n|12 |调试监视器 |可编程 |调试监视器(断点,数据观察点,或者是外部调试请求|\n|13 |保留 |N/A |N/A|\n|14 |PendSV |可编程 |为系统设备而设的“可悬挂请求”(pendable request)|\n|15 |SysTick |可编程 |系统滴答定时器(也就是周期性溢出的时基定时器——译注)|\n|16 |IRQ |#0 |可编程 |外中断#0|\n|17 |IRQ |#1 |可编程 |外中断#1|\n|... |... |... |... |\n|255 |IRQ |#239 |可编程 |外中断#239|\n\n## MPU存储器保护单元\nCortex‐M3 有一个可选的存储器保护单元。配上它之后,就可以对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规(violated)时,MPU 就会产生一个 fault 异常,可以由 fault异常的服务例程来分析该错误,并且在可能时改正它。MPU 有很多玩法。最常见的就是由操作系统使用 MPU,以使特权级代码的数据,包括操作系统本身的数据不被其它用户程序弄坏。MPU 在保护内存时是按区管理的(“区”的原文是 region,以后不再中译此名词——译注)。它可以把某些内存 region 设置成只读,从而避免了那里的内容意外被更改;还可以在多任务系统中把不同任务之间的数据区隔离。一句话,它会使嵌入式系统变得更加健壮,更加可靠(很多行业标准,尤其是航空的,就规定了必须使用 MPU 来行使保护职能——译注)。\n","slug":"cortex","published":1,"date":"2018-02-28T01:20:20.386Z","updated":"2018-02-28T01:17:19.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhb600029vf7qgvbrl6p","content":"<p>嵌入式笔记：cortex内核</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#arm内核发展历史\">arm内核发展历史</a></li>\n<li><a href=\"#cortexM0系列芯片系统框图\">cortexM0系列芯片系统框图</a></li>\n<li><a href=\"#通用寄存器\">通用寄存器</a></li>\n<li><a href=\"#m0特殊寄存器\">m0特殊寄存器</a></li>\n<li><a href=\"#m3/m4/m7特殊寄存器\">m3/m4/m7特殊寄存器</a><ul>\n<li><a href=\"#MSP和PSP\">MSP和PSP</a></li>\n<li><a href=\"#xPSR\">xPSR</a></li>\n<li><a href=\"#PRIMASK\">PRIMASK</a></li>\n<li><a href=\"#CONTROL\">CONTROL</a></li>\n<li><a href=\"#FAULTMASK\">FAULTMASK</a></li>\n<li><a href=\"#BASEPRI\">BASEPRI</a></li>\n</ul>\n</li>\n<li><a href=\"#栈空间操作\">栈空间操作</a></li>\n<li><a href=\"#异常和中断\">异常和中断</a><ul>\n<li><a href=\"#系统异常\">系统异常</a></li>\n</ul>\n</li>\n<li><a href=\"#NVIC可嵌套向量中断控制器\">NVIC可嵌套向量中断控制器</a></li>\n<li><a href=\"#系统操作寄存器\">系统操作寄存器</a><ul>\n<li><a href=\"#NVIC寄存器\">NVIC寄存器</a></li>\n<li><a href=\"#系统控制块SCB寄存器\">系统控制块SCB寄存器</a></li>\n<li><a href=\"#SysTick寄存器\">SysTick寄存器</a></li>\n</ul>\n</li>\n<li><a href=\"#cortex-m0启动流程\">cortex-m0启动流程</a></li>\n<li><a href=\"#中断向量表\">中断向量表</a></li>\n<li><a href=\"#大小端\">大小端</a></li>\n<li><a href=\"#堆栈\">堆栈</a><ul>\n<li><a href=\"#压栈的寄存器\">压栈的寄存器</a></li>\n</ul>\n</li>\n<li><a href=\"#杂项指令集\">杂项指令集</a></li>\n<li><a href=\"#M0/M3/M4/M7区别\">M0/M3/M4/M7区别</a></li>\n<li><a href=\"#M3系统框图\">M3系统框图</a></li>\n<li><a href=\"#M3快速开关中断汇编指令\">M3快速开关中断汇编指令</a></li>\n<li><a href=\"#M3内核CONTROL寄存器\">M3内核CONTROL寄存器</a></li>\n<li><a href=\"#异常和中断\">异常和中断</a></li>\n<li><a href=\"#MPU存储器保护单元\">MPU存储器保护单元</a></li>\n</ul>\n<h2 id=\"arm内核发展历史\"><a href=\"#arm内核发展历史\" class=\"headerlink\" title=\"arm内核发展历史\"></a>arm内核发展历史</h2><table>\n<thead>\n<tr>\n<th>arm内核</th>\n<th>架构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arm7</td>\n<td>armv6</td>\n</tr>\n<tr>\n<td>cortex-m0</td>\n<td>armv6-m</td>\n</tr>\n<tr>\n<td>cortex-m0+</td>\n<td>armv6-m</td>\n</tr>\n<tr>\n<td>cortex-m3</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>cortex-m4</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>cortex-m7</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>arm9</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>arm11</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>arm12</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>cortex-a7</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a8</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a9</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a15</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-A17</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-A53</td>\n<td>armv8</td>\n</tr>\n<tr>\n<td>cortex-A57</td>\n<td>armv8</td>\n</tr>\n<tr>\n<td>cortex-A72</td>\n<td>armv8</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cortexM0系列芯片系统框图\"><a href=\"#cortexM0系列芯片系统框图\" class=\"headerlink\" title=\"cortexM0系列芯片系统框图\"></a>cortexM0系列芯片系统框图</h2><p><img src=\"../res/cortex-m0系统框图.png\" alt=\"M0系统框图\"><br>系统中包括：</p>\n<ul>\n<li>中断控制器</li>\n<li>M0内核</li>\n<li>AHB总线</li>\n<li>存储器和外设</li>\n<li>电源管理</li>\n<li>时钟树</li>\n<li>调试系统</li>\n</ul>\n<h2 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h2><table><br>    <tr><br>        <td>R0</td><br>        <td>R1</td><br>        <td>R2</td><br>        <td>R3</td><br>        <td>R4</td><br>        <td>R5</td><br>        <td>R6</td><br>        <td>R7</td><br>        <td>R8</td><br>        <td>R9</td><br>        <td>R10</td><br>        <td>R11</td><br>        <td>R12</td><br>    </tr><br></table>\n\n<h2 id=\"m0特殊寄存器\"><a href=\"#m0特殊寄存器\" class=\"headerlink\" title=\"m0特殊寄存器\"></a>m0特殊寄存器</h2><table><br>    <tr><br>        <td>SP(R13)</td><br>        <td>LR(R14)</td><br>        <td>PC(R15)</td><br>        <td>CONTROL</td><br>        <td>xPSR</td><br>        <td>PRIMASK</td><br>    </tr><br></table>\n\n<h2 id=\"m3-m4-m7特殊寄存器\"><a href=\"#m3-m4-m7特殊寄存器\" class=\"headerlink\" title=\"m3/m4/m7特殊寄存器\"></a>m3/m4/m7特殊寄存器</h2><table><br>    <tr><br>        <td>SP(R13)</td><br>        <td>LR(R14)</td><br>        <td>PC(R15)</td><br>        <td>CONTROL</td><br>        <td>xPSR</td><br>        <td>PRIMASK</td><br>        <td>FAULTMASK</td><br>        <td>BASEPRI</td><br>    </tr><br></table>\n\n<h3 id=\"MSP和PSP\"><a href=\"#MSP和PSP\" class=\"headerlink\" title=\"MSP和PSP\"></a>MSP和PSP</h3><pre><code>msp中断中会使用，psp用于线程栈使用，通过配置CONTROL寄存器切换。\n系统复位后默认使用msp，中断中也使用msp。\n</code></pre><h3 id=\"xPSR\"><a href=\"#xPSR\" class=\"headerlink\" title=\"xPSR\"></a>xPSR</h3><pre><code>IPSR可以用来判断当前处于什么中断。\n</code></pre><h3 id=\"PRIMASK\"><a href=\"#PRIMASK\" class=\"headerlink\" title=\"PRIMASK\"></a>PRIMASK</h3><pre><code>中断屏蔽寄存器，写1屏蔽所有中断(除了不可屏蔽中断和hardfault)\n</code></pre><h3 id=\"CONTROL\"><a href=\"#CONTROL\" class=\"headerlink\" title=\"CONTROL\"></a>CONTROL</h3><pre><code>第1bit写1表示切换成PSP\n</code></pre><h3 id=\"FAULTMASK\"><a href=\"#FAULTMASK\" class=\"headerlink\" title=\"FAULTMASK\"></a>FAULTMASK</h3><p>屏蔽所有的fault (NMI不受影响)</p>\n<h3 id=\"BASEPRI\"><a href=\"#BASEPRI\" class=\"headerlink\" title=\"BASEPRI\"></a>BASEPRI</h3><p>屏蔽所有优先级不高于某个具体数值的中断</p>\n<h2 id=\"栈空间操作\"><a href=\"#栈空间操作\" class=\"headerlink\" title=\"栈空间操作\"></a>栈空间操作</h2><pre><code>栈向下递减\n栈指针始终指向栈的最后一个数据，每次执行数据存储前(push)，SP会首先减小\n</code></pre><h2 id=\"异常和中断\"><a href=\"#异常和中断\" class=\"headerlink\" title=\"异常和中断\"></a>异常和中断</h2><blockquote>\n<p>m0最多支持32个外部中断</p>\n</blockquote>\n<h3 id=\"系统异常\"><a href=\"#系统异常\" class=\"headerlink\" title=\"系统异常\"></a>系统异常</h3><blockquote>\n<p>主要用于操作系统和错误处理</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>异常类型</th>\n<th style=\"text-align:center\">异常编号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reset</td>\n<td style=\"text-align:center\">1</td>\n<td>上电复位、系统复位</td>\n</tr>\n<tr>\n<td>NMI</td>\n<td style=\"text-align:center\">2</td>\n<td>不可屏蔽中断</td>\n</tr>\n<tr>\n<td>hardfault</td>\n<td style=\"text-align:center\">3</td>\n<td>硬件错误</td>\n</tr>\n<tr>\n<td>SVCall</td>\n<td style=\"text-align:center\">11</td>\n<td>系统调用</td>\n</tr>\n<tr>\n<td>PendSV</td>\n<td style=\"text-align:center\">13</td>\n<td>挂起系统调用</td>\n</tr>\n<tr>\n<td>systick</td>\n<td style=\"text-align:center\">15</td>\n<td>系统滴答</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"NVIC可嵌套向量中断控制器\"><a href=\"#NVIC可嵌套向量中断控制器\" class=\"headerlink\" title=\"NVIC可嵌套向量中断控制器\"></a>NVIC可嵌套向量中断控制器</h2><ul>\n<li>中断可嵌套</li>\n<li>相同优先级的中断不可嵌套</li>\n<li>相同中断不可嵌套</li>\n</ul>\n<h2 id=\"系统操作寄存器\"><a href=\"#系统操作寄存器\" class=\"headerlink\" title=\"系统操作寄存器\"></a>系统操作寄存器</h2><p>实际上是许多的系统管理的寄存器<br>|地址范围|寄存器说明|<br>|—|—-|<br>|0xE000E008 - 0xE000E00F|System Control Block Table|<br>|0xE000E010 - 0xE000E01F|预留|<br>|0xE000E010 - 0xE000E01F|SysTick操作寄存器|<br>|0xE000E100 - 0xE000E4EF|NVIC操作寄存器|<br>|0xE000ED00 - 0xE000ED3F|系统控制块|<br>|0xE000EF00 - 0xE000EF03|NVIC|</p>\n<h3 id=\"NVIC寄存器\"><a href=\"#NVIC寄存器\" class=\"headerlink\" title=\"NVIC寄存器\"></a>NVIC寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000E100</td>\n<td style=\"text-align:center\">ISER</td>\n<td>中断使能寄存器</td>\n</tr>\n<tr>\n<td>0xE000E180</td>\n<td style=\"text-align:center\">ICER</td>\n<td>中断失能寄存器</td>\n</tr>\n<tr>\n<td>0xE000E200</td>\n<td style=\"text-align:center\">ISPR</td>\n<td>中断挂起寄存器</td>\n</tr>\n<tr>\n<td>0xE000E280</td>\n<td style=\"text-align:center\">ICPR</td>\n<td>清除挂起中断的寄存器</td>\n</tr>\n<tr>\n<td>0xE000E400 - 0xE000E41C</td>\n<td style=\"text-align:center\">IPR0-7</td>\n<td>中断优先级配置寄存器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"系统控制块SCB寄存器\"><a href=\"#系统控制块SCB寄存器\" class=\"headerlink\" title=\"系统控制块SCB寄存器\"></a>系统控制块SCB寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000ED00</td>\n<td style=\"text-align:center\">CPUID</td>\n<td>CPUID</td>\n</tr>\n<tr>\n<td>0xE000ED04</td>\n<td style=\"text-align:center\">ICSR</td>\n<td>中断控制和状态寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED0C</td>\n<td style=\"text-align:center\">AIRCR</td>\n<td>应用中断和复位的寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED10</td>\n<td style=\"text-align:center\">SCR</td>\n<td>系统控制寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED14</td>\n<td style=\"text-align:center\">CCR</td>\n<td>配置控制寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED1C</td>\n<td style=\"text-align:center\">SHPR2</td>\n<td>System Handler Priority Register 2</td>\n</tr>\n<tr>\n<td>0xE000ED20</td>\n<td style=\"text-align:center\">SHPR3</td>\n<td>System Handler Priority Register 3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"SysTick寄存器\"><a href=\"#SysTick寄存器\" class=\"headerlink\" title=\"SysTick寄存器\"></a>SysTick寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000E010</td>\n<td style=\"text-align:center\">SYST_CSR</td>\n<td>SysTick控制和状态寄存器</td>\n</tr>\n<tr>\n<td>0xE000E014</td>\n<td style=\"text-align:center\">SYST_RVR</td>\n<td>SysTick重载寄存器</td>\n</tr>\n<tr>\n<td>0xE000E018</td>\n<td style=\"text-align:center\">SYST_CVR</td>\n<td>SysTick当前值寄存器</td>\n</tr>\n<tr>\n<td>0xE000E01C</td>\n<td style=\"text-align:center\">SYST_CALIB</td>\n<td>SysTick校准寄存器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cortex-m0启动流程\"><a href=\"#cortex-m0启动流程\" class=\"headerlink\" title=\"cortex-m0启动流程\"></a>cortex-m0启动流程</h2><ol>\n<li>程序从0x00000000地址开始执行</li>\n<li>m0从程序bin文件的开始处第2个word运行reset_handler</li>\n<li>reset_handler函数开始执行一些必要的初始化（ramfunc函数复制，堆初始化，全局、静态变量初始化等）</li>\n<li>跳转到main函数中</li>\n</ol>\n<h2 id=\"中断向量表\"><a href=\"#中断向量表\" class=\"headerlink\" title=\"中断向量表\"></a>中断向量表</h2><table><br>    <tr><td>sp指针</td></tr><br>    <tr><td>resetHandler地址</td></tr><br>    <tr><td>NMIHandler地址</td></tr><br>    <tr><td>hardfault地址</td></tr><br>    <tr><td>reserved</td></tr><br>    <tr><td>systickHandler地址</td></tr><br>    <tr><td>……</td></tr><br></table>\n\n<h2 id=\"大小端\"><a href=\"#大小端\" class=\"headerlink\" title=\"大小端\"></a>大小端</h2><pre><code>m0支持大端模式和小端模式，不过一般芯片公司选择小端模式。\n</code></pre><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><pre><code>堆向上增长\n栈向下增长\n</code></pre><h3 id=\"压栈的寄存器\"><a href=\"#压栈的寄存器\" class=\"headerlink\" title=\"压栈的寄存器\"></a>压栈的寄存器</h3><table><br>    <tr><td>xPSR</td></tr><br>    <tr><td>PC</td></tr><br>    <tr><td>LR</td></tr><br>    <tr><td>R12</td></tr><br>    <tr><td>R3</td></tr><br>    <tr><td>R2</td></tr><br>    <tr><td>R1</td></tr><br>    <tr><td>R0</td></tr><br></table>\n\n<h2 id=\"杂项指令集\"><a href=\"#杂项指令集\" class=\"headerlink\" title=\"杂项指令集\"></a>杂项指令集</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">BKPT</td>\n<td>断点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPSID</td>\n<td>关闭总中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPSIE</td>\n<td>打开总中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DMB</td>\n<td>数据存储器隔离 仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的存储器访问操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DSB</td>\n<td>数据同步隔离，比DMB更严格:仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ISB</td>\n<td>指令同步隔离，最严格: 会清洗流水线，保证所有它前面的指令都执行完毕之后，才执行后面的指令。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MRS</td>\n<td>从特殊寄存器读取数据到通用寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSR</td>\n<td>从通用寄存器读取数据到特殊寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NOP</td>\n<td>空转指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SEV</td>\n<td>产生event</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SVC</td>\n<td>产生SVC系统调用中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WFE</td>\n<td>等待event</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WFI</td>\n<td>等待中断</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M0-M3-M4-M7区别\"><a href=\"#M0-M3-M4-M7区别\" class=\"headerlink\" title=\"M0/M3/M4/M7区别\"></a>M0/M3/M4/M7区别</h2><p>M0 armv6-M架构</p>\n<p>M3 armv7-M架构<br>多了basepri寄存器可以阻止某优先级或更低的优先级的中断。<br>faultmask寄存器提供了更多的错误管理特性。<br>CONTROL寄存器的bit0用于决定是特权模式还是用户线程模式<br>32为thumb指令<br>位段特性<br>位域处理<br>多处理器支持<br>最多240个中断<br>硬件除法<br>存储器保护单元<br>更多的调试和跟踪特性</p>\n<p>M4 armv7-M架构<br>浮点特性<br>SIMD指令(单周期多指令)<br>饱和算法<br>单周期MAC(MAC乘法累加)</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>M0</th>\n<th>M3</th>\n<th>M4</th>\n<th>M7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>basepr</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M3系统框图\"><a href=\"#M3系统框图\" class=\"headerlink\" title=\"M3系统框图\"></a>M3系统框图</h2><p><img src=\"../res/cortex-m3系统框图.png\" alt=\"M3系统框图\"></p>\n<h2 id=\"M3快速开关中断汇编指令\"><a href=\"#M3快速开关中断汇编指令\" class=\"headerlink\" title=\"M3快速开关中断汇编指令\"></a>M3快速开关中断汇编指令</h2><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>效果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CPSID I</td>\n<td>PRIMASK=1</td>\n<td>关中断</td>\n</tr>\n<tr>\n<td>CPSIE I</td>\n<td>PRIMASK=0</td>\n<td>开中断</td>\n</tr>\n<tr>\n<td>CPSID F</td>\n<td>FAULTMASK=1</td>\n<td>关异常</td>\n</tr>\n<tr>\n<td>CPSIE F</td>\n<td>FAULTMASK=0</td>\n<td>开异常</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M3内核CONTROL寄存器\"><a href=\"#M3内核CONTROL寄存器\" class=\"headerlink\" title=\"M3内核CONTROL寄存器\"></a>M3内核CONTROL寄存器</h2><ul>\n<li>CONTROL[1]<br>  堆栈指针选择<br>  0=选择主堆栈指针 MSP(复位后缺省值)<br>  1=选择进程堆栈指针 PSP<br>  在线程或基础级(没有在响应异常——译注),可以使用 PSP。在 handler 模式下,只允许使用 MSP,所以此时不得往该位写 1。 </li>\n<li>CONTROL[0]<br>  0=特权级的线程模式<br>  1=用户级的线程模式<br>  Handler 模式永远都是特权级的。 </li>\n</ul>\n<h2 id=\"异常和中断-1\"><a href=\"#异常和中断-1\" class=\"headerlink\" title=\"异常和中断\"></a>异常和中断</h2><blockquote>\n<p>Cortex‐M3 支持大量异常,包括 16‐4‐1=11 个系统异常,和最多 240 个外部中断——简称 IRQ。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>类型</th>\n<th>优先级</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>没有异常在运行</td>\n</tr>\n<tr>\n<td>1</td>\n<td>复位</td>\n<td>-3(最高)</td>\n<td>复位</td>\n</tr>\n<tr>\n<td>2</td>\n<td>NMI</td>\n<td>-2</td>\n<td>不可屏蔽中断(来自外部 NMI 输入脚)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>硬(hard) fault</td>\n<td>-1</td>\n<td>所有被除能的 fault,都将“上访”成硬 fault。除能的原因包括当前被禁用,或者 FAULTMASK 被置位。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>MemManage</td>\n<td>可编程</td>\n<td>fault</td>\n</tr>\n<tr>\n<td>5</td>\n<td>存储器管理fault</td>\n<td>可编程</td>\n<td>MPU 访问犯规以及访问非法位置均可引发。企图在“非执行区”取指也会引发此 fault总线 fault从总线系统收到了错误响应,原因可以是预取流产(Abort)或数据流产,或者企图访问协处理器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>用法(usage)</td>\n<td>可编程</td>\n<td>Fault</td>\n<td>由于程序错误导致的异常。通常是使用了一条无效指令,或者是非法的状态转换,例如尝试切换到 ARM 状态</td>\n</tr>\n<tr>\n<td>7-10</td>\n<td>保留</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>11</td>\n<td>SVCall</td>\n<td>可编程</td>\n<td>执行系统服务调用指令(SVC)引发的异常</td>\n</tr>\n<tr>\n<td>12</td>\n<td>调试监视器</td>\n<td>可编程</td>\n<td>调试监视器(断点,数据观察点,或者是外部调试请求</td>\n</tr>\n<tr>\n<td>13</td>\n<td>保留</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>14</td>\n<td>PendSV</td>\n<td>可编程</td>\n<td>为系统设备而设的“可悬挂请求”(pendable request)</td>\n</tr>\n<tr>\n<td>15</td>\n<td>SysTick</td>\n<td>可编程</td>\n<td>系统滴答定时器(也就是周期性溢出的时基定时器——译注)</td>\n</tr>\n<tr>\n<td>16</td>\n<td>IRQ</td>\n<td>#0</td>\n<td>可编程</td>\n<td>外中断#0</td>\n</tr>\n<tr>\n<td>17</td>\n<td>IRQ</td>\n<td>#1</td>\n<td>可编程</td>\n<td>外中断#1</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>255</td>\n<td>IRQ</td>\n<td>#239</td>\n<td>可编程</td>\n<td>外中断#239</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MPU存储器保护单元\"><a href=\"#MPU存储器保护单元\" class=\"headerlink\" title=\"MPU存储器保护单元\"></a>MPU存储器保护单元</h2><p>Cortex‐M3 有一个可选的存储器保护单元。配上它之后,就可以对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规(violated)时,MPU 就会产生一个 fault 异常,可以由 fault异常的服务例程来分析该错误,并且在可能时改正它。MPU 有很多玩法。最常见的就是由操作系统使用 MPU,以使特权级代码的数据,包括操作系统本身的数据不被其它用户程序弄坏。MPU 在保护内存时是按区管理的(“区”的原文是 region,以后不再中译此名词——译注)。它可以把某些内存 region 设置成只读,从而避免了那里的内容意外被更改;还可以在多任务系统中把不同任务之间的数据区隔离。一句话,它会使嵌入式系统变得更加健壮,更加可靠(很多行业标准,尤其是航空的,就规定了必须使用 MPU 来行使保护职能——译注)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：cortex内核</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#arm内核发展历史\">arm内核发展历史</a></li>\n<li><a href=\"#cortexM0系列芯片系统框图\">cortexM0系列芯片系统框图</a></li>\n<li><a href=\"#通用寄存器\">通用寄存器</a></li>\n<li><a href=\"#m0特殊寄存器\">m0特殊寄存器</a></li>\n<li><a href=\"#m3/m4/m7特殊寄存器\">m3/m4/m7特殊寄存器</a><ul>\n<li><a href=\"#MSP和PSP\">MSP和PSP</a></li>\n<li><a href=\"#xPSR\">xPSR</a></li>\n<li><a href=\"#PRIMASK\">PRIMASK</a></li>\n<li><a href=\"#CONTROL\">CONTROL</a></li>\n<li><a href=\"#FAULTMASK\">FAULTMASK</a></li>\n<li><a href=\"#BASEPRI\">BASEPRI</a></li>\n</ul>\n</li>\n<li><a href=\"#栈空间操作\">栈空间操作</a></li>\n<li><a href=\"#异常和中断\">异常和中断</a><ul>\n<li><a href=\"#系统异常\">系统异常</a></li>\n</ul>\n</li>\n<li><a href=\"#NVIC可嵌套向量中断控制器\">NVIC可嵌套向量中断控制器</a></li>\n<li><a href=\"#系统操作寄存器\">系统操作寄存器</a><ul>\n<li><a href=\"#NVIC寄存器\">NVIC寄存器</a></li>\n<li><a href=\"#系统控制块SCB寄存器\">系统控制块SCB寄存器</a></li>\n<li><a href=\"#SysTick寄存器\">SysTick寄存器</a></li>\n</ul>\n</li>\n<li><a href=\"#cortex-m0启动流程\">cortex-m0启动流程</a></li>\n<li><a href=\"#中断向量表\">中断向量表</a></li>\n<li><a href=\"#大小端\">大小端</a></li>\n<li><a href=\"#堆栈\">堆栈</a><ul>\n<li><a href=\"#压栈的寄存器\">压栈的寄存器</a></li>\n</ul>\n</li>\n<li><a href=\"#杂项指令集\">杂项指令集</a></li>\n<li><a href=\"#M0/M3/M4/M7区别\">M0/M3/M4/M7区别</a></li>\n<li><a href=\"#M3系统框图\">M3系统框图</a></li>\n<li><a href=\"#M3快速开关中断汇编指令\">M3快速开关中断汇编指令</a></li>\n<li><a href=\"#M3内核CONTROL寄存器\">M3内核CONTROL寄存器</a></li>\n<li><a href=\"#异常和中断\">异常和中断</a></li>\n<li><a href=\"#MPU存储器保护单元\">MPU存储器保护单元</a></li>\n</ul>\n<h2 id=\"arm内核发展历史\"><a href=\"#arm内核发展历史\" class=\"headerlink\" title=\"arm内核发展历史\"></a>arm内核发展历史</h2><table>\n<thead>\n<tr>\n<th>arm内核</th>\n<th>架构</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>arm7</td>\n<td>armv6</td>\n</tr>\n<tr>\n<td>cortex-m0</td>\n<td>armv6-m</td>\n</tr>\n<tr>\n<td>cortex-m0+</td>\n<td>armv6-m</td>\n</tr>\n<tr>\n<td>cortex-m3</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>cortex-m4</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>cortex-m7</td>\n<td>armv7-m</td>\n</tr>\n<tr>\n<td>arm9</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>arm11</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>arm12</td>\n<td>ARMv6</td>\n</tr>\n<tr>\n<td>cortex-a7</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a8</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a9</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-a15</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-A17</td>\n<td>armv7-a</td>\n</tr>\n<tr>\n<td>cortex-A53</td>\n<td>armv8</td>\n</tr>\n<tr>\n<td>cortex-A57</td>\n<td>armv8</td>\n</tr>\n<tr>\n<td>cortex-A72</td>\n<td>armv8</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cortexM0系列芯片系统框图\"><a href=\"#cortexM0系列芯片系统框图\" class=\"headerlink\" title=\"cortexM0系列芯片系统框图\"></a>cortexM0系列芯片系统框图</h2><p><img src=\"../res/cortex-m0系统框图.png\" alt=\"M0系统框图\"><br>系统中包括：</p>\n<ul>\n<li>中断控制器</li>\n<li>M0内核</li>\n<li>AHB总线</li>\n<li>存储器和外设</li>\n<li>电源管理</li>\n<li>时钟树</li>\n<li>调试系统</li>\n</ul>\n<h2 id=\"通用寄存器\"><a href=\"#通用寄存器\" class=\"headerlink\" title=\"通用寄存器\"></a>通用寄存器</h2><table><br>    <tr><br>        <td>R0</td><br>        <td>R1</td><br>        <td>R2</td><br>        <td>R3</td><br>        <td>R4</td><br>        <td>R5</td><br>        <td>R6</td><br>        <td>R7</td><br>        <td>R8</td><br>        <td>R9</td><br>        <td>R10</td><br>        <td>R11</td><br>        <td>R12</td><br>    </tr><br></table>\n\n<h2 id=\"m0特殊寄存器\"><a href=\"#m0特殊寄存器\" class=\"headerlink\" title=\"m0特殊寄存器\"></a>m0特殊寄存器</h2><table><br>    <tr><br>        <td>SP(R13)</td><br>        <td>LR(R14)</td><br>        <td>PC(R15)</td><br>        <td>CONTROL</td><br>        <td>xPSR</td><br>        <td>PRIMASK</td><br>    </tr><br></table>\n\n<h2 id=\"m3-m4-m7特殊寄存器\"><a href=\"#m3-m4-m7特殊寄存器\" class=\"headerlink\" title=\"m3/m4/m7特殊寄存器\"></a>m3/m4/m7特殊寄存器</h2><table><br>    <tr><br>        <td>SP(R13)</td><br>        <td>LR(R14)</td><br>        <td>PC(R15)</td><br>        <td>CONTROL</td><br>        <td>xPSR</td><br>        <td>PRIMASK</td><br>        <td>FAULTMASK</td><br>        <td>BASEPRI</td><br>    </tr><br></table>\n\n<h3 id=\"MSP和PSP\"><a href=\"#MSP和PSP\" class=\"headerlink\" title=\"MSP和PSP\"></a>MSP和PSP</h3><pre><code>msp中断中会使用，psp用于线程栈使用，通过配置CONTROL寄存器切换。\n系统复位后默认使用msp，中断中也使用msp。\n</code></pre><h3 id=\"xPSR\"><a href=\"#xPSR\" class=\"headerlink\" title=\"xPSR\"></a>xPSR</h3><pre><code>IPSR可以用来判断当前处于什么中断。\n</code></pre><h3 id=\"PRIMASK\"><a href=\"#PRIMASK\" class=\"headerlink\" title=\"PRIMASK\"></a>PRIMASK</h3><pre><code>中断屏蔽寄存器，写1屏蔽所有中断(除了不可屏蔽中断和hardfault)\n</code></pre><h3 id=\"CONTROL\"><a href=\"#CONTROL\" class=\"headerlink\" title=\"CONTROL\"></a>CONTROL</h3><pre><code>第1bit写1表示切换成PSP\n</code></pre><h3 id=\"FAULTMASK\"><a href=\"#FAULTMASK\" class=\"headerlink\" title=\"FAULTMASK\"></a>FAULTMASK</h3><p>屏蔽所有的fault (NMI不受影响)</p>\n<h3 id=\"BASEPRI\"><a href=\"#BASEPRI\" class=\"headerlink\" title=\"BASEPRI\"></a>BASEPRI</h3><p>屏蔽所有优先级不高于某个具体数值的中断</p>\n<h2 id=\"栈空间操作\"><a href=\"#栈空间操作\" class=\"headerlink\" title=\"栈空间操作\"></a>栈空间操作</h2><pre><code>栈向下递减\n栈指针始终指向栈的最后一个数据，每次执行数据存储前(push)，SP会首先减小\n</code></pre><h2 id=\"异常和中断\"><a href=\"#异常和中断\" class=\"headerlink\" title=\"异常和中断\"></a>异常和中断</h2><blockquote>\n<p>m0最多支持32个外部中断</p>\n</blockquote>\n<h3 id=\"系统异常\"><a href=\"#系统异常\" class=\"headerlink\" title=\"系统异常\"></a>系统异常</h3><blockquote>\n<p>主要用于操作系统和错误处理</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>异常类型</th>\n<th style=\"text-align:center\">异常编号</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>reset</td>\n<td style=\"text-align:center\">1</td>\n<td>上电复位、系统复位</td>\n</tr>\n<tr>\n<td>NMI</td>\n<td style=\"text-align:center\">2</td>\n<td>不可屏蔽中断</td>\n</tr>\n<tr>\n<td>hardfault</td>\n<td style=\"text-align:center\">3</td>\n<td>硬件错误</td>\n</tr>\n<tr>\n<td>SVCall</td>\n<td style=\"text-align:center\">11</td>\n<td>系统调用</td>\n</tr>\n<tr>\n<td>PendSV</td>\n<td style=\"text-align:center\">13</td>\n<td>挂起系统调用</td>\n</tr>\n<tr>\n<td>systick</td>\n<td style=\"text-align:center\">15</td>\n<td>系统滴答</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"NVIC可嵌套向量中断控制器\"><a href=\"#NVIC可嵌套向量中断控制器\" class=\"headerlink\" title=\"NVIC可嵌套向量中断控制器\"></a>NVIC可嵌套向量中断控制器</h2><ul>\n<li>中断可嵌套</li>\n<li>相同优先级的中断不可嵌套</li>\n<li>相同中断不可嵌套</li>\n</ul>\n<h2 id=\"系统操作寄存器\"><a href=\"#系统操作寄存器\" class=\"headerlink\" title=\"系统操作寄存器\"></a>系统操作寄存器</h2><p>实际上是许多的系统管理的寄存器<br>|地址范围|寄存器说明|<br>|—|—-|<br>|0xE000E008 - 0xE000E00F|System Control Block Table|<br>|0xE000E010 - 0xE000E01F|预留|<br>|0xE000E010 - 0xE000E01F|SysTick操作寄存器|<br>|0xE000E100 - 0xE000E4EF|NVIC操作寄存器|<br>|0xE000ED00 - 0xE000ED3F|系统控制块|<br>|0xE000EF00 - 0xE000EF03|NVIC|</p>\n<h3 id=\"NVIC寄存器\"><a href=\"#NVIC寄存器\" class=\"headerlink\" title=\"NVIC寄存器\"></a>NVIC寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000E100</td>\n<td style=\"text-align:center\">ISER</td>\n<td>中断使能寄存器</td>\n</tr>\n<tr>\n<td>0xE000E180</td>\n<td style=\"text-align:center\">ICER</td>\n<td>中断失能寄存器</td>\n</tr>\n<tr>\n<td>0xE000E200</td>\n<td style=\"text-align:center\">ISPR</td>\n<td>中断挂起寄存器</td>\n</tr>\n<tr>\n<td>0xE000E280</td>\n<td style=\"text-align:center\">ICPR</td>\n<td>清除挂起中断的寄存器</td>\n</tr>\n<tr>\n<td>0xE000E400 - 0xE000E41C</td>\n<td style=\"text-align:center\">IPR0-7</td>\n<td>中断优先级配置寄存器</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"系统控制块SCB寄存器\"><a href=\"#系统控制块SCB寄存器\" class=\"headerlink\" title=\"系统控制块SCB寄存器\"></a>系统控制块SCB寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000ED00</td>\n<td style=\"text-align:center\">CPUID</td>\n<td>CPUID</td>\n</tr>\n<tr>\n<td>0xE000ED04</td>\n<td style=\"text-align:center\">ICSR</td>\n<td>中断控制和状态寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED0C</td>\n<td style=\"text-align:center\">AIRCR</td>\n<td>应用中断和复位的寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED10</td>\n<td style=\"text-align:center\">SCR</td>\n<td>系统控制寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED14</td>\n<td style=\"text-align:center\">CCR</td>\n<td>配置控制寄存器</td>\n</tr>\n<tr>\n<td>0xE000ED1C</td>\n<td style=\"text-align:center\">SHPR2</td>\n<td>System Handler Priority Register 2</td>\n</tr>\n<tr>\n<td>0xE000ED20</td>\n<td style=\"text-align:center\">SHPR3</td>\n<td>System Handler Priority Register 3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"SysTick寄存器\"><a href=\"#SysTick寄存器\" class=\"headerlink\" title=\"SysTick寄存器\"></a>SysTick寄存器</h3><table>\n<thead>\n<tr>\n<th>地址</th>\n<th style=\"text-align:center\">寄存器名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0xE000E010</td>\n<td style=\"text-align:center\">SYST_CSR</td>\n<td>SysTick控制和状态寄存器</td>\n</tr>\n<tr>\n<td>0xE000E014</td>\n<td style=\"text-align:center\">SYST_RVR</td>\n<td>SysTick重载寄存器</td>\n</tr>\n<tr>\n<td>0xE000E018</td>\n<td style=\"text-align:center\">SYST_CVR</td>\n<td>SysTick当前值寄存器</td>\n</tr>\n<tr>\n<td>0xE000E01C</td>\n<td style=\"text-align:center\">SYST_CALIB</td>\n<td>SysTick校准寄存器</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cortex-m0启动流程\"><a href=\"#cortex-m0启动流程\" class=\"headerlink\" title=\"cortex-m0启动流程\"></a>cortex-m0启动流程</h2><ol>\n<li>程序从0x00000000地址开始执行</li>\n<li>m0从程序bin文件的开始处第2个word运行reset_handler</li>\n<li>reset_handler函数开始执行一些必要的初始化（ramfunc函数复制，堆初始化，全局、静态变量初始化等）</li>\n<li>跳转到main函数中</li>\n</ol>\n<h2 id=\"中断向量表\"><a href=\"#中断向量表\" class=\"headerlink\" title=\"中断向量表\"></a>中断向量表</h2><table><br>    <tr><td>sp指针</td></tr><br>    <tr><td>resetHandler地址</td></tr><br>    <tr><td>NMIHandler地址</td></tr><br>    <tr><td>hardfault地址</td></tr><br>    <tr><td>reserved</td></tr><br>    <tr><td>systickHandler地址</td></tr><br>    <tr><td>……</td></tr><br></table>\n\n<h2 id=\"大小端\"><a href=\"#大小端\" class=\"headerlink\" title=\"大小端\"></a>大小端</h2><pre><code>m0支持大端模式和小端模式，不过一般芯片公司选择小端模式。\n</code></pre><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><pre><code>堆向上增长\n栈向下增长\n</code></pre><h3 id=\"压栈的寄存器\"><a href=\"#压栈的寄存器\" class=\"headerlink\" title=\"压栈的寄存器\"></a>压栈的寄存器</h3><table><br>    <tr><td>xPSR</td></tr><br>    <tr><td>PC</td></tr><br>    <tr><td>LR</td></tr><br>    <tr><td>R12</td></tr><br>    <tr><td>R3</td></tr><br>    <tr><td>R2</td></tr><br>    <tr><td>R1</td></tr><br>    <tr><td>R0</td></tr><br></table>\n\n<h2 id=\"杂项指令集\"><a href=\"#杂项指令集\" class=\"headerlink\" title=\"杂项指令集\"></a>杂项指令集</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">BKPT</td>\n<td>断点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPSID</td>\n<td>关闭总中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CPSIE</td>\n<td>打开总中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DMB</td>\n<td>数据存储器隔离 仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的存储器访问操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DSB</td>\n<td>数据同步隔离，比DMB更严格:仅当所有在它前面的存储器访问操作都执行完毕后，才开始后面的指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ISB</td>\n<td>指令同步隔离，最严格: 会清洗流水线，保证所有它前面的指令都执行完毕之后，才执行后面的指令。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MRS</td>\n<td>从特殊寄存器读取数据到通用寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSR</td>\n<td>从通用寄存器读取数据到特殊寄存器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NOP</td>\n<td>空转指令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SEV</td>\n<td>产生event</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SVC</td>\n<td>产生SVC系统调用中断</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WFE</td>\n<td>等待event</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WFI</td>\n<td>等待中断</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M0-M3-M4-M7区别\"><a href=\"#M0-M3-M4-M7区别\" class=\"headerlink\" title=\"M0/M3/M4/M7区别\"></a>M0/M3/M4/M7区别</h2><p>M0 armv6-M架构</p>\n<p>M3 armv7-M架构<br>多了basepri寄存器可以阻止某优先级或更低的优先级的中断。<br>faultmask寄存器提供了更多的错误管理特性。<br>CONTROL寄存器的bit0用于决定是特权模式还是用户线程模式<br>32为thumb指令<br>位段特性<br>位域处理<br>多处理器支持<br>最多240个中断<br>硬件除法<br>存储器保护单元<br>更多的调试和跟踪特性</p>\n<p>M4 armv7-M架构<br>浮点特性<br>SIMD指令(单周期多指令)<br>饱和算法<br>单周期MAC(MAC乘法累加)</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>M0</th>\n<th>M3</th>\n<th>M4</th>\n<th>M7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>basepr</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M3系统框图\"><a href=\"#M3系统框图\" class=\"headerlink\" title=\"M3系统框图\"></a>M3系统框图</h2><p><img src=\"../res/cortex-m3系统框图.png\" alt=\"M3系统框图\"></p>\n<h2 id=\"M3快速开关中断汇编指令\"><a href=\"#M3快速开关中断汇编指令\" class=\"headerlink\" title=\"M3快速开关中断汇编指令\"></a>M3快速开关中断汇编指令</h2><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>效果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CPSID I</td>\n<td>PRIMASK=1</td>\n<td>关中断</td>\n</tr>\n<tr>\n<td>CPSIE I</td>\n<td>PRIMASK=0</td>\n<td>开中断</td>\n</tr>\n<tr>\n<td>CPSID F</td>\n<td>FAULTMASK=1</td>\n<td>关异常</td>\n</tr>\n<tr>\n<td>CPSIE F</td>\n<td>FAULTMASK=0</td>\n<td>开异常</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"M3内核CONTROL寄存器\"><a href=\"#M3内核CONTROL寄存器\" class=\"headerlink\" title=\"M3内核CONTROL寄存器\"></a>M3内核CONTROL寄存器</h2><ul>\n<li>CONTROL[1]<br>  堆栈指针选择<br>  0=选择主堆栈指针 MSP(复位后缺省值)<br>  1=选择进程堆栈指针 PSP<br>  在线程或基础级(没有在响应异常——译注),可以使用 PSP。在 handler 模式下,只允许使用 MSP,所以此时不得往该位写 1。 </li>\n<li>CONTROL[0]<br>  0=特权级的线程模式<br>  1=用户级的线程模式<br>  Handler 模式永远都是特权级的。 </li>\n</ul>\n<h2 id=\"异常和中断-1\"><a href=\"#异常和中断-1\" class=\"headerlink\" title=\"异常和中断\"></a>异常和中断</h2><blockquote>\n<p>Cortex‐M3 支持大量异常,包括 16‐4‐1=11 个系统异常,和最多 240 个外部中断——简称 IRQ。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>类型</th>\n<th>优先级</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>没有异常在运行</td>\n</tr>\n<tr>\n<td>1</td>\n<td>复位</td>\n<td>-3(最高)</td>\n<td>复位</td>\n</tr>\n<tr>\n<td>2</td>\n<td>NMI</td>\n<td>-2</td>\n<td>不可屏蔽中断(来自外部 NMI 输入脚)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>硬(hard) fault</td>\n<td>-1</td>\n<td>所有被除能的 fault,都将“上访”成硬 fault。除能的原因包括当前被禁用,或者 FAULTMASK 被置位。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>MemManage</td>\n<td>可编程</td>\n<td>fault</td>\n</tr>\n<tr>\n<td>5</td>\n<td>存储器管理fault</td>\n<td>可编程</td>\n<td>MPU 访问犯规以及访问非法位置均可引发。企图在“非执行区”取指也会引发此 fault总线 fault从总线系统收到了错误响应,原因可以是预取流产(Abort)或数据流产,或者企图访问协处理器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>用法(usage)</td>\n<td>可编程</td>\n<td>Fault</td>\n<td>由于程序错误导致的异常。通常是使用了一条无效指令,或者是非法的状态转换,例如尝试切换到 ARM 状态</td>\n</tr>\n<tr>\n<td>7-10</td>\n<td>保留</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>11</td>\n<td>SVCall</td>\n<td>可编程</td>\n<td>执行系统服务调用指令(SVC)引发的异常</td>\n</tr>\n<tr>\n<td>12</td>\n<td>调试监视器</td>\n<td>可编程</td>\n<td>调试监视器(断点,数据观察点,或者是外部调试请求</td>\n</tr>\n<tr>\n<td>13</td>\n<td>保留</td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>14</td>\n<td>PendSV</td>\n<td>可编程</td>\n<td>为系统设备而设的“可悬挂请求”(pendable request)</td>\n</tr>\n<tr>\n<td>15</td>\n<td>SysTick</td>\n<td>可编程</td>\n<td>系统滴答定时器(也就是周期性溢出的时基定时器——译注)</td>\n</tr>\n<tr>\n<td>16</td>\n<td>IRQ</td>\n<td>#0</td>\n<td>可编程</td>\n<td>外中断#0</td>\n</tr>\n<tr>\n<td>17</td>\n<td>IRQ</td>\n<td>#1</td>\n<td>可编程</td>\n<td>外中断#1</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>255</td>\n<td>IRQ</td>\n<td>#239</td>\n<td>可编程</td>\n<td>外中断#239</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MPU存储器保护单元\"><a href=\"#MPU存储器保护单元\" class=\"headerlink\" title=\"MPU存储器保护单元\"></a>MPU存储器保护单元</h2><p>Cortex‐M3 有一个可选的存储器保护单元。配上它之后,就可以对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规(violated)时,MPU 就会产生一个 fault 异常,可以由 fault异常的服务例程来分析该错误,并且在可能时改正它。MPU 有很多玩法。最常见的就是由操作系统使用 MPU,以使特权级代码的数据,包括操作系统本身的数据不被其它用户程序弄坏。MPU 在保护内存时是按区管理的(“区”的原文是 region,以后不再中译此名词——译注)。它可以把某些内存 region 设置成只读,从而避免了那里的内容意外被更改;还可以在多任务系统中把不同任务之间的数据区隔离。一句话,它会使嵌入式系统变得更加健壮,更加可靠(很多行业标准,尤其是航空的,就规定了必须使用 MPU 来行使保护职能——译注)。</p>\n"},{"title":"嵌入式笔记：freertos RTOS","_content":"嵌入式笔记：freertos RTOS\n\n# 目录\n\n## 简单的任务函数\n```c\nvoid ATaskFunction( void *pvParameters )\n{\n    int iVariableExample = 0;\n\n    /* 任务通常实现在一个死循环中。 */\n    for( ;; )\n    {\n        /* 完成任务功能的代码将放在这里。 */\n    }\n    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除的是当前任务 */\n    vTaskDelete( NULL );\n}\n```\n## 创建任务函数\n```c\n/* 函数原型 */\nportBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,\n                            const signed portCHAR * const pcName,\n                            unsigned portSHORT usStackDepth,\n                            void *pvParameters,\n                            unsigned portBASE_TYPE uxPriority,\n                            xTaskHandle *pxCreatedTask );\n/* 函数示例 */\nstatic TaskHandle_t myTaskHandler = NULL;\n\nxTaskCreate(ATaskFunction, \"myTask\", 512, NULL, configMAX_PRIORITIES - 4, &myTaskHandler);\n```\n\n## 删除任务函数\n```c\n/* 函数原型 */\nvoid vTaskDelete( xTaskHandle pxTaskToDelete );\n```\n\n## 任务优先级\n低优先级号表示任务的优先级低，优先级号0表示最低优先级。有效的优先级号范围从0到`(configMAX_PRIORITES – 1)`。\n\n|函数|说明|\n|---|---|\n|vTaskPrioritySet()|可以动态的更改任务优先级|\n|uxTaskPriorityGet()|获取任务优先级|\n|uxTaskPriorityGetFromISR()|在ISR函数中获取任务优先级|\n\n## 延时函数\n```c\nvoid vTaskDelay( portTickType xTicksToDelay );\n```\n> xTicksToDelay 表示延时多少个tick \\\n> 该函数会把task切出到阻塞态\n\n### 精确延时函数\n```c\nvoid vTaskDelayUntil( portTickType * pxPreviousWakeTime, portTickType xTimeIncrement );\n```\n> 调用此函数的任务解除阻塞的时间是绝对时刻，比起vTaskDelay()延时时间更精确\n\n使用方法：\n\n```c\nvoid vTaskFunction( void *pvParameters )\n{\n    char *pcTaskName;\n    portTickType xLastWakeTime;\n    pcTaskName = ( char * ) pvParameters;\n\n    /* 变量xLastWakeTime需要被初始化为当前心跳计数值。说明一下，这是该变量唯一一次被显式赋值。之后，\n    xLastWakeTime将在函数vTaskDelayUntil()中自动更新。 */\n    xLastWakeTime = xTaskGetTickCount();\n\n    for( ;; )\n    {\n        vPrintString( pcTaskName );\n        /* 本任务将精确的以250毫秒为周期执行。同vTaskDelay()函数一样，时间值是以心跳周期为单位的，\n        可以使用常量portTICK_RATE_MS将毫秒转换为心跳周期。变量xLastWakeTime会在\n        vTaskDelayUntil()中自动更新，因此不需要应用程序进行显示更新。 */\n        vTaskDelayUntil( &xLastWakeTime, ( 250 / portTICK_RATE_MS ) );\n    }\n}\n```\n\n## 空闲任务\n\n> 调用vTaskStartScheduler()时，调度器会自动创建一个空闲任务 \\\n> 空闲任务拥有最低优先级(优先级0) \\\n> 空闲任务是一个非常短小的循环\n\n具体代码在vTaskStartScheduler()中可以看到：\n\n```c\nvoid vTaskStartScheduler( void )\n{\n    BaseType_t xReturn;\n\n    /* Add the idle task at the lowest priority. */\n    #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )\n    {\n        /* Create the idle task, storing its handle in xIdleTaskHandle so it can\n        be returned by the xTaskGetIdleTaskHandle() function. */\n        xReturn = xTaskCreate( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #else\n    {\n        /* Create the idle task without storing its handle. */\n        xReturn = xTaskCreate( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #endif /* INCLUDE_xTaskGetIdleTaskHandle */\n\n    ...\n}\n```\n\n## 队列\n### 创建队列\n```c\nxQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,unsigned portBASE_TYPE uxItemSize );\n```\n\n### 写入到队列首\n```c\nportBASE_TYPE xQueueSendToFront( xQueueHandle xQueue,\n                                  const void * pvItemToQueue,\n                                  portTickType xTicksToWait );\n```\n### 写入到队列尾\n```c\nportBASE_TYPE xQueueSendToBack( xQueueHandle xQueue,\n                                const void * pvItemToQueue,\n                                portTickType xTicksToWait );\n```\n\n### 发送队列\n\n* [协程--croutine.c](#协程--croutine.c)\n\n## 系统运行过程\n\n## 协程--croutine.c\n4个链表：readyList  pendingList  delayList（2个）\n## 链表设计--List.c\n\n## 系统调度\n\n## 任务管理\n\n## 内存管理\n\n## 优先级反转\n有优先级为A、B和C三个任务，优先级A>B>C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。\n\n## 优先级继承\n> freertos 使用优先级继承来解决优先级反转问题\n当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。\n\n## freertos HOOK函数\n* vApplicationIdleHook()\n    idle的hook函数\n* vApplicationTickHook()\n    系统tick的hook函数\n* vApplicationMallocFailedHook()\n    malloc失败的hook函数\n* vApplicationStackOverflowHook()\n    栈溢出的hook函数\n* vApplicationDaemonTaskStartupHook()\n    vTaskStartScheduler()函数第一次执行的时候调用。\n\n## freertos栈溢出检测的2种方法\n* 第一种\n    每次调度都检查一下任务的当前栈有没有超过任务的栈区域。\n* 第二种\n    每个任务栈最下面会有16个字节是特定的内容，每次调度的时候如果发现这16个字节不正常了，就说明有谁踩到了这个栈。\n","source":"_posts/freertos-inside.md","raw":"---\ntitle: 嵌入式笔记：freertos RTOS\n---\n嵌入式笔记：freertos RTOS\n\n# 目录\n\n## 简单的任务函数\n```c\nvoid ATaskFunction( void *pvParameters )\n{\n    int iVariableExample = 0;\n\n    /* 任务通常实现在一个死循环中。 */\n    for( ;; )\n    {\n        /* 完成任务功能的代码将放在这里。 */\n    }\n    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除的是当前任务 */\n    vTaskDelete( NULL );\n}\n```\n## 创建任务函数\n```c\n/* 函数原型 */\nportBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,\n                            const signed portCHAR * const pcName,\n                            unsigned portSHORT usStackDepth,\n                            void *pvParameters,\n                            unsigned portBASE_TYPE uxPriority,\n                            xTaskHandle *pxCreatedTask );\n/* 函数示例 */\nstatic TaskHandle_t myTaskHandler = NULL;\n\nxTaskCreate(ATaskFunction, \"myTask\", 512, NULL, configMAX_PRIORITIES - 4, &myTaskHandler);\n```\n\n## 删除任务函数\n```c\n/* 函数原型 */\nvoid vTaskDelete( xTaskHandle pxTaskToDelete );\n```\n\n## 任务优先级\n低优先级号表示任务的优先级低，优先级号0表示最低优先级。有效的优先级号范围从0到`(configMAX_PRIORITES – 1)`。\n\n|函数|说明|\n|---|---|\n|vTaskPrioritySet()|可以动态的更改任务优先级|\n|uxTaskPriorityGet()|获取任务优先级|\n|uxTaskPriorityGetFromISR()|在ISR函数中获取任务优先级|\n\n## 延时函数\n```c\nvoid vTaskDelay( portTickType xTicksToDelay );\n```\n> xTicksToDelay 表示延时多少个tick \\\n> 该函数会把task切出到阻塞态\n\n### 精确延时函数\n```c\nvoid vTaskDelayUntil( portTickType * pxPreviousWakeTime, portTickType xTimeIncrement );\n```\n> 调用此函数的任务解除阻塞的时间是绝对时刻，比起vTaskDelay()延时时间更精确\n\n使用方法：\n\n```c\nvoid vTaskFunction( void *pvParameters )\n{\n    char *pcTaskName;\n    portTickType xLastWakeTime;\n    pcTaskName = ( char * ) pvParameters;\n\n    /* 变量xLastWakeTime需要被初始化为当前心跳计数值。说明一下，这是该变量唯一一次被显式赋值。之后，\n    xLastWakeTime将在函数vTaskDelayUntil()中自动更新。 */\n    xLastWakeTime = xTaskGetTickCount();\n\n    for( ;; )\n    {\n        vPrintString( pcTaskName );\n        /* 本任务将精确的以250毫秒为周期执行。同vTaskDelay()函数一样，时间值是以心跳周期为单位的，\n        可以使用常量portTICK_RATE_MS将毫秒转换为心跳周期。变量xLastWakeTime会在\n        vTaskDelayUntil()中自动更新，因此不需要应用程序进行显示更新。 */\n        vTaskDelayUntil( &xLastWakeTime, ( 250 / portTICK_RATE_MS ) );\n    }\n}\n```\n\n## 空闲任务\n\n> 调用vTaskStartScheduler()时，调度器会自动创建一个空闲任务 \\\n> 空闲任务拥有最低优先级(优先级0) \\\n> 空闲任务是一个非常短小的循环\n\n具体代码在vTaskStartScheduler()中可以看到：\n\n```c\nvoid vTaskStartScheduler( void )\n{\n    BaseType_t xReturn;\n\n    /* Add the idle task at the lowest priority. */\n    #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )\n    {\n        /* Create the idle task, storing its handle in xIdleTaskHandle so it can\n        be returned by the xTaskGetIdleTaskHandle() function. */\n        xReturn = xTaskCreate( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #else\n    {\n        /* Create the idle task without storing its handle. */\n        xReturn = xTaskCreate( prvIdleTask, \"IDLE\", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #endif /* INCLUDE_xTaskGetIdleTaskHandle */\n\n    ...\n}\n```\n\n## 队列\n### 创建队列\n```c\nxQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,unsigned portBASE_TYPE uxItemSize );\n```\n\n### 写入到队列首\n```c\nportBASE_TYPE xQueueSendToFront( xQueueHandle xQueue,\n                                  const void * pvItemToQueue,\n                                  portTickType xTicksToWait );\n```\n### 写入到队列尾\n```c\nportBASE_TYPE xQueueSendToBack( xQueueHandle xQueue,\n                                const void * pvItemToQueue,\n                                portTickType xTicksToWait );\n```\n\n### 发送队列\n\n* [协程--croutine.c](#协程--croutine.c)\n\n## 系统运行过程\n\n## 协程--croutine.c\n4个链表：readyList  pendingList  delayList（2个）\n## 链表设计--List.c\n\n## 系统调度\n\n## 任务管理\n\n## 内存管理\n\n## 优先级反转\n有优先级为A、B和C三个任务，优先级A>B>C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。\n\n## 优先级继承\n> freertos 使用优先级继承来解决优先级反转问题\n当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。\n\n## freertos HOOK函数\n* vApplicationIdleHook()\n    idle的hook函数\n* vApplicationTickHook()\n    系统tick的hook函数\n* vApplicationMallocFailedHook()\n    malloc失败的hook函数\n* vApplicationStackOverflowHook()\n    栈溢出的hook函数\n* vApplicationDaemonTaskStartupHook()\n    vTaskStartScheduler()函数第一次执行的时候调用。\n\n## freertos栈溢出检测的2种方法\n* 第一种\n    每次调度都检查一下任务的当前栈有没有超过任务的栈区域。\n* 第二种\n    每个任务栈最下面会有16个字节是特定的内容，每次调度的时候如果发现这16个字节不正常了，就说明有谁踩到了这个栈。\n","slug":"freertos-inside","published":1,"date":"2018-02-28T01:20:44.969Z","updated":"2018-02-28T01:12:17.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhb800039vf74jy4942r","content":"<p>嵌入式笔记：freertos RTOS</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"简单的任务函数\"><a href=\"#简单的任务函数\" class=\"headerlink\" title=\"简单的任务函数\"></a>简单的任务函数</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">ATaskFunction</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>pvParameters <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> iVariableExample <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 任务通常实现在一个死循环中。 */</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/* 完成任务功能的代码将放在这里。 */</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除的是当前任务 */</span>\n    <span class=\"token function\">vTaskDelete</span><span class=\"token punctuation\">(</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"创建任务函数\"><a href=\"#创建任务函数\" class=\"headerlink\" title=\"创建任务函数\"></a>创建任务函数</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 函数原型 */</span>\nportBASE_TYPE <span class=\"token function\">xTaskCreate</span><span class=\"token punctuation\">(</span> pdTASK_CODE pvTaskCode<span class=\"token punctuation\">,</span>\n                            <span class=\"token keyword\">const</span> <span class=\"token keyword\">signed</span> portCHAR <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> pcName<span class=\"token punctuation\">,</span>\n                            <span class=\"token keyword\">unsigned</span> portSHORT usStackDepth<span class=\"token punctuation\">,</span>\n                            <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>pvParameters<span class=\"token punctuation\">,</span>\n                            <span class=\"token keyword\">unsigned</span> portBASE_TYPE uxPriority<span class=\"token punctuation\">,</span>\n                            xTaskHandle <span class=\"token operator\">*</span>pxCreatedTask <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/* 函数示例 */</span>\n<span class=\"token keyword\">static</span> TaskHandle_t myTaskHandler <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">xTaskCreate</span><span class=\"token punctuation\">(</span>ATaskFunction<span class=\"token punctuation\">,</span> <span class=\"token string\">\"myTask\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> configMAX_PRIORITIES <span class=\"token operator\">-</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>myTaskHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"删除任务函数\"><a href=\"#删除任务函数\" class=\"headerlink\" title=\"删除任务函数\"></a>删除任务函数</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 函数原型 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">vTaskDelete</span><span class=\"token punctuation\">(</span> xTaskHandle pxTaskToDelete <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"任务优先级\"><a href=\"#任务优先级\" class=\"headerlink\" title=\"任务优先级\"></a>任务优先级</h2><p>低优先级号表示任务的优先级低，优先级号0表示最低优先级。有效的优先级号范围从0到<code>(configMAX_PRIORITES – 1)</code>。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vTaskPrioritySet()</td>\n<td>可以动态的更改任务优先级</td>\n</tr>\n<tr>\n<td>uxTaskPriorityGet()</td>\n<td>获取任务优先级</td>\n</tr>\n<tr>\n<td>uxTaskPriorityGetFromISR()</td>\n<td>在ISR函数中获取任务优先级</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"延时函数\"><a href=\"#延时函数\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">vTaskDelay</span><span class=\"token punctuation\">(</span> portTickType xTicksToDelay <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>xTicksToDelay 表示延时多少个tick \\<br>该函数会把task切出到阻塞态</p>\n</blockquote>\n<h3 id=\"精确延时函数\"><a href=\"#精确延时函数\" class=\"headerlink\" title=\"精确延时函数\"></a>精确延时函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">vTaskDelayUntil</span><span class=\"token punctuation\">(</span> portTickType <span class=\"token operator\">*</span> pxPreviousWakeTime<span class=\"token punctuation\">,</span> portTickType xTimeIncrement <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>调用此函数的任务解除阻塞的时间是绝对时刻，比起vTaskDelay()延时时间更精确</p>\n</blockquote>\n<p>使用方法：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">vTaskFunction</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>pvParameters <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>pcTaskName<span class=\"token punctuation\">;</span>\n    portTickType xLastWakeTime<span class=\"token punctuation\">;</span>\n    pcTaskName <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">)</span> pvParameters<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* 变量xLastWakeTime需要被初始化为当前心跳计数值。说明一下，这是该变量唯一一次被显式赋值。之后，\n    xLastWakeTime将在函数vTaskDelayUntil()中自动更新。 */</span>\n    xLastWakeTime <span class=\"token operator\">=</span> <span class=\"token function\">xTaskGetTickCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">vPrintString</span><span class=\"token punctuation\">(</span> pcTaskName <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/* 本任务将精确的以250毫秒为周期执行。同vTaskDelay()函数一样，时间值是以心跳周期为单位的，\n        可以使用常量portTICK_RATE_MS将毫秒转换为心跳周期。变量xLastWakeTime会在\n        vTaskDelayUntil()中自动更新，因此不需要应用程序进行显示更新。 */</span>\n        <span class=\"token function\">vTaskDelayUntil</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">&amp;</span>xLastWakeTime<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span> <span class=\"token number\">250</span> <span class=\"token operator\">/</span> portTICK_RATE_MS <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"空闲任务\"><a href=\"#空闲任务\" class=\"headerlink\" title=\"空闲任务\"></a>空闲任务</h2><blockquote>\n<p>调用vTaskStartScheduler()时，调度器会自动创建一个空闲任务 \\<br>空闲任务拥有最低优先级(优先级0) \\<br>空闲任务是一个非常短小的循环</p>\n</blockquote>\n<p>具体代码在vTaskStartScheduler()中可以看到：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">vTaskStartScheduler</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    BaseType_t xReturn<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/* Add the idle task at the lowest priority. */</span>\n    <span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> ( INCLUDE_xTaskGetIdleTaskHandle == 1 )</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/* Create the idle task, storing its handle in xIdleTaskHandle so it can\n        be returned by the xTaskGetIdleTaskHandle() function. */</span>\n        xReturn <span class=\"token operator\">=</span> <span class=\"token function\">xTaskCreate</span><span class=\"token punctuation\">(</span> prvIdleTask<span class=\"token punctuation\">,</span> <span class=\"token string\">\"IDLE\"</span><span class=\"token punctuation\">,</span> tskIDLE_STACK_SIZE<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">)</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span> tskIDLE_PRIORITY <span class=\"token operator\">|</span> portPRIVILEGE_BIT <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>xIdleTaskHandle <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">/* Create the idle task without storing its handle. */</span>\n        xReturn <span class=\"token operator\">=</span> <span class=\"token function\">xTaskCreate</span><span class=\"token punctuation\">(</span> prvIdleTask<span class=\"token punctuation\">,</span> <span class=\"token string\">\"IDLE\"</span><span class=\"token punctuation\">,</span> tskIDLE_STACK_SIZE<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">)</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span> tskIDLE_PRIORITY <span class=\"token operator\">|</span> portPRIVILEGE_BIT <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span> </span><span class=\"token comment\" spellcheck=\"true\">/* INCLUDE_xTaskGetIdleTaskHandle */</span>\n\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\">xQueueHandle <span class=\"token function\">xQueueCreate</span><span class=\"token punctuation\">(</span> <span class=\"token keyword\">unsigned</span> portBASE_TYPE uxQueueLength<span class=\"token punctuation\">,</span><span class=\"token keyword\">unsigned</span> portBASE_TYPE uxItemSize <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"写入到队列首\"><a href=\"#写入到队列首\" class=\"headerlink\" title=\"写入到队列首\"></a>写入到队列首</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\">portBASE_TYPE <span class=\"token function\">xQueueSendToFront</span><span class=\"token punctuation\">(</span> xQueueHandle xQueue<span class=\"token punctuation\">,</span>\n                                  <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> pvItemToQueue<span class=\"token punctuation\">,</span>\n                                  portTickType xTicksToWait <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"写入到队列尾\"><a href=\"#写入到队列尾\" class=\"headerlink\" title=\"写入到队列尾\"></a>写入到队列尾</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\">portBASE_TYPE <span class=\"token function\">xQueueSendToBack</span><span class=\"token punctuation\">(</span> xQueueHandle xQueue<span class=\"token punctuation\">,</span>\n                                <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> pvItemToQueue<span class=\"token punctuation\">,</span>\n                                portTickType xTicksToWait <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"发送队列\"><a href=\"#发送队列\" class=\"headerlink\" title=\"发送队列\"></a>发送队列</h3><ul>\n<li><a href=\"#协程--croutine.c\">协程–croutine.c</a></li>\n</ul>\n<h2 id=\"系统运行过程\"><a href=\"#系统运行过程\" class=\"headerlink\" title=\"系统运行过程\"></a>系统运行过程</h2><h2 id=\"协程–croutine-c\"><a href=\"#协程–croutine-c\" class=\"headerlink\" title=\"协程–croutine.c\"></a>协程–croutine.c</h2><p>4个链表：readyList  pendingList  delayList（2个）</p>\n<h2 id=\"链表设计–List-c\"><a href=\"#链表设计–List-c\" class=\"headerlink\" title=\"链表设计–List.c\"></a>链表设计–List.c</h2><h2 id=\"系统调度\"><a href=\"#系统调度\" class=\"headerlink\" title=\"系统调度\"></a>系统调度</h2><h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h2 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h2><p>有优先级为A、B和C三个任务，优先级A&gt;B&gt;C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。</p>\n<h2 id=\"优先级继承\"><a href=\"#优先级继承\" class=\"headerlink\" title=\"优先级继承\"></a>优先级继承</h2><blockquote>\n<p>freertos 使用优先级继承来解决优先级反转问题<br>当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。</p>\n</blockquote>\n<h2 id=\"freertos-HOOK函数\"><a href=\"#freertos-HOOK函数\" class=\"headerlink\" title=\"freertos HOOK函数\"></a>freertos HOOK函数</h2><ul>\n<li>vApplicationIdleHook()<br>  idle的hook函数</li>\n<li>vApplicationTickHook()<br>  系统tick的hook函数</li>\n<li>vApplicationMallocFailedHook()<br>  malloc失败的hook函数</li>\n<li>vApplicationStackOverflowHook()<br>  栈溢出的hook函数</li>\n<li>vApplicationDaemonTaskStartupHook()<br>  vTaskStartScheduler()函数第一次执行的时候调用。</li>\n</ul>\n<h2 id=\"freertos栈溢出检测的2种方法\"><a href=\"#freertos栈溢出检测的2种方法\" class=\"headerlink\" title=\"freertos栈溢出检测的2种方法\"></a>freertos栈溢出检测的2种方法</h2><ul>\n<li>第一种<br>  每次调度都检查一下任务的当前栈有没有超过任务的栈区域。</li>\n<li>第二种<br>  每个任务栈最下面会有16个字节是特定的内容，每次调度的时候如果发现这16个字节不正常了，就说明有谁踩到了这个栈。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：freertos RTOS</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"简单的任务函数\"><a href=\"#简单的任务函数\" class=\"headerlink\" title=\"简单的任务函数\"></a>简单的任务函数</h2><pre><code class=\"c\">void ATaskFunction( void *pvParameters )\n{\n    int iVariableExample = 0;\n\n    /* 任务通常实现在一个死循环中。 */\n    for( ;; )\n    {\n        /* 完成任务功能的代码将放在这里。 */\n    }\n    /* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除的是当前任务 */\n    vTaskDelete( NULL );\n}\n</code></pre>\n<h2 id=\"创建任务函数\"><a href=\"#创建任务函数\" class=\"headerlink\" title=\"创建任务函数\"></a>创建任务函数</h2><pre><code class=\"c\">/* 函数原型 */\nportBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,\n                            const signed portCHAR * const pcName,\n                            unsigned portSHORT usStackDepth,\n                            void *pvParameters,\n                            unsigned portBASE_TYPE uxPriority,\n                            xTaskHandle *pxCreatedTask );\n/* 函数示例 */\nstatic TaskHandle_t myTaskHandler = NULL;\n\nxTaskCreate(ATaskFunction, &quot;myTask&quot;, 512, NULL, configMAX_PRIORITIES - 4, &amp;myTaskHandler);\n</code></pre>\n<h2 id=\"删除任务函数\"><a href=\"#删除任务函数\" class=\"headerlink\" title=\"删除任务函数\"></a>删除任务函数</h2><pre><code class=\"c\">/* 函数原型 */\nvoid vTaskDelete( xTaskHandle pxTaskToDelete );\n</code></pre>\n<h2 id=\"任务优先级\"><a href=\"#任务优先级\" class=\"headerlink\" title=\"任务优先级\"></a>任务优先级</h2><p>低优先级号表示任务的优先级低，优先级号0表示最低优先级。有效的优先级号范围从0到<code>(configMAX_PRIORITES – 1)</code>。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vTaskPrioritySet()</td>\n<td>可以动态的更改任务优先级</td>\n</tr>\n<tr>\n<td>uxTaskPriorityGet()</td>\n<td>获取任务优先级</td>\n</tr>\n<tr>\n<td>uxTaskPriorityGetFromISR()</td>\n<td>在ISR函数中获取任务优先级</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"延时函数\"><a href=\"#延时函数\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h2><pre><code class=\"c\">void vTaskDelay( portTickType xTicksToDelay );\n</code></pre>\n<blockquote>\n<p>xTicksToDelay 表示延时多少个tick \\<br>该函数会把task切出到阻塞态</p>\n</blockquote>\n<h3 id=\"精确延时函数\"><a href=\"#精确延时函数\" class=\"headerlink\" title=\"精确延时函数\"></a>精确延时函数</h3><pre><code class=\"c\">void vTaskDelayUntil( portTickType * pxPreviousWakeTime, portTickType xTimeIncrement );\n</code></pre>\n<blockquote>\n<p>调用此函数的任务解除阻塞的时间是绝对时刻，比起vTaskDelay()延时时间更精确</p>\n</blockquote>\n<p>使用方法：</p>\n<pre><code class=\"c\">void vTaskFunction( void *pvParameters )\n{\n    char *pcTaskName;\n    portTickType xLastWakeTime;\n    pcTaskName = ( char * ) pvParameters;\n\n    /* 变量xLastWakeTime需要被初始化为当前心跳计数值。说明一下，这是该变量唯一一次被显式赋值。之后，\n    xLastWakeTime将在函数vTaskDelayUntil()中自动更新。 */\n    xLastWakeTime = xTaskGetTickCount();\n\n    for( ;; )\n    {\n        vPrintString( pcTaskName );\n        /* 本任务将精确的以250毫秒为周期执行。同vTaskDelay()函数一样，时间值是以心跳周期为单位的，\n        可以使用常量portTICK_RATE_MS将毫秒转换为心跳周期。变量xLastWakeTime会在\n        vTaskDelayUntil()中自动更新，因此不需要应用程序进行显示更新。 */\n        vTaskDelayUntil( &amp;xLastWakeTime, ( 250 / portTICK_RATE_MS ) );\n    }\n}\n</code></pre>\n<h2 id=\"空闲任务\"><a href=\"#空闲任务\" class=\"headerlink\" title=\"空闲任务\"></a>空闲任务</h2><blockquote>\n<p>调用vTaskStartScheduler()时，调度器会自动创建一个空闲任务 \\<br>空闲任务拥有最低优先级(优先级0) \\<br>空闲任务是一个非常短小的循环</p>\n</blockquote>\n<p>具体代码在vTaskStartScheduler()中可以看到：</p>\n<pre><code class=\"c\">void vTaskStartScheduler( void )\n{\n    BaseType_t xReturn;\n\n    /* Add the idle task at the lowest priority. */\n    #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )\n    {\n        /* Create the idle task, storing its handle in xIdleTaskHandle so it can\n        be returned by the xTaskGetIdleTaskHandle() function. */\n        xReturn = xTaskCreate( prvIdleTask, &quot;IDLE&quot;, tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &amp;xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #else\n    {\n        /* Create the idle task without storing its handle. */\n        xReturn = xTaskCreate( prvIdleTask, &quot;IDLE&quot;, tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */\n    }\n    #endif /* INCLUDE_xTaskGetIdleTaskHandle */\n\n    ...\n}\n</code></pre>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><pre><code class=\"c\">xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,unsigned portBASE_TYPE uxItemSize );\n</code></pre>\n<h3 id=\"写入到队列首\"><a href=\"#写入到队列首\" class=\"headerlink\" title=\"写入到队列首\"></a>写入到队列首</h3><pre><code class=\"c\">portBASE_TYPE xQueueSendToFront( xQueueHandle xQueue,\n                                  const void * pvItemToQueue,\n                                  portTickType xTicksToWait );\n</code></pre>\n<h3 id=\"写入到队列尾\"><a href=\"#写入到队列尾\" class=\"headerlink\" title=\"写入到队列尾\"></a>写入到队列尾</h3><pre><code class=\"c\">portBASE_TYPE xQueueSendToBack( xQueueHandle xQueue,\n                                const void * pvItemToQueue,\n                                portTickType xTicksToWait );\n</code></pre>\n<h3 id=\"发送队列\"><a href=\"#发送队列\" class=\"headerlink\" title=\"发送队列\"></a>发送队列</h3><ul>\n<li><a href=\"#协程--croutine.c\">协程–croutine.c</a></li>\n</ul>\n<h2 id=\"系统运行过程\"><a href=\"#系统运行过程\" class=\"headerlink\" title=\"系统运行过程\"></a>系统运行过程</h2><h2 id=\"协程–croutine-c\"><a href=\"#协程–croutine-c\" class=\"headerlink\" title=\"协程–croutine.c\"></a>协程–croutine.c</h2><p>4个链表：readyList  pendingList  delayList（2个）</p>\n<h2 id=\"链表设计–List-c\"><a href=\"#链表设计–List-c\" class=\"headerlink\" title=\"链表设计–List.c\"></a>链表设计–List.c</h2><h2 id=\"系统调度\"><a href=\"#系统调度\" class=\"headerlink\" title=\"系统调度\"></a>系统调度</h2><h2 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h2><h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h2 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h2><p>有优先级为A、B和C三个任务，优先级A&gt;B&gt;C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。</p>\n<h2 id=\"优先级继承\"><a href=\"#优先级继承\" class=\"headerlink\" title=\"优先级继承\"></a>优先级继承</h2><blockquote>\n<p>freertos 使用优先级继承来解决优先级反转问题<br>当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。</p>\n</blockquote>\n<h2 id=\"freertos-HOOK函数\"><a href=\"#freertos-HOOK函数\" class=\"headerlink\" title=\"freertos HOOK函数\"></a>freertos HOOK函数</h2><ul>\n<li>vApplicationIdleHook()<br>  idle的hook函数</li>\n<li>vApplicationTickHook()<br>  系统tick的hook函数</li>\n<li>vApplicationMallocFailedHook()<br>  malloc失败的hook函数</li>\n<li>vApplicationStackOverflowHook()<br>  栈溢出的hook函数</li>\n<li>vApplicationDaemonTaskStartupHook()<br>  vTaskStartScheduler()函数第一次执行的时候调用。</li>\n</ul>\n<h2 id=\"freertos栈溢出检测的2种方法\"><a href=\"#freertos栈溢出检测的2种方法\" class=\"headerlink\" title=\"freertos栈溢出检测的2种方法\"></a>freertos栈溢出检测的2种方法</h2><ul>\n<li>第一种<br>  每次调度都检查一下任务的当前栈有没有超过任务的栈区域。</li>\n<li>第二种<br>  每个任务栈最下面会有16个字节是特定的内容，每次调度的时候如果发现这16个字节不正常了，就说明有谁踩到了这个栈。</li>\n</ul>\n"},{"title":"嵌入式笔记：C基础","_content":"嵌入式笔记：C基础\n# 目录\n* [c基础](#c基础)\n    * [数据类型说明](#数据类型说明)\n    * [volatile](#volatile)\n    * [指针](#指针)\n        * [函数指针](#函数指针)\n        * [函数指针数组](#函数指针数组)\n        * [指针数组](#指针数组)\n        * [数组指针](#数组指针)\n        * [指针的指针](#指针的指针)\n    * [main函数的返回值](#main函数的返回值)\n    * [const](#const)\n    * [浮点数存储方式](#浮点数存储方式)\n* [c题目](#c题目)\n    * [printf返回值](#printf返回值)\n    * [enum枚举类型](#enum枚举类型)\n    * [可变参数函数](#可变参数函数)\n* [链表](#链表)\n* [排序算法](#排序算法)\n    * [选择排序](#选择排序)\n    * [插入排序](#插入排序)\n    * [希尔排序](#希尔排序)\n    * [冒泡排序](#冒泡排序)\n    * [快速排序](#快速排序)\n* [hash算法](#hash算法)\n    * [hash构造方法](#hash构造方法)\n    * [hash冲突及解决](#hash冲突及解决)\n    * [常用的hash函数](#常用的hash函数)\n    \n## c基础\n* [数据类型说明](#数据类型说明)\n* [volatile](#volatile)\n* [指针](#指针)\n* [const](#const)\n* [main函数的返回值](#main函数的返回值)\n* [浮点数存储方式](#浮点数存储方式)\n\n### 数据类型说明\n|  数据类型      | 16位平台  | 32位平台 | 64位平台 |\n| -------------|:---------:|:------:|:------:|\n| char         | 1 字节     | 1 字节 |  1 字节 |\n| pointer      | 2 字节     | 4 字节 |  8 字节 |\n| short        | 2 字节     | 2 字节 |  2 字节 |\n| int          | 2 字节     | 4 字节 |  4 字节 |\n| float        | 4 字节     | 4 字节 |  4 字节 |\n| double       | 8 字节     | 8 字节 |  8 字节 |\n| long         | 4 字节     | 4 字节 |  8 字节 |\n| long long    | 8 字节     | 8 字节 |  8 字节 |\n\n### volatile\nvolatile 指出变量是随时可能发生变化的，每次使用它的时候必须从变量的地址中读取，因而编译器生成的汇编代码会重新从变量的地址读取数据。\n1. 并行设备的硬件寄存器，\n2. 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables),可以使用关键区保护\n3. 多线程应用中被几个任务共享的变量，可以关闭系统调度\n\n### 指针\n#### 函数指针\n```c\nint (*fun)(int *a);\n```\n#### 函数指针数组\n```c\nint (*fun[10])(int *data, int size);\n```\n使用方法：\n```c\nint (*sort_fun[5])(int *data, int size) = {\n    quick_sort,     /* 快速排序 */\n    insert_sort,    /* 插入排序 */\n    bubble_sort,    /* 冒泡排序 */\n    heap_sort,      /* 堆排序 */\n    selection_sort  /* 选择排序 */\n};\n// 或者\nsort_fun[0] = quick_sort;\nsort_fun[1] = insert_sort;\n```\n\n#### 指针数组\n```c\nint *a[10];\n```\n\n#### 数组指针\n```c\n/* a为指向含10个元素的一维数组的指针变量，\n * ()优先级高，说明a是一个指针，指向一个整型的一维数组.\n * a+1时，a要跨过10个整型数据的长度 */\nint (*a)[10];\n```\n#### 指针的指针\n```c\nint **a;\n```\n\n\n### main函数的返回值\n1. 0 表示程序正常退出\n2. 负数表示程序异常退出\n\n### const\n#### const T\n定义一个常量，声明的同时必须进行初始化。一旦声明，这个值将不能被改变。\n```c\nconst int constInt = 10;        //正确\nconstInt = 20;                  //错误，常量值不可被改变\nconst int constInt3;            //错误，未被初始化\n```\n\n#### const T*\n指向常量的指针，不能用于改变其所指向的对象的值。\n```c\nconst int i = 5;\nconst int i2 = 10;\nconst int* pInt = &i;           //正确，指向一个const int对象，即i的地址\n//*pInt = 10;                   //错误，不能改变其所指缶的对象\npInt = &i2;                     //正确，可以改变pInt指针本身的值,此时pInt指向的是i2的地址\nconst int* p2 = new int(8);     //正确，指向一个new出来的对象的地址\ndelete p2;                      //正确\n//int* pInt = &i;               //错误，i是const int类型，类型不匹配，不能将const int * 初始化为int *\nint nValue = 15;\nconst int * pConstInt = &nValue;    //正确，可以把int *赋给const int *，但是pConstInt不能改变其所指向对象的值，即nValue\n*pConstInt = 40;                    //错误，不能改变其所指向对象的值\n```\n#### const int* 与int* const的区别\n指针本身就是一种对象，把指针定义为常量就是常量指针，也就是int* const的类型，也可以写成int *const，声明时必须初始化。\n```c\nint nValue = 10;\nint* const p = &nValue;\nint *const p2 = &nValue;\nconst int* 指针指向的对象不可以改变，但指针本身的值可以改变；int* const 指针本身的值不可改变，但其指向的对象可以改变。\nint nValue1 = 10;\nint nValue2 = 20;\nint* const constPoint = &nValue1;\n//constPoint = & nValue2;           //错误，不能改变constPoint本身的值\n*constPoint = 40;                   //正确，可以改变constPoint所指向的对象，此时nValue1 = 40\n\n\nconst int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* pPoint = &nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\npPoint = &nConstValue2;             //正确，可以改变pPoint指针本身的值，此时pPoint邦定的是nConstValue2对象，即pPoint为nConstValue2的地址\n```\nconst int* const 是一个指向常量对象的常量指针，即不可以改变指针本身的值，也不可以改变指针指向的对象。\n```c\nconst int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* const pPoint = &nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\n//pPoint = &nConstValue2;           //错误，不能改变pPoint本身的值\n```\n#### const助记方法\n##### 把一个声明从右向左读。( * 读成 pointer to )\n```c\nchar * const cp;  // cp is a const pointer to char\nconst char * p;   // p is a pointer to const char;\nchar const * p;   // 同上,因为C++里面没有const*的运算符，所以const只能属于前面的类型。\n```\n##### C++标准规定，const关键字放在类型或变量名之前等价的。\n\n结论：\n```c\nchar * const cp     // 定义一个指向字符的指针常数，即const指针\nconst char* p       // 定义一个指向字符常数的指针\nchar const* p       // 等同于const char* p\nconst char **       // 是一个指向指针的指针，那个指针又指向一个字符串常量。   \nchar **             // 也是一个指向指针的指针，那个指针又指向一个字符串变量。\n```\n\n### 浮点数存储方式\n1. float 占用4个字节，32bits\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>符号位</td>\n      <td width=\"150\">指数位</td>\n      <td width=\"300\">尾数部分</td>\n   </tr>\n   <tr>\n      <td>1 bits</td>\n      <td>8 bits</td>\n      <td>23 bits</td>\n   </tr>\n</table>\n\n2. double 占用8字节，64bits\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>符号位</td>\n      <td width=\"150\">指数位</td>\n      <td width=\"300\">尾数部分</td>\n   </tr>\n   <tr>\n      <td>1 bits</td>\n      <td>11 bits</td>\n      <td>52 bits</td>\n   </tr>\n</table>\n\n## c题目\n* [printf返回值](#printf返回值)\n* [enum枚举类型](#enum枚举类型)\n* [可变参数函数](#可变参数函数)\n\n### printf返回值\n```c\n#include <stdio.h>\nint main() {\n  int i = 43;\n  printf(\"%d\\n\", printf(\"%d\", printf(\"%d\", i)));\n  return 0;\n}\n```\n输出：4321\nprintf返回值是输出字符的个数（不包括字符串结尾\\x00）\n\n### enum枚举类型\n```c\n#include <stdio.h>\nint main() {\n  enum color{\n    RED,\n    BLUE,\n    GREEN = -2,\n    YELLOW,\n    PINK\n  };\n  printf(\"%d %d\\n\", BLUE, PINK);\n  return 0;\n}\n```\n输出：1 0\nenum默认是从0开始的，所以RED = 0， BLUE = 1， GREEN = -2， YELLOW = -1， PINK = 0；\n\n### 可变参数函数\n```c\n#include \"stdarg.h\"\n\nchar buf[512] = {0};\n\nint func(const char *fmt, ...)\n{\n  va_list args;\n  va_start(args, fmt);\n  vsprintf(buf, fmt, args);\n  va_end(args);\n}\n```\n### 大小端区分\n```c\nunion data {\n    int a;\n    char b;\n};\n\nstruct def {\n    union data mine;\n};\n\nstruct def endian;\n\nint main(int argc, char **argv)\n{\n    endian.mine.a = 0x12345678;\n    printf(\"%02X\\n\", endian.mine.b);\n\n    return 0;\n}\n/*打印 78 说明是小端， 12 说明是大端 */\n```\n\n## 链表\n```c\n////////////////////////////////////////////\n//单链表的初始化，建立，插入，查找，删除。//\n//Author:Wang Yong                        //\n//Date: 2010.8.19                         //\n////////////////////////////////////////////\n#include <stdio.h>\n#include <stdlib.h>\ntypedef int ElemType;\n////////////////////////////////////////////\n//定义结点类型\ntypedef struct Node\n{\n    ElemType data;              //单链表中的数据域\n    struct Node *next;          //单链表的指针域\n}Node,*LinkedList;\n////////////////////////////////////////////\n//单链表的初始化\nLinkedList LinkedListInit()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请结点空间\n    if(L == NULL)                       //判断是否有足够的内存空间\n        printf(\"申请内存空间失败/n\");\n    L->next = NULL;                  //将next设置为NULL,初始长度为0的单链表\n}\n////////////////////////////////////////////\n//单链表的建立1，头插法建立单链表\nLinkedList LinkedListCreatH()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L->next = NULL;                      //初始化一个空链表\n    \n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(\"%d\",&x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p->data = x;                     //结点数据域赋值\n        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL\n        L->next = p; \n    }\n    return L;\n}\n////////////////////////////////////////////\n//单链表的建立2，尾插法建立单链表\nLinkedList LinkedListCreatT()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L->next = NULL;                  //初始化一个空链表\n    Node *r;\n    r = L;                          //r始终指向终端结点，开始时指向头结点\n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(\"%d\",&x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p->data = x;                     //结点数据域赋值\n        r->next = p;                 //将结点插入到表头L-->|1|-->|2|-->NULL\n        r = p;\n    }\n    r->next = NULL;\n    \n    return L;\n}\n////////////////////////////////////////////\n//单链表的插入，在链表的第i个位置插入x的元素\nLinkedList LinkedListInsert(LinkedList L,int i,ElemType x)\n{  \n    Node *pre;                      //pre为前驱结点\n    pre = L;\n    int tempi = 0;\n    for (tempi = 1; tempi < i; tempi++)\n        pre = pre->next;                 //查找第i个位置的前驱结点\n    Node *p;                                //插入的结点为p\n    p = (Node *)malloc(sizeof(Node));\n    p->data = x;\n    p->next = pre->next;\n    pre->next = p;\n\n    return L;\n}\n////////////////////////////////////////////\n//单链表的删除，在链表中删除值为x的元素\nLinkedList LinkedListDelete(LinkedList L,ElemType x)\n{\n    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。\n    p = L->next;\n    while(p->data != x)              //查找值为x的元素\n    {\n        pre = p;\n        p = p->next;\n    }\n    pre->next = p->next;          //删除操作，将其前驱next指向其后继。\n    free(p);\n    return L;\n}\n/////////////////////////////////////////////\nint main()\n{\n    LinkedList list,start;\n/*  printf(\"请输入单链表的数据：\");\n    list = LinkedListCreatH();\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n*/  printf(\"请输入单链表的数据：\");\n    list = LinkedListCreatT();\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n    int i;\n    ElemType x;\n    printf(\"请输入插入数据的位置：\");\n    scanf(\"%d\",&i);\n    printf(\"请输入插入数据的值：\");\n    scanf(\"%d\",&x);\n    LinkedListInsert(list,i,x);\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n    printf(\"请输入要删除的元素的值：\");\n    scanf(\"%d\",&x);\n    LinkedListDelete(list,x); \n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n\n    return 0;\n}\n```\n\n## 排序算法\n* [选择排序](#选择排序)\n* [插入排序](#插入排序)\n* [希尔排序](#希尔排序)\n* [冒泡排序](#冒泡排序)\n* [快速排序](#快速排序)\n\n排序算法有：\n<table>\n    <tr>\n      <td>选择排序</td>\n      <td>快速排序</td>\n      <td>希尔排序</td>\n      <td>冒泡排序</td>\n      <td>插入排序</td>\n      <td>堆排序</td>\n      <td>归并排序</td>\n    </tr>\n</table>\n排序算法比较：\n\n![排序算法比较](../res/sort/sort.png)\n\n### 选择排序\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n#### 时间复杂度\n    平均: O(n2) 最好: O(n2) 最坏:O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 重复第二步，直到所有元素均排序完毕。\n#### 动图演示\n![动图演示](../res/sort/selectionSort.gif)\n```c\n/* 直接选择排序 */\nvoid selection_sort(int n)\n{\n    for (int i = 0; i < n - 1; i++)\n    {\n        int min = i;\n        for (int j = i + 1; j < n; j++)\n        {\n            if (x[j] < x[min])\n            {\n                min = j;\n            }\n        }\n        if (min != i)\n        {\n            swap(x,i,min);\n        }\n    }\n}\n```\n### 插入排序\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n#### 时间复杂度\n    平均：O(n2) 最好：O(n) 最坏：O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n#### 动图演示\n![动图演示](res/sort/insertionSort.gif)\n```c\n/* 直接插入排序 */\nvoid insertion_sort(int n)\n{\n    for(int i = 1; i < n; i++)\n    {\n        int t = x[i];\n        int j;\n        for (j = i; j > 0 && x[j-1] > t ; j--)\n        {\n            x[j] = x[j - 1];\n        }\n        x[j] = t;\n    }\n}\n```\n### 希尔排序\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n#### 时间复杂度\n    平均：O(n1.5) 最好：O(n) 最坏O(n2)\n#### 空间复杂度\n    O(1) \n#### 算法步骤\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n```c\n/* 希尔排序 */\nvoid shell_sort(int n)\n{\n    for (int inc = n/3; inc >= 1; inc /= 3 )\n    {\n        for (int i = inc; i < n; i++)\n        {\n            int t = x[i];\n            int j;\n            for (j = i; j >= inc && x[j - inc] > t ; j -= inc)\n            {\n                x[j] = x[j - inc];\n            }\n            x[j] = t;\n        }\n    }\n}\n```\n### 冒泡排序\n\n#### 时间复杂度\n    平均: O(n2) 最好: O(n) 最坏：O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n动图演示\n![动图演示](res/sort/bubbleSort.gif)\n```c\n/* 冒泡排序 */\nvoid bubble_sort(int n)\n{\n    bool change = true;\n    for (int i = n-1; i >= 1 && change; i--)\n    {\n        change = false;\n        for (int j = 0; j < i; j++)\n        {\n            if(x[j] > x[j + 1])\n            {\n                swap(x, j, j + 1);\n                change = true;\n            }\n        }\n    }\n}\n```\n### 快速排序\n快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：\n\n> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n#### 时间复杂度\n    平均: O(nlogn) 最好: O(nlogn) 最坏:O(n2)\n#### 空间复杂度\n    O(nlogn)   用于方法栈\n#### 算法步骤\n1. 从数列中挑出一个元素，称为 “基准”（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n#### 动图演示\n\n![动图演示](res/sort/quickSort.gif)\n```c\n/* 快速排序 */\nvoid quick_sort(int l, int u)\n{\n    if (l >= u)\n        return;\n    int m = l;\n    for (int i = l+1; i<= u; i++)\n    {\n        if(x[i] < x[l])\n            swap(x, ++m, i);\n    }\n    swap(x, l, m);\n    quick_sort(l, m-1);\n    quick_sort(m+1, u);\n}\n```\n## hash算法\n### hash构造方法\n1. 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数） \n2. 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 \n3. 平方取中法：取关键字平方后的中间几位作为散列地址。 \n4. 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 \n5. 随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 \n6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。\n### hash冲突及解决\n#### 冲突原因： \n1. 与散列函数有关，一个好的散列函数的值应尽可能平均分布。 \n2. 与解决冲突的哈希冲突函数有关。 \n3. 与负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。 \n#### 解决冲突的办法\n* 开放定址法：线性探查法、平方探查法、伪随机序列法、双哈希函数法。 \n* 拉链法：把所有同义词，即hash值相同的记录，用单链表连接起来。\n#### 常用的hash函数\n```c\nunsigned int RSHash(char* str, unsigned int len)\n{\n    unsigned int b   = 378551;\n    unsigned int a   = 63689;\n    unsigned int hash = 0;\n    unsigned int i   = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = hash * a + (*str);\n        a    = a * b;\n    }\n\n    return hash;\n}\n/* End Of RS Hash Function */\n\nunsigned int JSHash(char* str, unsigned int len)\n{\n    unsigned int hash = 1315423911;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash ^= ((hash << 5) + (*str) + (hash >> 2));\n    }\n\n    return hash;\n}\n/* End Of JS Hash Function */\n\nunsigned int ELFHash(char* str, unsigned int len)\n{\n    unsigned int hash = 0;\n    unsigned int x\t = 0;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = (hash << 4) + (*str);\n        if((x = hash & 0xF0000000L) != 0)\n        {\n            hash ^= (x >> 24);\n        }\n        hash &= ~x;\n    }\n\n    return hash;\n}\n/* End Of ELF Hash Function */\n\nunsigned int DJBHash(char* str, unsigned int len)\n{\n    unsigned int hash = 5381;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = ((hash << 5) + hash) + (*str);\n    }\n\n    return hash;\n}\n/* End Of DJB Hash Function */\n```\n\n## javascript数据类型\n字符串 数字 布尔 对象 数组 undefined null\n\n> js只有一种数字类型\n> undefined：当声明的变量没有初始化的话，那这个变量的值就是undefined\n> null表示尚未存在的对象。\n","source":"_posts/c基础.md","raw":"---\ntitle: 嵌入式笔记：C基础\n---\n嵌入式笔记：C基础\n# 目录\n* [c基础](#c基础)\n    * [数据类型说明](#数据类型说明)\n    * [volatile](#volatile)\n    * [指针](#指针)\n        * [函数指针](#函数指针)\n        * [函数指针数组](#函数指针数组)\n        * [指针数组](#指针数组)\n        * [数组指针](#数组指针)\n        * [指针的指针](#指针的指针)\n    * [main函数的返回值](#main函数的返回值)\n    * [const](#const)\n    * [浮点数存储方式](#浮点数存储方式)\n* [c题目](#c题目)\n    * [printf返回值](#printf返回值)\n    * [enum枚举类型](#enum枚举类型)\n    * [可变参数函数](#可变参数函数)\n* [链表](#链表)\n* [排序算法](#排序算法)\n    * [选择排序](#选择排序)\n    * [插入排序](#插入排序)\n    * [希尔排序](#希尔排序)\n    * [冒泡排序](#冒泡排序)\n    * [快速排序](#快速排序)\n* [hash算法](#hash算法)\n    * [hash构造方法](#hash构造方法)\n    * [hash冲突及解决](#hash冲突及解决)\n    * [常用的hash函数](#常用的hash函数)\n    \n## c基础\n* [数据类型说明](#数据类型说明)\n* [volatile](#volatile)\n* [指针](#指针)\n* [const](#const)\n* [main函数的返回值](#main函数的返回值)\n* [浮点数存储方式](#浮点数存储方式)\n\n### 数据类型说明\n|  数据类型      | 16位平台  | 32位平台 | 64位平台 |\n| -------------|:---------:|:------:|:------:|\n| char         | 1 字节     | 1 字节 |  1 字节 |\n| pointer      | 2 字节     | 4 字节 |  8 字节 |\n| short        | 2 字节     | 2 字节 |  2 字节 |\n| int          | 2 字节     | 4 字节 |  4 字节 |\n| float        | 4 字节     | 4 字节 |  4 字节 |\n| double       | 8 字节     | 8 字节 |  8 字节 |\n| long         | 4 字节     | 4 字节 |  8 字节 |\n| long long    | 8 字节     | 8 字节 |  8 字节 |\n\n### volatile\nvolatile 指出变量是随时可能发生变化的，每次使用它的时候必须从变量的地址中读取，因而编译器生成的汇编代码会重新从变量的地址读取数据。\n1. 并行设备的硬件寄存器，\n2. 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables),可以使用关键区保护\n3. 多线程应用中被几个任务共享的变量，可以关闭系统调度\n\n### 指针\n#### 函数指针\n```c\nint (*fun)(int *a);\n```\n#### 函数指针数组\n```c\nint (*fun[10])(int *data, int size);\n```\n使用方法：\n```c\nint (*sort_fun[5])(int *data, int size) = {\n    quick_sort,     /* 快速排序 */\n    insert_sort,    /* 插入排序 */\n    bubble_sort,    /* 冒泡排序 */\n    heap_sort,      /* 堆排序 */\n    selection_sort  /* 选择排序 */\n};\n// 或者\nsort_fun[0] = quick_sort;\nsort_fun[1] = insert_sort;\n```\n\n#### 指针数组\n```c\nint *a[10];\n```\n\n#### 数组指针\n```c\n/* a为指向含10个元素的一维数组的指针变量，\n * ()优先级高，说明a是一个指针，指向一个整型的一维数组.\n * a+1时，a要跨过10个整型数据的长度 */\nint (*a)[10];\n```\n#### 指针的指针\n```c\nint **a;\n```\n\n\n### main函数的返回值\n1. 0 表示程序正常退出\n2. 负数表示程序异常退出\n\n### const\n#### const T\n定义一个常量，声明的同时必须进行初始化。一旦声明，这个值将不能被改变。\n```c\nconst int constInt = 10;        //正确\nconstInt = 20;                  //错误，常量值不可被改变\nconst int constInt3;            //错误，未被初始化\n```\n\n#### const T*\n指向常量的指针，不能用于改变其所指向的对象的值。\n```c\nconst int i = 5;\nconst int i2 = 10;\nconst int* pInt = &i;           //正确，指向一个const int对象，即i的地址\n//*pInt = 10;                   //错误，不能改变其所指缶的对象\npInt = &i2;                     //正确，可以改变pInt指针本身的值,此时pInt指向的是i2的地址\nconst int* p2 = new int(8);     //正确，指向一个new出来的对象的地址\ndelete p2;                      //正确\n//int* pInt = &i;               //错误，i是const int类型，类型不匹配，不能将const int * 初始化为int *\nint nValue = 15;\nconst int * pConstInt = &nValue;    //正确，可以把int *赋给const int *，但是pConstInt不能改变其所指向对象的值，即nValue\n*pConstInt = 40;                    //错误，不能改变其所指向对象的值\n```\n#### const int* 与int* const的区别\n指针本身就是一种对象，把指针定义为常量就是常量指针，也就是int* const的类型，也可以写成int *const，声明时必须初始化。\n```c\nint nValue = 10;\nint* const p = &nValue;\nint *const p2 = &nValue;\nconst int* 指针指向的对象不可以改变，但指针本身的值可以改变；int* const 指针本身的值不可改变，但其指向的对象可以改变。\nint nValue1 = 10;\nint nValue2 = 20;\nint* const constPoint = &nValue1;\n//constPoint = & nValue2;           //错误，不能改变constPoint本身的值\n*constPoint = 40;                   //正确，可以改变constPoint所指向的对象，此时nValue1 = 40\n\n\nconst int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* pPoint = &nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\npPoint = &nConstValue2;             //正确，可以改变pPoint指针本身的值，此时pPoint邦定的是nConstValue2对象，即pPoint为nConstValue2的地址\n```\nconst int* const 是一个指向常量对象的常量指针，即不可以改变指针本身的值，也不可以改变指针指向的对象。\n```c\nconst int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* const pPoint = &nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\n//pPoint = &nConstValue2;           //错误，不能改变pPoint本身的值\n```\n#### const助记方法\n##### 把一个声明从右向左读。( * 读成 pointer to )\n```c\nchar * const cp;  // cp is a const pointer to char\nconst char * p;   // p is a pointer to const char;\nchar const * p;   // 同上,因为C++里面没有const*的运算符，所以const只能属于前面的类型。\n```\n##### C++标准规定，const关键字放在类型或变量名之前等价的。\n\n结论：\n```c\nchar * const cp     // 定义一个指向字符的指针常数，即const指针\nconst char* p       // 定义一个指向字符常数的指针\nchar const* p       // 等同于const char* p\nconst char **       // 是一个指向指针的指针，那个指针又指向一个字符串常量。   \nchar **             // 也是一个指向指针的指针，那个指针又指向一个字符串变量。\n```\n\n### 浮点数存储方式\n1. float 占用4个字节，32bits\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>符号位</td>\n      <td width=\"150\">指数位</td>\n      <td width=\"300\">尾数部分</td>\n   </tr>\n   <tr>\n      <td>1 bits</td>\n      <td>8 bits</td>\n      <td>23 bits</td>\n   </tr>\n</table>\n\n2. double 占用8字节，64bits\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>符号位</td>\n      <td width=\"150\">指数位</td>\n      <td width=\"300\">尾数部分</td>\n   </tr>\n   <tr>\n      <td>1 bits</td>\n      <td>11 bits</td>\n      <td>52 bits</td>\n   </tr>\n</table>\n\n## c题目\n* [printf返回值](#printf返回值)\n* [enum枚举类型](#enum枚举类型)\n* [可变参数函数](#可变参数函数)\n\n### printf返回值\n```c\n#include <stdio.h>\nint main() {\n  int i = 43;\n  printf(\"%d\\n\", printf(\"%d\", printf(\"%d\", i)));\n  return 0;\n}\n```\n输出：4321\nprintf返回值是输出字符的个数（不包括字符串结尾\\x00）\n\n### enum枚举类型\n```c\n#include <stdio.h>\nint main() {\n  enum color{\n    RED,\n    BLUE,\n    GREEN = -2,\n    YELLOW,\n    PINK\n  };\n  printf(\"%d %d\\n\", BLUE, PINK);\n  return 0;\n}\n```\n输出：1 0\nenum默认是从0开始的，所以RED = 0， BLUE = 1， GREEN = -2， YELLOW = -1， PINK = 0；\n\n### 可变参数函数\n```c\n#include \"stdarg.h\"\n\nchar buf[512] = {0};\n\nint func(const char *fmt, ...)\n{\n  va_list args;\n  va_start(args, fmt);\n  vsprintf(buf, fmt, args);\n  va_end(args);\n}\n```\n### 大小端区分\n```c\nunion data {\n    int a;\n    char b;\n};\n\nstruct def {\n    union data mine;\n};\n\nstruct def endian;\n\nint main(int argc, char **argv)\n{\n    endian.mine.a = 0x12345678;\n    printf(\"%02X\\n\", endian.mine.b);\n\n    return 0;\n}\n/*打印 78 说明是小端， 12 说明是大端 */\n```\n\n## 链表\n```c\n////////////////////////////////////////////\n//单链表的初始化，建立，插入，查找，删除。//\n//Author:Wang Yong                        //\n//Date: 2010.8.19                         //\n////////////////////////////////////////////\n#include <stdio.h>\n#include <stdlib.h>\ntypedef int ElemType;\n////////////////////////////////////////////\n//定义结点类型\ntypedef struct Node\n{\n    ElemType data;              //单链表中的数据域\n    struct Node *next;          //单链表的指针域\n}Node,*LinkedList;\n////////////////////////////////////////////\n//单链表的初始化\nLinkedList LinkedListInit()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请结点空间\n    if(L == NULL)                       //判断是否有足够的内存空间\n        printf(\"申请内存空间失败/n\");\n    L->next = NULL;                  //将next设置为NULL,初始长度为0的单链表\n}\n////////////////////////////////////////////\n//单链表的建立1，头插法建立单链表\nLinkedList LinkedListCreatH()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L->next = NULL;                      //初始化一个空链表\n    \n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(\"%d\",&x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p->data = x;                     //结点数据域赋值\n        p->next = L->next;                    //将结点插入到表头L-->|2|-->|1|-->NULL\n        L->next = p; \n    }\n    return L;\n}\n////////////////////////////////////////////\n//单链表的建立2，尾插法建立单链表\nLinkedList LinkedListCreatT()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L->next = NULL;                  //初始化一个空链表\n    Node *r;\n    r = L;                          //r始终指向终端结点，开始时指向头结点\n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(\"%d\",&x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p->data = x;                     //结点数据域赋值\n        r->next = p;                 //将结点插入到表头L-->|1|-->|2|-->NULL\n        r = p;\n    }\n    r->next = NULL;\n    \n    return L;\n}\n////////////////////////////////////////////\n//单链表的插入，在链表的第i个位置插入x的元素\nLinkedList LinkedListInsert(LinkedList L,int i,ElemType x)\n{  \n    Node *pre;                      //pre为前驱结点\n    pre = L;\n    int tempi = 0;\n    for (tempi = 1; tempi < i; tempi++)\n        pre = pre->next;                 //查找第i个位置的前驱结点\n    Node *p;                                //插入的结点为p\n    p = (Node *)malloc(sizeof(Node));\n    p->data = x;\n    p->next = pre->next;\n    pre->next = p;\n\n    return L;\n}\n////////////////////////////////////////////\n//单链表的删除，在链表中删除值为x的元素\nLinkedList LinkedListDelete(LinkedList L,ElemType x)\n{\n    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。\n    p = L->next;\n    while(p->data != x)              //查找值为x的元素\n    {\n        pre = p;\n        p = p->next;\n    }\n    pre->next = p->next;          //删除操作，将其前驱next指向其后继。\n    free(p);\n    return L;\n}\n/////////////////////////////////////////////\nint main()\n{\n    LinkedList list,start;\n/*  printf(\"请输入单链表的数据：\");\n    list = LinkedListCreatH();\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n*/  printf(\"请输入单链表的数据：\");\n    list = LinkedListCreatT();\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n    int i;\n    ElemType x;\n    printf(\"请输入插入数据的位置：\");\n    scanf(\"%d\",&i);\n    printf(\"请输入插入数据的值：\");\n    scanf(\"%d\",&x);\n    LinkedListInsert(list,i,x);\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n    printf(\"请输入要删除的元素的值：\");\n    scanf(\"%d\",&x);\n    LinkedListDelete(list,x); \n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n\n    return 0;\n}\n```\n\n## 排序算法\n* [选择排序](#选择排序)\n* [插入排序](#插入排序)\n* [希尔排序](#希尔排序)\n* [冒泡排序](#冒泡排序)\n* [快速排序](#快速排序)\n\n排序算法有：\n<table>\n    <tr>\n      <td>选择排序</td>\n      <td>快速排序</td>\n      <td>希尔排序</td>\n      <td>冒泡排序</td>\n      <td>插入排序</td>\n      <td>堆排序</td>\n      <td>归并排序</td>\n    </tr>\n</table>\n排序算法比较：\n\n![排序算法比较](../res/sort/sort.png)\n\n### 选择排序\n选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。\n#### 时间复杂度\n    平均: O(n2) 最好: O(n2) 最坏:O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 重复第二步，直到所有元素均排序完毕。\n#### 动图演示\n![动图演示](../res/sort/selectionSort.gif)\n```c\n/* 直接选择排序 */\nvoid selection_sort(int n)\n{\n    for (int i = 0; i < n - 1; i++)\n    {\n        int min = i;\n        for (int j = i + 1; j < n; j++)\n        {\n            if (x[j] < x[min])\n            {\n                min = j;\n            }\n        }\n        if (min != i)\n        {\n            swap(x,i,min);\n        }\n    }\n}\n```\n### 插入排序\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n#### 时间复杂度\n    平均：O(n2) 最好：O(n) 最坏：O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n#### 动图演示\n![动图演示](res/sort/insertionSort.gif)\n```c\n/* 直接插入排序 */\nvoid insertion_sort(int n)\n{\n    for(int i = 1; i < n; i++)\n    {\n        int t = x[i];\n        int j;\n        for (j = i; j > 0 && x[j-1] > t ; j--)\n        {\n            x[j] = x[j - 1];\n        }\n        x[j] = t;\n    }\n}\n```\n### 希尔排序\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n#### 时间复杂度\n    平均：O(n1.5) 最好：O(n) 最坏O(n2)\n#### 空间复杂度\n    O(1) \n#### 算法步骤\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n```c\n/* 希尔排序 */\nvoid shell_sort(int n)\n{\n    for (int inc = n/3; inc >= 1; inc /= 3 )\n    {\n        for (int i = inc; i < n; i++)\n        {\n            int t = x[i];\n            int j;\n            for (j = i; j >= inc && x[j - inc] > t ; j -= inc)\n            {\n                x[j] = x[j - inc];\n            }\n            x[j] = t;\n        }\n    }\n}\n```\n### 冒泡排序\n\n#### 时间复杂度\n    平均: O(n2) 最好: O(n) 最坏：O(n2)\n#### 空间复杂度\n    O(1)\n#### 算法步骤\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n动图演示\n![动图演示](res/sort/bubbleSort.gif)\n```c\n/* 冒泡排序 */\nvoid bubble_sort(int n)\n{\n    bool change = true;\n    for (int i = n-1; i >= 1 && change; i--)\n    {\n        change = false;\n        for (int j = 0; j < i; j++)\n        {\n            if(x[j] > x[j + 1])\n            {\n                swap(x, j, j + 1);\n                change = true;\n            }\n        }\n    }\n}\n```\n### 快速排序\n快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。\n\n快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。\n\n快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：\n\n> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\n#### 时间复杂度\n    平均: O(nlogn) 最好: O(nlogn) 最坏:O(n2)\n#### 空间复杂度\n    O(nlogn)   用于方法栈\n#### 算法步骤\n1. 从数列中挑出一个元素，称为 “基准”（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n#### 动图演示\n\n![动图演示](res/sort/quickSort.gif)\n```c\n/* 快速排序 */\nvoid quick_sort(int l, int u)\n{\n    if (l >= u)\n        return;\n    int m = l;\n    for (int i = l+1; i<= u; i++)\n    {\n        if(x[i] < x[l])\n            swap(x, ++m, i);\n    }\n    swap(x, l, m);\n    quick_sort(l, m-1);\n    quick_sort(m+1, u);\n}\n```\n## hash算法\n### hash构造方法\n1. 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数） \n2. 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 \n3. 平方取中法：取关键字平方后的中间几位作为散列地址。 \n4. 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 \n5. 随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 \n6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。\n### hash冲突及解决\n#### 冲突原因： \n1. 与散列函数有关，一个好的散列函数的值应尽可能平均分布。 \n2. 与解决冲突的哈希冲突函数有关。 \n3. 与负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。 \n#### 解决冲突的办法\n* 开放定址法：线性探查法、平方探查法、伪随机序列法、双哈希函数法。 \n* 拉链法：把所有同义词，即hash值相同的记录，用单链表连接起来。\n#### 常用的hash函数\n```c\nunsigned int RSHash(char* str, unsigned int len)\n{\n    unsigned int b   = 378551;\n    unsigned int a   = 63689;\n    unsigned int hash = 0;\n    unsigned int i   = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = hash * a + (*str);\n        a    = a * b;\n    }\n\n    return hash;\n}\n/* End Of RS Hash Function */\n\nunsigned int JSHash(char* str, unsigned int len)\n{\n    unsigned int hash = 1315423911;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash ^= ((hash << 5) + (*str) + (hash >> 2));\n    }\n\n    return hash;\n}\n/* End Of JS Hash Function */\n\nunsigned int ELFHash(char* str, unsigned int len)\n{\n    unsigned int hash = 0;\n    unsigned int x\t = 0;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = (hash << 4) + (*str);\n        if((x = hash & 0xF0000000L) != 0)\n        {\n            hash ^= (x >> 24);\n        }\n        hash &= ~x;\n    }\n\n    return hash;\n}\n/* End Of ELF Hash Function */\n\nunsigned int DJBHash(char* str, unsigned int len)\n{\n    unsigned int hash = 5381;\n    unsigned int i\t = 0;\n\n    for(i = 0; i < len; str++, i++)\n    {\n        hash = ((hash << 5) + hash) + (*str);\n    }\n\n    return hash;\n}\n/* End Of DJB Hash Function */\n```\n\n## javascript数据类型\n字符串 数字 布尔 对象 数组 undefined null\n\n> js只有一种数字类型\n> undefined：当声明的变量没有初始化的话，那这个变量的值就是undefined\n> null表示尚未存在的对象。\n","slug":"c基础","published":1,"date":"2018-02-28T01:20:44.965Z","updated":"2018-02-28T01:17:33.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhb900049vf7hgi0qhvk","content":"<p>嵌入式笔记：C基础</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#c基础\">c基础</a><ul>\n<li><a href=\"#数据类型说明\">数据类型说明</a></li>\n<li><a href=\"#volatile\">volatile</a></li>\n<li><a href=\"#指针\">指针</a><ul>\n<li><a href=\"#函数指针\">函数指针</a></li>\n<li><a href=\"#函数指针数组\">函数指针数组</a></li>\n<li><a href=\"#指针数组\">指针数组</a></li>\n<li><a href=\"#数组指针\">数组指针</a></li>\n<li><a href=\"#指针的指针\">指针的指针</a></li>\n</ul>\n</li>\n<li><a href=\"#main函数的返回值\">main函数的返回值</a></li>\n<li><a href=\"#const\">const</a></li>\n<li><a href=\"#浮点数存储方式\">浮点数存储方式</a></li>\n</ul>\n</li>\n<li><a href=\"#c题目\">c题目</a><ul>\n<li><a href=\"#printf返回值\">printf返回值</a></li>\n<li><a href=\"#enum枚举类型\">enum枚举类型</a></li>\n<li><a href=\"#可变参数函数\">可变参数函数</a></li>\n</ul>\n</li>\n<li><a href=\"#链表\">链表</a></li>\n<li><a href=\"#排序算法\">排序算法</a><ul>\n<li><a href=\"#选择排序\">选择排序</a></li>\n<li><a href=\"#插入排序\">插入排序</a></li>\n<li><a href=\"#希尔排序\">希尔排序</a></li>\n<li><a href=\"#冒泡排序\">冒泡排序</a></li>\n<li><a href=\"#快速排序\">快速排序</a></li>\n</ul>\n</li>\n<li><a href=\"#hash算法\">hash算法</a><ul>\n<li><a href=\"#hash构造方法\">hash构造方法</a></li>\n<li><a href=\"#hash冲突及解决\">hash冲突及解决</a></li>\n<li><a href=\"#常用的hash函数\">常用的hash函数</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"c基础\"><a href=\"#c基础\" class=\"headerlink\" title=\"c基础\"></a>c基础</h2><ul>\n<li><a href=\"#数据类型说明\">数据类型说明</a></li>\n<li><a href=\"#volatile\">volatile</a></li>\n<li><a href=\"#指针\">指针</a></li>\n<li><a href=\"#const\">const</a></li>\n<li><a href=\"#main函数的返回值\">main函数的返回值</a></li>\n<li><a href=\"#浮点数存储方式\">浮点数存储方式</a></li>\n</ul>\n<h3 id=\"数据类型说明\"><a href=\"#数据类型说明\" class=\"headerlink\" title=\"数据类型说明\"></a>数据类型说明</h3><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th style=\"text-align:center\">16位平台</th>\n<th style=\"text-align:center\">32位平台</th>\n<th style=\"text-align:center\">64位平台</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td style=\"text-align:center\">1 字节</td>\n<td style=\"text-align:center\">1 字节</td>\n<td style=\"text-align:center\">1 字节</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>short</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">2 字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n</tr>\n<tr>\n<td>double</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>long</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>long long</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile 指出变量是随时可能发生变化的，每次使用它的时候必须从变量的地址中读取，因而编译器生成的汇编代码会重新从变量的地址读取数据。</p>\n<ol>\n<li>并行设备的硬件寄存器，</li>\n<li>一个中断服务子程序中会访问到的非自动变量（Non-automatic variables),可以使用关键区保护</li>\n<li>多线程应用中被几个任务共享的变量，可以关闭系统调度</li>\n</ol>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"函数指针数组\"><a href=\"#函数指针数组\" class=\"headerlink\" title=\"函数指针数组\"></a>函数指针数组</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fun<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用方法：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>sort_fun<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    quick_sort<span class=\"token punctuation\">,</span>     <span class=\"token comment\" spellcheck=\"true\">/* 快速排序 */</span>\n    insert_sort<span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">/* 插入排序 */</span>\n    bubble_sort<span class=\"token punctuation\">,</span>    <span class=\"token comment\" spellcheck=\"true\">/* 冒泡排序 */</span>\n    heap_sort<span class=\"token punctuation\">,</span>      <span class=\"token comment\" spellcheck=\"true\">/* 堆排序 */</span>\n    selection_sort  <span class=\"token comment\" spellcheck=\"true\">/* 选择排序 */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 或者</span>\nsort_fun<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> quick_sort<span class=\"token punctuation\">;</span>\nsort_fun<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> insert_sort<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* a为指向含10个元素的一维数组的指针变量，\n * ()优先级高，说明a是一个指针，指向一个整型的一维数组.\n * a+1时，a要跨过10个整型数据的长度 */</span>\n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"指针的指针\"><a href=\"#指针的指针\" class=\"headerlink\" title=\"指针的指针\"></a>指针的指针</h4><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"main函数的返回值\"><a href=\"#main函数的返回值\" class=\"headerlink\" title=\"main函数的返回值\"></a>main函数的返回值</h3><ol>\n<li>0 表示程序正常退出</li>\n<li>负数表示程序异常退出</li>\n</ol>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><h4 id=\"const-T\"><a href=\"#const-T\" class=\"headerlink\" title=\"const T\"></a>const T</h4><p>定义一个常量，声明的同时必须进行初始化。一旦声明，这个值将不能被改变。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> constInt <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">//正确</span>\nconstInt <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\" spellcheck=\"true\">//错误，常量值不可被改变</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> constInt3<span class=\"token punctuation\">;</span>            <span class=\"token comment\" spellcheck=\"true\">//错误，未被初始化</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"const-T-1\"><a href=\"#const-T-1\" class=\"headerlink\" title=\"const T*\"></a>const T*</h4><p>指向常量的指针，不能用于改变其所指向的对象的值。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> i2 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> pInt <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">;</span>           <span class=\"token comment\" spellcheck=\"true\">//正确，指向一个const int对象，即i的地址</span>\n<span class=\"token comment\" spellcheck=\"true\">//*pInt = 10;                   //错误，不能改变其所指缶的对象</span>\npInt <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i2<span class=\"token punctuation\">;</span>                     <span class=\"token comment\" spellcheck=\"true\">//正确，可以改变pInt指针本身的值,此时pInt指向的是i2的地址</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p2 <span class=\"token operator\">=</span> new <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">//正确，指向一个new出来的对象的地址</span>\ndelete p2<span class=\"token punctuation\">;</span>                      <span class=\"token comment\" spellcheck=\"true\">//正确</span>\n<span class=\"token comment\" spellcheck=\"true\">//int* pInt = &amp;i;               //错误，i是const int类型，类型不匹配，不能将const int * 初始化为int *</span>\n<span class=\"token keyword\">int</span> nValue <span class=\"token operator\">=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span> pConstInt <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nValue<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//正确，可以把int *赋给const int *，但是pConstInt不能改变其所指向对象的值，即nValue</span>\n<span class=\"token operator\">*</span>pConstInt <span class=\"token operator\">=</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span>                    <span class=\"token comment\" spellcheck=\"true\">//错误，不能改变其所指向对象的值</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"const-int-与int-const的区别\"><a href=\"#const-int-与int-const的区别\" class=\"headerlink\" title=\"const int 与int const的区别\"></a>const int<em> 与int</em> const的区别</h4><p>指针本身就是一种对象，把指针定义为常量就是常量指针，也就是int<em> const的类型，也可以写成int </em>const，声明时必须初始化。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> nValue <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nValue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> p2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nValue<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> 指针指向的对象不可以改变，但指针本身的值可以改变；<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> 指针本身的值不可改变，但其指向的对象可以改变。\n<span class=\"token keyword\">int</span> nValue1 <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> nValue2 <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> constPoint <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nValue1<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//constPoint = &amp; nValue2;           //错误，不能改变constPoint本身的值</span>\n<span class=\"token operator\">*</span>constPoint <span class=\"token operator\">=</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span>                   <span class=\"token comment\" spellcheck=\"true\">//正确，可以改变constPoint所指向的对象，此时nValue1 = 40</span>\n\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> nConstValue1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> nConstValue2 <span class=\"token operator\">=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> pPoint <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nConstValue1<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值</span>\npPoint <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nConstValue2<span class=\"token punctuation\">;</span>             <span class=\"token comment\" spellcheck=\"true\">//正确，可以改变pPoint指针本身的值，此时pPoint邦定的是nConstValue2对象，即pPoint为nConstValue2的地址</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>const int* const 是一个指向常量对象的常量指针，即不可以改变指针本身的值，也不可以改变指针指向的对象。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> nConstValue1 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> nConstValue2 <span class=\"token operator\">=</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> pPoint <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>nConstValue1<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值</span>\n<span class=\"token comment\" spellcheck=\"true\">//pPoint = &amp;nConstValue2;           //错误，不能改变pPoint本身的值</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"const助记方法\"><a href=\"#const助记方法\" class=\"headerlink\" title=\"const助记方法\"></a>const助记方法</h4><h5 id=\"把一个声明从右向左读。-读成-pointer-to\"><a href=\"#把一个声明从右向左读。-读成-pointer-to\" class=\"headerlink\" title=\"把一个声明从右向左读。( * 读成 pointer to )\"></a>把一个声明从右向左读。( * 读成 pointer to )</h5><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> cp<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// cp is a const pointer to char</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> p<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// p is a pointer to const char;</span>\n<span class=\"token keyword\">char</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">*</span> p<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 同上,因为C++里面没有const*的运算符，所以const只能属于前面的类型。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"C-标准规定，const关键字放在类型或变量名之前等价的。\"><a href=\"#C-标准规定，const关键字放在类型或变量名之前等价的。\" class=\"headerlink\" title=\"C++标准规定，const关键字放在类型或变量名之前等价的。\"></a>C++标准规定，const关键字放在类型或变量名之前等价的。</h5><p>结论：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> cp     <span class=\"token comment\" spellcheck=\"true\">// 定义一个指向字符的指针常数，即const指针</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> p       <span class=\"token comment\" spellcheck=\"true\">// 定义一个指向字符常数的指针</span>\n<span class=\"token keyword\">char</span> <span class=\"token keyword\">const</span><span class=\"token operator\">*</span> p       <span class=\"token comment\" spellcheck=\"true\">// 等同于const char* p</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>       <span class=\"token comment\" spellcheck=\"true\">// 是一个指向指针的指针，那个指针又指向一个字符串常量。   </span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>             <span class=\"token comment\" spellcheck=\"true\">// 也是一个指向指针的指针，那个指针又指向一个字符串变量。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"浮点数存储方式\"><a href=\"#浮点数存储方式\" class=\"headerlink\" title=\"浮点数存储方式\"></a>浮点数存储方式</h3><ol>\n<li>float 占用4个字节，32bits</li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>符号位</td><br>      <td width=\"150\">指数位</td><br>      <td width=\"300\">尾数部分</td><br>   </tr><br>   <tr><br>      <td>1 bits</td><br>      <td>8 bits</td><br>      <td>23 bits</td><br>   </tr><br></table>\n\n<ol>\n<li>double 占用8字节，64bits</li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>符号位</td><br>      <td width=\"150\">指数位</td><br>      <td width=\"300\">尾数部分</td><br>   </tr><br>   <tr><br>      <td>1 bits</td><br>      <td>11 bits</td><br>      <td>52 bits</td><br>   </tr><br></table>\n\n<h2 id=\"c题目\"><a href=\"#c题目\" class=\"headerlink\" title=\"c题目\"></a>c题目</h2><ul>\n<li><a href=\"#printf返回值\">printf返回值</a></li>\n<li><a href=\"#enum枚举类型\">enum枚举类型</a></li>\n<li><a href=\"#可变参数函数\">可变参数函数</a></li>\n</ul>\n<h3 id=\"printf返回值\"><a href=\"#printf返回值\" class=\"headerlink\" title=\"printf返回值\"></a>printf返回值</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">43</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：4321<br>printf返回值是输出字符的个数（不包括字符串结尾\\x00）</p>\n<h3 id=\"enum枚举类型\"><a href=\"#enum枚举类型\" class=\"headerlink\" title=\"enum枚举类型\"></a>enum枚举类型</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">enum</span> color<span class=\"token punctuation\">{</span>\n    RED<span class=\"token punctuation\">,</span>\n    BLUE<span class=\"token punctuation\">,</span>\n    GREEN <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    YELLOW<span class=\"token punctuation\">,</span>\n    PINK\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d\\n\"</span><span class=\"token punctuation\">,</span> BLUE<span class=\"token punctuation\">,</span> PINK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：1 0<br>enum默认是从0开始的，所以RED = 0， BLUE = 1， GREEN = -2， YELLOW = -1， PINK = 0；</p>\n<h3 id=\"可变参数函数\"><a href=\"#可变参数函数\" class=\"headerlink\" title=\"可变参数函数\"></a>可变参数函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"stdarg.h\"</span></span>\n\n<span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">512</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>fmt<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n  va_list args<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> fmt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">vsprintf</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> fmt<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"大小端区分\"><a href=\"#大小端区分\" class=\"headerlink\" title=\"大小端区分\"></a>大小端区分</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">union</span> data <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> def <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">union</span> data mine<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> def endian<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    endian<span class=\"token punctuation\">.</span>mine<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">0x12345678</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%02X\\n\"</span><span class=\"token punctuation\">,</span> endian<span class=\"token punctuation\">.</span>mine<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*打印 78 说明是小端， 12 说明是大端 */</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的初始化，建立，插入，查找，删除。//</span>\n<span class=\"token comment\" spellcheck=\"true\">//Author:Wang Yong                        //</span>\n<span class=\"token comment\" spellcheck=\"true\">//Date: 2010.8.19                         //</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> ElemType<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//定义结点类型</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> Node\n<span class=\"token punctuation\">{</span>\n    ElemType data<span class=\"token punctuation\">;</span>              <span class=\"token comment\" spellcheck=\"true\">//单链表中的数据域</span>\n    <span class=\"token keyword\">struct</span> Node <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">//单链表的指针域</span>\n<span class=\"token punctuation\">}</span>Node<span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>LinkedList<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的初始化</span>\nLinkedList <span class=\"token function\">LinkedListInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Node <span class=\"token operator\">*</span>L<span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//申请结点空间</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>                       <span class=\"token comment\" spellcheck=\"true\">//判断是否有足够的内存空间</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"申请内存空间失败/n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    L<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\" spellcheck=\"true\">//将next设置为NULL,初始长度为0的单链表</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的建立1，头插法建立单链表</span>\nLinkedList <span class=\"token function\">LinkedListCreatH</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Node <span class=\"token operator\">*</span>L<span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//申请头结点空间</span>\n    L<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>                      <span class=\"token comment\" spellcheck=\"true\">//初始化一个空链表</span>\n\n    ElemType x<span class=\"token punctuation\">;</span>                         <span class=\"token comment\" spellcheck=\"true\">//x为链表数据域中的数据</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//申请新的结点</span>\n        p<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>                     <span class=\"token comment\" spellcheck=\"true\">//结点数据域赋值</span>\n        p<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> L<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>                    <span class=\"token comment\" spellcheck=\"true\">//将结点插入到表头L-->|2|-->|1|-->NULL</span>\n        L<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> L<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的建立2，尾插法建立单链表</span>\nLinkedList <span class=\"token function\">LinkedListCreatT</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Node <span class=\"token operator\">*</span>L<span class=\"token punctuation\">;</span>\n    L <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//申请头结点空间</span>\n    L<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>                  <span class=\"token comment\" spellcheck=\"true\">//初始化一个空链表</span>\n    Node <span class=\"token operator\">*</span>r<span class=\"token punctuation\">;</span>\n    r <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>                          <span class=\"token comment\" spellcheck=\"true\">//r始终指向终端结点，开始时指向头结点</span>\n    ElemType x<span class=\"token punctuation\">;</span>                         <span class=\"token comment\" spellcheck=\"true\">//x为链表数据域中的数据</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        Node <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//申请新的结点</span>\n        p<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>                     <span class=\"token comment\" spellcheck=\"true\">//结点数据域赋值</span>\n        r<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>                 <span class=\"token comment\" spellcheck=\"true\">//将结点插入到表头L-->|1|-->|2|-->NULL</span>\n        r <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    r<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> L<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的插入，在链表的第i个位置插入x的元素</span>\nLinkedList <span class=\"token function\">LinkedListInsert</span><span class=\"token punctuation\">(</span>LinkedList L<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span>ElemType x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>  \n    Node <span class=\"token operator\">*</span>pre<span class=\"token punctuation\">;</span>                      <span class=\"token comment\" spellcheck=\"true\">//pre为前驱结点</span>\n    pre <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> tempi <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>tempi <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> tempi <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> tempi<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n        pre <span class=\"token operator\">=</span> pre<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>                 <span class=\"token comment\" spellcheck=\"true\">//查找第i个位置的前驱结点</span>\n    Node <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>                                <span class=\"token comment\" spellcheck=\"true\">//插入的结点为p</span>\n    p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>data <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    p<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> pre<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    pre<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> L<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">////////////////////////////////////////////</span>\n<span class=\"token comment\" spellcheck=\"true\">//单链表的删除，在链表中删除值为x的元素</span>\nLinkedList <span class=\"token function\">LinkedListDelete</span><span class=\"token punctuation\">(</span>LinkedList L<span class=\"token punctuation\">,</span>ElemType x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Node <span class=\"token operator\">*</span>p<span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>pre<span class=\"token punctuation\">;</span>                   <span class=\"token comment\" spellcheck=\"true\">//pre为前驱结点，p为查找的结点。</span>\n    p <span class=\"token operator\">=</span> L<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>data <span class=\"token operator\">!=</span> x<span class=\"token punctuation\">)</span>              <span class=\"token comment\" spellcheck=\"true\">//查找值为x的元素</span>\n    <span class=\"token punctuation\">{</span>\n        pre <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        p <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    pre<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>          <span class=\"token comment\" spellcheck=\"true\">//删除操作，将其前驱next指向其后继。</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> L<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/////////////////////////////////////////////</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    LinkedList list<span class=\"token punctuation\">,</span>start<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/*  printf(\"请输入单链表的数据：\");\n    list = LinkedListCreatH();\n    for(start = list->next; start != NULL; start = start->next)\n        printf(\"%d \",start->data);\n    printf(\"/n\");\n*/</span>  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入单链表的数据：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    list <span class=\"token operator\">=</span> <span class=\"token function\">LinkedListCreatT</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> list<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span> start <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> start <span class=\"token operator\">=</span> start<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span>start<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    ElemType x<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入插入数据的位置：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入插入数据的值：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">LinkedListInsert</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> list<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span> start <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> start <span class=\"token operator\">=</span> start<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span>start<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"请输入要删除的元素的值：\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">LinkedListDelete</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> list<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span> start <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span> start <span class=\"token operator\">=</span> start<span class=\"token operator\">-></span>next<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span>start<span class=\"token operator\">-></span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><ul>\n<li><a href=\"#选择排序\">选择排序</a></li>\n<li><a href=\"#插入排序\">插入排序</a></li>\n<li><a href=\"#希尔排序\">希尔排序</a></li>\n<li><a href=\"#冒泡排序\">冒泡排序</a></li>\n<li><a href=\"#快速排序\">快速排序</a></li>\n</ul>\n<p>排序算法有：</p>\n<p><table><br>    <tr><br>      <td>选择排序</td><br>      <td>快速排序</td><br>      <td>希尔排序</td><br>      <td>冒泡排序</td><br>      <td>插入排序</td><br>      <td>堆排序</td><br>      <td>归并排序</td><br>    </tr><br></table><br>排序算法比较：</p>\n<p><img src=\"../res/sort/sort.png\" alt=\"排序算法比较\"></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(n2) 最好: O(n2) 最坏:O(n2)\n</code></pre><h4 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(1)\n</code></pre><h4 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕。<h4 id=\"动图演示\"><a href=\"#动图演示\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><img src=\"../res/sort/selectionSort.gif\" alt=\"动图演示\"><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 直接选择排序 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">selection_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{</span>\n             min <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min <span class=\"token operator\">!=</span> i<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{</span>\n         <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">,</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。<h4 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4> 平均：O(n2) 最好：O(n) 最坏：O(n2)<h4 id=\"空间复杂度-1\"><a href=\"#空间复杂度-1\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4> O(1)<h4 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4></li>\n<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>\n<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<h4 id=\"动图演示-1\"><a href=\"#动图演示-1\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><img src=\"res/sort/insertionSort.gif\" alt=\"动图演示\"><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 直接插入排序 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">insertion_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> t <span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{</span>\n         x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<ul>\n<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>\n<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。<h4 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4>平均：O(n1.5) 最好：O(n) 最坏O(n2)<h4 id=\"空间复杂度-2\"><a href=\"#空间复杂度-2\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4>O(1) <h4 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4></li>\n</ul>\n</li>\n<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 希尔排序 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">shell_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inc <span class=\"token operator\">=</span> n<span class=\"token operator\">/</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> inc <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> inc <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> inc<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> inc <span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> inc<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> t <span class=\"token punctuation\">;</span> j <span class=\"token operator\">-</span><span class=\"token operator\">=</span> inc<span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{</span>\n             x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> inc<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n         x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3></li>\n</ol>\n<h4 id=\"时间复杂度-3\"><a href=\"#时间复杂度-3\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(n2) 最好: O(n) 最坏：O(n2)\n</code></pre><h4 id=\"空间复杂度-3\"><a href=\"#空间复杂度-3\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(1)\n</code></pre><h4 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>动图演示<br><img src=\"res/sort/bubbleSort.gif\" alt=\"动图演示\"><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 冒泡排序 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n bool change <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> change<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{</span>\n     change <span class=\"token operator\">=</span> false<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> x<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n         <span class=\"token punctuation\">{</span>\n             <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             change <span class=\"token operator\">=</span> true<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li>\n</ol>\n<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>\n<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>\n<blockquote>\n<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>\n</blockquote>\n<h4 id=\"时间复杂度-4\"><a href=\"#时间复杂度-4\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(nlogn) 最好: O(nlogn) 最坏:O(n2)\n</code></pre><h4 id=\"空间复杂度-4\"><a href=\"#空间复杂度-4\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(nlogn)   用于方法栈\n</code></pre><h4 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>\n</ol>\n<h4 id=\"动图演示-2\"><a href=\"#动图演示-2\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><p><img src=\"res/sort/quickSort.gif\" alt=\"动图演示\"></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* 快速排序 */</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> u<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> u<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> l<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span> u<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> x<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">++</span>m<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">,</span> m<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>m<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"hash算法\"><a href=\"#hash算法\" class=\"headerlink\" title=\"hash算法\"></a>hash算法</h2><h3 id=\"hash构造方法\"><a href=\"#hash构造方法\" class=\"headerlink\" title=\"hash构造方法\"></a>hash构造方法</h3><ol>\n<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数） </li>\n<li>数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 </li>\n<li>平方取中法：取关键字平方后的中间几位作为散列地址。 </li>\n<li>折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 </li>\n<li>随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 </li>\n<li>除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。<h3 id=\"hash冲突及解决\"><a href=\"#hash冲突及解决\" class=\"headerlink\" title=\"hash冲突及解决\"></a>hash冲突及解决</h3><h4 id=\"冲突原因：\"><a href=\"#冲突原因：\" class=\"headerlink\" title=\"冲突原因：\"></a>冲突原因：</h4></li>\n<li>与散列函数有关，一个好的散列函数的值应尽可能平均分布。 </li>\n<li>与解决冲突的哈希冲突函数有关。 </li>\n<li>与负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。 <h4 id=\"解决冲突的办法\"><a href=\"#解决冲突的办法\" class=\"headerlink\" title=\"解决冲突的办法\"></a>解决冲突的办法</h4></li>\n</ol>\n<ul>\n<li>开放定址法：线性探查法、平方探查法、伪随机序列法、双哈希函数法。 </li>\n<li><p>拉链法：把所有同义词，即hash值相同的记录，用单链表连接起来。</p>\n<h4 id=\"常用的hash函数\"><a href=\"#常用的hash函数\" class=\"headerlink\" title=\"常用的hash函数\"></a>常用的hash函数</h4><p><code>`</code>c<br>unsigned int RSHash(char* str, unsigned int len)<br>{<br>  unsigned int b   = 378551;<br>  unsigned int a   = 63689;<br>  unsigned int hash = 0;<br>  unsigned int i   = 0;</p>\n<p>  for(i = 0; i &lt; len; str++, i++)<br>  {</p>\n<pre><code>  hash = hash * a + (*str);\n  a    = a * b;\n</code></pre><p>  }</p>\n<p>  return hash;<br>}<br>/<em> End Of RS Hash Function </em>/</p>\n</li>\n</ul>\n<p>unsigned int JSHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 1315423911;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash ^= ((hash &lt;&lt; 5) + (*str) + (hash &gt;&gt; 2));\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of JS Hash Function </em>/</p>\n<p>unsigned int ELFHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 0;<br>    unsigned int x     = 0;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash = (hash &lt;&lt; 4) + (*str);\n    if((x = hash &amp; 0xF0000000L) != 0)\n    {\n        hash ^= (x &gt;&gt; 24);\n    }\n    hash &amp;= ~x;\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of ELF Hash Function </em>/</p>\n<p>unsigned int DJBHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 5381;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash = ((hash &lt;&lt; 5) + hash) + (*str);\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of DJB Hash Function </em>/<br><code>`</code></p>\n<h2 id=\"javascript数据类型\"><a href=\"#javascript数据类型\" class=\"headerlink\" title=\"javascript数据类型\"></a>javascript数据类型</h2><p>字符串 数字 布尔 对象 数组 undefined null</p>\n<blockquote>\n<p>js只有一种数字类型<br>undefined：当声明的变量没有初始化的话，那这个变量的值就是undefined<br>null表示尚未存在的对象。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：C基础</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#c基础\">c基础</a><ul>\n<li><a href=\"#数据类型说明\">数据类型说明</a></li>\n<li><a href=\"#volatile\">volatile</a></li>\n<li><a href=\"#指针\">指针</a><ul>\n<li><a href=\"#函数指针\">函数指针</a></li>\n<li><a href=\"#函数指针数组\">函数指针数组</a></li>\n<li><a href=\"#指针数组\">指针数组</a></li>\n<li><a href=\"#数组指针\">数组指针</a></li>\n<li><a href=\"#指针的指针\">指针的指针</a></li>\n</ul>\n</li>\n<li><a href=\"#main函数的返回值\">main函数的返回值</a></li>\n<li><a href=\"#const\">const</a></li>\n<li><a href=\"#浮点数存储方式\">浮点数存储方式</a></li>\n</ul>\n</li>\n<li><a href=\"#c题目\">c题目</a><ul>\n<li><a href=\"#printf返回值\">printf返回值</a></li>\n<li><a href=\"#enum枚举类型\">enum枚举类型</a></li>\n<li><a href=\"#可变参数函数\">可变参数函数</a></li>\n</ul>\n</li>\n<li><a href=\"#链表\">链表</a></li>\n<li><a href=\"#排序算法\">排序算法</a><ul>\n<li><a href=\"#选择排序\">选择排序</a></li>\n<li><a href=\"#插入排序\">插入排序</a></li>\n<li><a href=\"#希尔排序\">希尔排序</a></li>\n<li><a href=\"#冒泡排序\">冒泡排序</a></li>\n<li><a href=\"#快速排序\">快速排序</a></li>\n</ul>\n</li>\n<li><a href=\"#hash算法\">hash算法</a><ul>\n<li><a href=\"#hash构造方法\">hash构造方法</a></li>\n<li><a href=\"#hash冲突及解决\">hash冲突及解决</a></li>\n<li><a href=\"#常用的hash函数\">常用的hash函数</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"c基础\"><a href=\"#c基础\" class=\"headerlink\" title=\"c基础\"></a>c基础</h2><ul>\n<li><a href=\"#数据类型说明\">数据类型说明</a></li>\n<li><a href=\"#volatile\">volatile</a></li>\n<li><a href=\"#指针\">指针</a></li>\n<li><a href=\"#const\">const</a></li>\n<li><a href=\"#main函数的返回值\">main函数的返回值</a></li>\n<li><a href=\"#浮点数存储方式\">浮点数存储方式</a></li>\n</ul>\n<h3 id=\"数据类型说明\"><a href=\"#数据类型说明\" class=\"headerlink\" title=\"数据类型说明\"></a>数据类型说明</h3><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th style=\"text-align:center\">16位平台</th>\n<th style=\"text-align:center\">32位平台</th>\n<th style=\"text-align:center\">64位平台</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td style=\"text-align:center\">1 字节</td>\n<td style=\"text-align:center\">1 字节</td>\n<td style=\"text-align:center\">1 字节</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>short</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">2 字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td style=\"text-align:center\">2 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n</tr>\n<tr>\n<td>double</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>long</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">4 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n<tr>\n<td>long long</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n<td style=\"text-align:center\">8 字节</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile 指出变量是随时可能发生变化的，每次使用它的时候必须从变量的地址中读取，因而编译器生成的汇编代码会重新从变量的地址读取数据。</p>\n<ol>\n<li>并行设备的硬件寄存器，</li>\n<li>一个中断服务子程序中会访问到的非自动变量（Non-automatic variables),可以使用关键区保护</li>\n<li>多线程应用中被几个任务共享的变量，可以关闭系统调度</li>\n</ol>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h4><pre><code class=\"c\">int (*fun)(int *a);\n</code></pre>\n<h4 id=\"函数指针数组\"><a href=\"#函数指针数组\" class=\"headerlink\" title=\"函数指针数组\"></a>函数指针数组</h4><pre><code class=\"c\">int (*fun[10])(int *data, int size);\n</code></pre>\n<p>使用方法：</p>\n<pre><code class=\"c\">int (*sort_fun[5])(int *data, int size) = {\n    quick_sort,     /* 快速排序 */\n    insert_sort,    /* 插入排序 */\n    bubble_sort,    /* 冒泡排序 */\n    heap_sort,      /* 堆排序 */\n    selection_sort  /* 选择排序 */\n};\n// 或者\nsort_fun[0] = quick_sort;\nsort_fun[1] = insert_sort;\n</code></pre>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><pre><code class=\"c\">int *a[10];\n</code></pre>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><pre><code class=\"c\">/* a为指向含10个元素的一维数组的指针变量，\n * ()优先级高，说明a是一个指针，指向一个整型的一维数组.\n * a+1时，a要跨过10个整型数据的长度 */\nint (*a)[10];\n</code></pre>\n<h4 id=\"指针的指针\"><a href=\"#指针的指针\" class=\"headerlink\" title=\"指针的指针\"></a>指针的指针</h4><pre><code class=\"c\">int **a;\n</code></pre>\n<h3 id=\"main函数的返回值\"><a href=\"#main函数的返回值\" class=\"headerlink\" title=\"main函数的返回值\"></a>main函数的返回值</h3><ol>\n<li>0 表示程序正常退出</li>\n<li>负数表示程序异常退出</li>\n</ol>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><h4 id=\"const-T\"><a href=\"#const-T\" class=\"headerlink\" title=\"const T\"></a>const T</h4><p>定义一个常量，声明的同时必须进行初始化。一旦声明，这个值将不能被改变。</p>\n<pre><code class=\"c\">const int constInt = 10;        //正确\nconstInt = 20;                  //错误，常量值不可被改变\nconst int constInt3;            //错误，未被初始化\n</code></pre>\n<h4 id=\"const-T-1\"><a href=\"#const-T-1\" class=\"headerlink\" title=\"const T*\"></a>const T*</h4><p>指向常量的指针，不能用于改变其所指向的对象的值。</p>\n<pre><code class=\"c\">const int i = 5;\nconst int i2 = 10;\nconst int* pInt = &amp;i;           //正确，指向一个const int对象，即i的地址\n//*pInt = 10;                   //错误，不能改变其所指缶的对象\npInt = &amp;i2;                     //正确，可以改变pInt指针本身的值,此时pInt指向的是i2的地址\nconst int* p2 = new int(8);     //正确，指向一个new出来的对象的地址\ndelete p2;                      //正确\n//int* pInt = &amp;i;               //错误，i是const int类型，类型不匹配，不能将const int * 初始化为int *\nint nValue = 15;\nconst int * pConstInt = &amp;nValue;    //正确，可以把int *赋给const int *，但是pConstInt不能改变其所指向对象的值，即nValue\n*pConstInt = 40;                    //错误，不能改变其所指向对象的值\n</code></pre>\n<h4 id=\"const-int-与int-const的区别\"><a href=\"#const-int-与int-const的区别\" class=\"headerlink\" title=\"const int 与int const的区别\"></a>const int<em> 与int</em> const的区别</h4><p>指针本身就是一种对象，把指针定义为常量就是常量指针，也就是int<em> const的类型，也可以写成int </em>const，声明时必须初始化。</p>\n<pre><code class=\"c\">int nValue = 10;\nint* const p = &amp;nValue;\nint *const p2 = &amp;nValue;\nconst int* 指针指向的对象不可以改变，但指针本身的值可以改变；int* const 指针本身的值不可改变，但其指向的对象可以改变。\nint nValue1 = 10;\nint nValue2 = 20;\nint* const constPoint = &amp;nValue1;\n//constPoint = &amp; nValue2;           //错误，不能改变constPoint本身的值\n*constPoint = 40;                   //正确，可以改变constPoint所指向的对象，此时nValue1 = 40\n\n\nconst int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* pPoint = &amp;nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\npPoint = &amp;nConstValue2;             //正确，可以改变pPoint指针本身的值，此时pPoint邦定的是nConstValue2对象，即pPoint为nConstValue2的地址\n</code></pre>\n<p>const int* const 是一个指向常量对象的常量指针，即不可以改变指针本身的值，也不可以改变指针指向的对象。</p>\n<pre><code class=\"c\">const int nConstValue1 = 5;\nconst int nConstValue2 = 15;\nconst int* const pPoint = &amp;nConstValue1;\n//*pPoint  = 55;                    //错误，不能改变pPoint所指向对象的值\n//pPoint = &amp;nConstValue2;           //错误，不能改变pPoint本身的值\n</code></pre>\n<h4 id=\"const助记方法\"><a href=\"#const助记方法\" class=\"headerlink\" title=\"const助记方法\"></a>const助记方法</h4><h5 id=\"把一个声明从右向左读。-读成-pointer-to\"><a href=\"#把一个声明从右向左读。-读成-pointer-to\" class=\"headerlink\" title=\"把一个声明从右向左读。( * 读成 pointer to )\"></a>把一个声明从右向左读。( * 读成 pointer to )</h5><pre><code class=\"c\">char * const cp;  // cp is a const pointer to char\nconst char * p;   // p is a pointer to const char;\nchar const * p;   // 同上,因为C++里面没有const*的运算符，所以const只能属于前面的类型。\n</code></pre>\n<h5 id=\"C-标准规定，const关键字放在类型或变量名之前等价的。\"><a href=\"#C-标准规定，const关键字放在类型或变量名之前等价的。\" class=\"headerlink\" title=\"C++标准规定，const关键字放在类型或变量名之前等价的。\"></a>C++标准规定，const关键字放在类型或变量名之前等价的。</h5><p>结论：</p>\n<pre><code class=\"c\">char * const cp     // 定义一个指向字符的指针常数，即const指针\nconst char* p       // 定义一个指向字符常数的指针\nchar const* p       // 等同于const char* p\nconst char **       // 是一个指向指针的指针，那个指针又指向一个字符串常量。   \nchar **             // 也是一个指向指针的指针，那个指针又指向一个字符串变量。\n</code></pre>\n<h3 id=\"浮点数存储方式\"><a href=\"#浮点数存储方式\" class=\"headerlink\" title=\"浮点数存储方式\"></a>浮点数存储方式</h3><ol>\n<li>float 占用4个字节，32bits</li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>符号位</td><br>      <td width=\"150\">指数位</td><br>      <td width=\"300\">尾数部分</td><br>   </tr><br>   <tr><br>      <td>1 bits</td><br>      <td>8 bits</td><br>      <td>23 bits</td><br>   </tr><br></table>\n\n<ol>\n<li>double 占用8字节，64bits</li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>符号位</td><br>      <td width=\"150\">指数位</td><br>      <td width=\"300\">尾数部分</td><br>   </tr><br>   <tr><br>      <td>1 bits</td><br>      <td>11 bits</td><br>      <td>52 bits</td><br>   </tr><br></table>\n\n<h2 id=\"c题目\"><a href=\"#c题目\" class=\"headerlink\" title=\"c题目\"></a>c题目</h2><ul>\n<li><a href=\"#printf返回值\">printf返回值</a></li>\n<li><a href=\"#enum枚举类型\">enum枚举类型</a></li>\n<li><a href=\"#可变参数函数\">可变参数函数</a></li>\n</ul>\n<h3 id=\"printf返回值\"><a href=\"#printf返回值\" class=\"headerlink\" title=\"printf返回值\"></a>printf返回值</h3><pre><code class=\"c\">#include &lt;stdio.h&gt;\nint main() {\n  int i = 43;\n  printf(&quot;%d\\n&quot;, printf(&quot;%d&quot;, printf(&quot;%d&quot;, i)));\n  return 0;\n}\n</code></pre>\n<p>输出：4321<br>printf返回值是输出字符的个数（不包括字符串结尾\\x00）</p>\n<h3 id=\"enum枚举类型\"><a href=\"#enum枚举类型\" class=\"headerlink\" title=\"enum枚举类型\"></a>enum枚举类型</h3><pre><code class=\"c\">#include &lt;stdio.h&gt;\nint main() {\n  enum color{\n    RED,\n    BLUE,\n    GREEN = -2,\n    YELLOW,\n    PINK\n  };\n  printf(&quot;%d %d\\n&quot;, BLUE, PINK);\n  return 0;\n}\n</code></pre>\n<p>输出：1 0<br>enum默认是从0开始的，所以RED = 0， BLUE = 1， GREEN = -2， YELLOW = -1， PINK = 0；</p>\n<h3 id=\"可变参数函数\"><a href=\"#可变参数函数\" class=\"headerlink\" title=\"可变参数函数\"></a>可变参数函数</h3><pre><code class=\"c\">#include &quot;stdarg.h&quot;\n\nchar buf[512] = {0};\n\nint func(const char *fmt, ...)\n{\n  va_list args;\n  va_start(args, fmt);\n  vsprintf(buf, fmt, args);\n  va_end(args);\n}\n</code></pre>\n<h3 id=\"大小端区分\"><a href=\"#大小端区分\" class=\"headerlink\" title=\"大小端区分\"></a>大小端区分</h3><pre><code class=\"c\">union data {\n    int a;\n    char b;\n};\n\nstruct def {\n    union data mine;\n};\n\nstruct def endian;\n\nint main(int argc, char **argv)\n{\n    endian.mine.a = 0x12345678;\n    printf(&quot;%02X\\n&quot;, endian.mine.b);\n\n    return 0;\n}\n/*打印 78 说明是小端， 12 说明是大端 */\n</code></pre>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><pre><code class=\"c\">////////////////////////////////////////////\n//单链表的初始化，建立，插入，查找，删除。//\n//Author:Wang Yong                        //\n//Date: 2010.8.19                         //\n////////////////////////////////////////////\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\ntypedef int ElemType;\n////////////////////////////////////////////\n//定义结点类型\ntypedef struct Node\n{\n    ElemType data;              //单链表中的数据域\n    struct Node *next;          //单链表的指针域\n}Node,*LinkedList;\n////////////////////////////////////////////\n//单链表的初始化\nLinkedList LinkedListInit()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请结点空间\n    if(L == NULL)                       //判断是否有足够的内存空间\n        printf(&quot;申请内存空间失败/n&quot;);\n    L-&gt;next = NULL;                  //将next设置为NULL,初始长度为0的单链表\n}\n////////////////////////////////////////////\n//单链表的建立1，头插法建立单链表\nLinkedList LinkedListCreatH()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L-&gt;next = NULL;                      //初始化一个空链表\n\n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(&quot;%d&quot;,&amp;x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p-&gt;data = x;                     //结点数据域赋值\n        p-&gt;next = L-&gt;next;                    //将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL\n        L-&gt;next = p; \n    }\n    return L;\n}\n////////////////////////////////////////////\n//单链表的建立2，尾插法建立单链表\nLinkedList LinkedListCreatT()\n{\n    Node *L;\n    L = (Node *)malloc(sizeof(Node));   //申请头结点空间\n    L-&gt;next = NULL;                  //初始化一个空链表\n    Node *r;\n    r = L;                          //r始终指向终端结点，开始时指向头结点\n    ElemType x;                         //x为链表数据域中的数据\n    while(scanf(&quot;%d&quot;,&amp;x) != EOF)\n    {\n        Node *p;\n        p = (Node *)malloc(sizeof(Node));   //申请新的结点\n        p-&gt;data = x;                     //结点数据域赋值\n        r-&gt;next = p;                 //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL\n        r = p;\n    }\n    r-&gt;next = NULL;\n\n    return L;\n}\n////////////////////////////////////////////\n//单链表的插入，在链表的第i个位置插入x的元素\nLinkedList LinkedListInsert(LinkedList L,int i,ElemType x)\n{  \n    Node *pre;                      //pre为前驱结点\n    pre = L;\n    int tempi = 0;\n    for (tempi = 1; tempi &lt; i; tempi++)\n        pre = pre-&gt;next;                 //查找第i个位置的前驱结点\n    Node *p;                                //插入的结点为p\n    p = (Node *)malloc(sizeof(Node));\n    p-&gt;data = x;\n    p-&gt;next = pre-&gt;next;\n    pre-&gt;next = p;\n\n    return L;\n}\n////////////////////////////////////////////\n//单链表的删除，在链表中删除值为x的元素\nLinkedList LinkedListDelete(LinkedList L,ElemType x)\n{\n    Node *p,*pre;                   //pre为前驱结点，p为查找的结点。\n    p = L-&gt;next;\n    while(p-&gt;data != x)              //查找值为x的元素\n    {\n        pre = p;\n        p = p-&gt;next;\n    }\n    pre-&gt;next = p-&gt;next;          //删除操作，将其前驱next指向其后继。\n    free(p);\n    return L;\n}\n/////////////////////////////////////////////\nint main()\n{\n    LinkedList list,start;\n/*  printf(&quot;请输入单链表的数据：&quot;);\n    list = LinkedListCreatH();\n    for(start = list-&gt;next; start != NULL; start = start-&gt;next)\n        printf(&quot;%d &quot;,start-&gt;data);\n    printf(&quot;/n&quot;);\n*/  printf(&quot;请输入单链表的数据：&quot;);\n    list = LinkedListCreatT();\n    for(start = list-&gt;next; start != NULL; start = start-&gt;next)\n        printf(&quot;%d &quot;,start-&gt;data);\n    printf(&quot;/n&quot;);\n    int i;\n    ElemType x;\n    printf(&quot;请输入插入数据的位置：&quot;);\n    scanf(&quot;%d&quot;,&amp;i);\n    printf(&quot;请输入插入数据的值：&quot;);\n    scanf(&quot;%d&quot;,&amp;x);\n    LinkedListInsert(list,i,x);\n    for(start = list-&gt;next; start != NULL; start = start-&gt;next)\n        printf(&quot;%d &quot;,start-&gt;data);\n    printf(&quot;/n&quot;);\n    printf(&quot;请输入要删除的元素的值：&quot;);\n    scanf(&quot;%d&quot;,&amp;x);\n    LinkedListDelete(list,x); \n    for(start = list-&gt;next; start != NULL; start = start-&gt;next)\n        printf(&quot;%d &quot;,start-&gt;data);\n    printf(&quot;/n&quot;);\n\n    return 0;\n}\n</code></pre>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><ul>\n<li><a href=\"#选择排序\">选择排序</a></li>\n<li><a href=\"#插入排序\">插入排序</a></li>\n<li><a href=\"#希尔排序\">希尔排序</a></li>\n<li><a href=\"#冒泡排序\">冒泡排序</a></li>\n<li><a href=\"#快速排序\">快速排序</a></li>\n</ul>\n<p>排序算法有：</p>\n<p><table><br>    <tr><br>      <td>选择排序</td><br>      <td>快速排序</td><br>      <td>希尔排序</td><br>      <td>冒泡排序</td><br>      <td>插入排序</td><br>      <td>堆排序</td><br>      <td>归并排序</td><br>    </tr><br></table><br>排序算法比较：</p>\n<p><img src=\"../res/sort/sort.png\" alt=\"排序算法比较\"></p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(n2) 最好: O(n2) 最坏:O(n2)\n</code></pre><h4 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(1)\n</code></pre><h4 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕。<h4 id=\"动图演示\"><a href=\"#动图演示\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><img src=\"../res/sort/selectionSort.gif\" alt=\"动图演示\"><pre><code class=\"c\">/* 直接选择排序 */\nvoid selection_sort(int n)\n{\n for (int i = 0; i &lt; n - 1; i++)\n {\n     int min = i;\n     for (int j = i + 1; j &lt; n; j++)\n     {\n         if (x[j] &lt; x[min])\n         {\n             min = j;\n         }\n     }\n     if (min != i)\n     {\n         swap(x,i,min);\n     }\n }\n}\n</code></pre>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。<h4 id=\"时间复杂度-1\"><a href=\"#时间复杂度-1\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4> 平均：O(n2) 最好：O(n) 最坏：O(n2)<h4 id=\"空间复杂度-1\"><a href=\"#空间复杂度-1\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4> O(1)<h4 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4></li>\n<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>\n<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<h4 id=\"动图演示-1\"><a href=\"#动图演示-1\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><img src=\"res/sort/insertionSort.gif\" alt=\"动图演示\"><pre><code class=\"c\">/* 直接插入排序 */\nvoid insertion_sort(int n)\n{\n for(int i = 1; i &lt; n; i++)\n {\n     int t = x[i];\n     int j;\n     for (j = i; j &gt; 0 &amp;&amp; x[j-1] &gt; t ; j--)\n     {\n         x[j] = x[j - 1];\n     }\n     x[j] = t;\n }\n}\n</code></pre>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<ul>\n<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>\n<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。<h4 id=\"时间复杂度-2\"><a href=\"#时间复杂度-2\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4>平均：O(n1.5) 最好：O(n) 最坏O(n2)<h4 id=\"空间复杂度-2\"><a href=\"#空间复杂度-2\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4>O(1) <h4 id=\"算法步骤-2\"><a href=\"#算法步骤-2\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4></li>\n</ul>\n</li>\n<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<pre><code class=\"c\">/* 希尔排序 */\nvoid shell_sort(int n)\n{\n for (int inc = n/3; inc &gt;= 1; inc /= 3 )\n {\n     for (int i = inc; i &lt; n; i++)\n     {\n         int t = x[i];\n         int j;\n         for (j = i; j &gt;= inc &amp;&amp; x[j - inc] &gt; t ; j -= inc)\n         {\n             x[j] = x[j - inc];\n         }\n         x[j] = t;\n     }\n }\n}\n</code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3></li>\n</ol>\n<h4 id=\"时间复杂度-3\"><a href=\"#时间复杂度-3\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(n2) 最好: O(n) 最坏：O(n2)\n</code></pre><h4 id=\"空间复杂度-3\"><a href=\"#空间复杂度-3\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(1)\n</code></pre><h4 id=\"算法步骤-3\"><a href=\"#算法步骤-3\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>动图演示<br><img src=\"res/sort/bubbleSort.gif\" alt=\"动图演示\"><pre><code class=\"c\">/* 冒泡排序 */\nvoid bubble_sort(int n)\n{\n bool change = true;\n for (int i = n-1; i &gt;= 1 &amp;&amp; change; i--)\n {\n     change = false;\n     for (int j = 0; j &lt; i; j++)\n     {\n         if(x[j] &gt; x[j + 1])\n         {\n             swap(x, j, j + 1);\n             change = true;\n         }\n     }\n }\n}\n</code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li>\n</ol>\n<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>\n<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>\n<blockquote>\n<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>\n</blockquote>\n<h4 id=\"时间复杂度-4\"><a href=\"#时间复杂度-4\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><pre><code>平均: O(nlogn) 最好: O(nlogn) 最坏:O(n2)\n</code></pre><h4 id=\"空间复杂度-4\"><a href=\"#空间复杂度-4\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h4><pre><code>O(nlogn)   用于方法栈\n</code></pre><h4 id=\"算法步骤-4\"><a href=\"#算法步骤-4\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>\n</ol>\n<h4 id=\"动图演示-2\"><a href=\"#动图演示-2\" class=\"headerlink\" title=\"动图演示\"></a>动图演示</h4><p><img src=\"res/sort/quickSort.gif\" alt=\"动图演示\"></p>\n<pre><code class=\"c\">/* 快速排序 */\nvoid quick_sort(int l, int u)\n{\n    if (l &gt;= u)\n        return;\n    int m = l;\n    for (int i = l+1; i&lt;= u; i++)\n    {\n        if(x[i] &lt; x[l])\n            swap(x, ++m, i);\n    }\n    swap(x, l, m);\n    quick_sort(l, m-1);\n    quick_sort(m+1, u);\n}\n</code></pre>\n<h2 id=\"hash算法\"><a href=\"#hash算法\" class=\"headerlink\" title=\"hash算法\"></a>hash算法</h2><h3 id=\"hash构造方法\"><a href=\"#hash构造方法\" class=\"headerlink\" title=\"hash构造方法\"></a>hash构造方法</h3><ol>\n<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数） </li>\n<li>数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 </li>\n<li>平方取中法：取关键字平方后的中间几位作为散列地址。 </li>\n<li>折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 </li>\n<li>随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 </li>\n<li>除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。<h3 id=\"hash冲突及解决\"><a href=\"#hash冲突及解决\" class=\"headerlink\" title=\"hash冲突及解决\"></a>hash冲突及解决</h3><h4 id=\"冲突原因：\"><a href=\"#冲突原因：\" class=\"headerlink\" title=\"冲突原因：\"></a>冲突原因：</h4></li>\n<li>与散列函数有关，一个好的散列函数的值应尽可能平均分布。 </li>\n<li>与解决冲突的哈希冲突函数有关。 </li>\n<li>与负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。 <h4 id=\"解决冲突的办法\"><a href=\"#解决冲突的办法\" class=\"headerlink\" title=\"解决冲突的办法\"></a>解决冲突的办法</h4></li>\n</ol>\n<ul>\n<li>开放定址法：线性探查法、平方探查法、伪随机序列法、双哈希函数法。 </li>\n<li><p>拉链法：把所有同义词，即hash值相同的记录，用单链表连接起来。</p>\n<h4 id=\"常用的hash函数\"><a href=\"#常用的hash函数\" class=\"headerlink\" title=\"常用的hash函数\"></a>常用的hash函数</h4><p><code>`</code>c<br>unsigned int RSHash(char* str, unsigned int len)<br>{<br>  unsigned int b   = 378551;<br>  unsigned int a   = 63689;<br>  unsigned int hash = 0;<br>  unsigned int i   = 0;</p>\n<p>  for(i = 0; i &lt; len; str++, i++)<br>  {</p>\n<pre><code>  hash = hash * a + (*str);\n  a    = a * b;\n</code></pre><p>  }</p>\n<p>  return hash;<br>}<br>/<em> End Of RS Hash Function </em>/</p>\n</li>\n</ul>\n<p>unsigned int JSHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 1315423911;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash ^= ((hash &lt;&lt; 5) + (*str) + (hash &gt;&gt; 2));\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of JS Hash Function </em>/</p>\n<p>unsigned int ELFHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 0;<br>    unsigned int x     = 0;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash = (hash &lt;&lt; 4) + (*str);\n    if((x = hash &amp; 0xF0000000L) != 0)\n    {\n        hash ^= (x &gt;&gt; 24);\n    }\n    hash &amp;= ~x;\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of ELF Hash Function </em>/</p>\n<p>unsigned int DJBHash(char* str, unsigned int len)<br>{<br>    unsigned int hash = 5381;<br>    unsigned int i     = 0;</p>\n<pre><code>for(i = 0; i &lt; len; str++, i++)\n{\n    hash = ((hash &lt;&lt; 5) + hash) + (*str);\n}\n\nreturn hash;\n</code></pre><p>}<br>/<em> End Of DJB Hash Function </em>/<br><code>`</code></p>\n<h2 id=\"javascript数据类型\"><a href=\"#javascript数据类型\" class=\"headerlink\" title=\"javascript数据类型\"></a>javascript数据类型</h2><p>字符串 数字 布尔 对象 数组 undefined null</p>\n<blockquote>\n<p>js只有一种数字类型<br>undefined：当声明的变量没有初始化的话，那这个变量的值就是undefined<br>null表示尚未存在的对象。</p>\n</blockquote>\n"},{"title":"嵌入式笔记：gpu知识点","_content":"嵌入式笔记：gpu知识点\n\n## vivante图芯技术有限公司\n\n## 硬件抽象层\n    Hardware Abstraction Layer (HAL)\n## Alpha Blending\n    是按照“Alpha”混合向量的值来混合源像素和目标像素的一种图像处理技术。\n## android SurfaceFlinger\n    SurfaceFlinger服务负责绘制Android应用程序的UI\n\n## android专有驱动\n\n|驱动|说明|\n|-|-|\n|`Android Ashmem`|匿名共享内存； 为用户空间程序提供分配内存的机制|\n|`Android Logger`|轻量级的LOG（日志）驱动|\n|`Android Binder`|基于 OpenBinder 框架的一个驱动|\n|`Android Power Management`|电源管理模块|\n|`Low Memory Killer`|低内存管理器|\n|`Android PMEM`|物理内存驱动|\n|`USB Gadget`|USB 驱动（基于 gaeget 框架）|\n|`Ram Console`|用于调试写入日志信息的设备|\n|`Time Device`|定时控制设备|\n|`Android Alarm`|硬件时钟|\n\n## android 上的设备驱动\n\n|驱动|说明|\n|-|-|\n|`Framebuff`|显示驱动|\n|`surfaceflinger`|显示驱动|\n|`gralloc`|显示驱动|\n|`Event`|输入设备驱动|\n|`ALSA`|音频驱动|\n|`OSS`|音频驱动|\n|`v412`|摄像头视频驱动|\n|`MTD`|驱动|\n||蓝牙驱动|\n|`WLAN`|wifi驱动|\n\n## android 图形名词\n\n|名词|说明|\n|-|-|\n|`OpenGL`|开放图形库（open graphics library）用于生成2D 3D图像|\n|`OpenGL ES`|（OpenGL for Embedded Systems）是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计|\n|`OpenVG`|（Open Vector Graphics）2D矢量图形处理标准函式库|\n|`OpenCL`|（Open Computing Language）开放运算语言|\n|`DirectFB`|（Direct Frame Buffer），提供硬体图形加速库|\n|`GDI`|（Graphics Device Interface），图形设备接口，负责系统与绘图程序之间的信息交换|\n|`DirectDraw`|DirectX中的关于视频输入输出的基本部分，使用DirectDraw可以方便地编制出高效的视频处理程序，只要用户的硬件支持DirectDraw，就能保证你的代码可以处理它们。|\n|`Skia`|Android中的2D图形库|\n|`libagl`|Android中通过软件方法实现的一套OpenGL动态库|\n|`libhgl`|为区别libagl，自定义的一种叫法。特指GPU厂商提供的硬件实现的OpenGL|\n|`render`|特指使用OpenGL动态库进行3D渲染|\n|`copybit`|Android使用2D引擎来加速图形操作（主要是Surface之间的composition操作）的一种技术，对应着一个或几个动态库。|\n|`pmem`|Android特有驱动，从linux内核中reserve物理连续内存，可以为2d、3d引擎、vpu等设备分配物理连续内存。|\n\n\n## 使用GPU硬件加速需要做的工作\n* Linux内核方面：\n\t* 添加GPU驱动支持，以模块方式编译GPU驱动，Android启动时加载内核模块。\n\t* 添加PMEM支持，预留内存供GPU使用\n* Android方面：\n\t* 添加copybit HAL\n\t* 修改gralloc gralloc负责显存等的分配，以及对framebuffer操作\n\t* 修改libagl\n\t* 修改surfaceflinger\n## framebuffer\n    framebuffer字符设备\n\n设备位于`/dev/graphics/fb*`,主设备号为29\n相关代码：\n```sh\ninclude/linux/fb.h\ndriver/video/fbmem.c\nfbmem.c\t# 提供用户接口\nxxxfb.c\t# 提供硬件操作接口\n```\n用户操作：\n|函数|说明|\n|-|-|\n|`ioctl()`|获取/设置信息|\n|`mmap()`|映射内存|\n\n\n\n\n\n\n\n\n","source":"_posts/gpu.md","raw":"---\ntitle: 嵌入式笔记：gpu知识点\n---\n嵌入式笔记：gpu知识点\n\n## vivante图芯技术有限公司\n\n## 硬件抽象层\n    Hardware Abstraction Layer (HAL)\n## Alpha Blending\n    是按照“Alpha”混合向量的值来混合源像素和目标像素的一种图像处理技术。\n## android SurfaceFlinger\n    SurfaceFlinger服务负责绘制Android应用程序的UI\n\n## android专有驱动\n\n|驱动|说明|\n|-|-|\n|`Android Ashmem`|匿名共享内存； 为用户空间程序提供分配内存的机制|\n|`Android Logger`|轻量级的LOG（日志）驱动|\n|`Android Binder`|基于 OpenBinder 框架的一个驱动|\n|`Android Power Management`|电源管理模块|\n|`Low Memory Killer`|低内存管理器|\n|`Android PMEM`|物理内存驱动|\n|`USB Gadget`|USB 驱动（基于 gaeget 框架）|\n|`Ram Console`|用于调试写入日志信息的设备|\n|`Time Device`|定时控制设备|\n|`Android Alarm`|硬件时钟|\n\n## android 上的设备驱动\n\n|驱动|说明|\n|-|-|\n|`Framebuff`|显示驱动|\n|`surfaceflinger`|显示驱动|\n|`gralloc`|显示驱动|\n|`Event`|输入设备驱动|\n|`ALSA`|音频驱动|\n|`OSS`|音频驱动|\n|`v412`|摄像头视频驱动|\n|`MTD`|驱动|\n||蓝牙驱动|\n|`WLAN`|wifi驱动|\n\n## android 图形名词\n\n|名词|说明|\n|-|-|\n|`OpenGL`|开放图形库（open graphics library）用于生成2D 3D图像|\n|`OpenGL ES`|（OpenGL for Embedded Systems）是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计|\n|`OpenVG`|（Open Vector Graphics）2D矢量图形处理标准函式库|\n|`OpenCL`|（Open Computing Language）开放运算语言|\n|`DirectFB`|（Direct Frame Buffer），提供硬体图形加速库|\n|`GDI`|（Graphics Device Interface），图形设备接口，负责系统与绘图程序之间的信息交换|\n|`DirectDraw`|DirectX中的关于视频输入输出的基本部分，使用DirectDraw可以方便地编制出高效的视频处理程序，只要用户的硬件支持DirectDraw，就能保证你的代码可以处理它们。|\n|`Skia`|Android中的2D图形库|\n|`libagl`|Android中通过软件方法实现的一套OpenGL动态库|\n|`libhgl`|为区别libagl，自定义的一种叫法。特指GPU厂商提供的硬件实现的OpenGL|\n|`render`|特指使用OpenGL动态库进行3D渲染|\n|`copybit`|Android使用2D引擎来加速图形操作（主要是Surface之间的composition操作）的一种技术，对应着一个或几个动态库。|\n|`pmem`|Android特有驱动，从linux内核中reserve物理连续内存，可以为2d、3d引擎、vpu等设备分配物理连续内存。|\n\n\n## 使用GPU硬件加速需要做的工作\n* Linux内核方面：\n\t* 添加GPU驱动支持，以模块方式编译GPU驱动，Android启动时加载内核模块。\n\t* 添加PMEM支持，预留内存供GPU使用\n* Android方面：\n\t* 添加copybit HAL\n\t* 修改gralloc gralloc负责显存等的分配，以及对framebuffer操作\n\t* 修改libagl\n\t* 修改surfaceflinger\n## framebuffer\n    framebuffer字符设备\n\n设备位于`/dev/graphics/fb*`,主设备号为29\n相关代码：\n```sh\ninclude/linux/fb.h\ndriver/video/fbmem.c\nfbmem.c\t# 提供用户接口\nxxxfb.c\t# 提供硬件操作接口\n```\n用户操作：\n|函数|说明|\n|-|-|\n|`ioctl()`|获取/设置信息|\n|`mmap()`|映射内存|\n\n\n\n\n\n\n\n\n","slug":"gpu","published":1,"date":"2018-02-28T01:20:44.969Z","updated":"2018-02-28T01:13:02.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhba00059vf7b106wdcd","content":"<p>嵌入式笔记：gpu知识点</p>\n<h2 id=\"vivante图芯技术有限公司\"><a href=\"#vivante图芯技术有限公司\" class=\"headerlink\" title=\"vivante图芯技术有限公司\"></a>vivante图芯技术有限公司</h2><h2 id=\"硬件抽象层\"><a href=\"#硬件抽象层\" class=\"headerlink\" title=\"硬件抽象层\"></a>硬件抽象层</h2><pre><code>Hardware Abstraction Layer (HAL)\n</code></pre><h2 id=\"Alpha-Blending\"><a href=\"#Alpha-Blending\" class=\"headerlink\" title=\"Alpha Blending\"></a>Alpha Blending</h2><pre><code>是按照“Alpha”混合向量的值来混合源像素和目标像素的一种图像处理技术。\n</code></pre><h2 id=\"android-SurfaceFlinger\"><a href=\"#android-SurfaceFlinger\" class=\"headerlink\" title=\"android SurfaceFlinger\"></a>android SurfaceFlinger</h2><pre><code>SurfaceFlinger服务负责绘制Android应用程序的UI\n</code></pre><h2 id=\"android专有驱动\"><a href=\"#android专有驱动\" class=\"headerlink\" title=\"android专有驱动\"></a>android专有驱动</h2><table>\n<thead>\n<tr>\n<th>驱动</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Android Ashmem</code></td>\n<td>匿名共享内存； 为用户空间程序提供分配内存的机制</td>\n</tr>\n<tr>\n<td><code>Android Logger</code></td>\n<td>轻量级的LOG（日志）驱动</td>\n</tr>\n<tr>\n<td><code>Android Binder</code></td>\n<td>基于 OpenBinder 框架的一个驱动</td>\n</tr>\n<tr>\n<td><code>Android Power Management</code></td>\n<td>电源管理模块</td>\n</tr>\n<tr>\n<td><code>Low Memory Killer</code></td>\n<td>低内存管理器</td>\n</tr>\n<tr>\n<td><code>Android PMEM</code></td>\n<td>物理内存驱动</td>\n</tr>\n<tr>\n<td><code>USB Gadget</code></td>\n<td>USB 驱动（基于 gaeget 框架）</td>\n</tr>\n<tr>\n<td><code>Ram Console</code></td>\n<td>用于调试写入日志信息的设备</td>\n</tr>\n<tr>\n<td><code>Time Device</code></td>\n<td>定时控制设备</td>\n</tr>\n<tr>\n<td><code>Android Alarm</code></td>\n<td>硬件时钟</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"android-上的设备驱动\"><a href=\"#android-上的设备驱动\" class=\"headerlink\" title=\"android 上的设备驱动\"></a>android 上的设备驱动</h2><table>\n<thead>\n<tr>\n<th>驱动</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Framebuff</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>surfaceflinger</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>gralloc</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>Event</code></td>\n<td>输入设备驱动</td>\n</tr>\n<tr>\n<td><code>ALSA</code></td>\n<td>音频驱动</td>\n</tr>\n<tr>\n<td><code>OSS</code></td>\n<td>音频驱动</td>\n</tr>\n<tr>\n<td><code>v412</code></td>\n<td>摄像头视频驱动</td>\n</tr>\n<tr>\n<td><code>MTD</code></td>\n<td>驱动</td>\n</tr>\n<tr>\n<td></td>\n<td>蓝牙驱动</td>\n</tr>\n<tr>\n<td><code>WLAN</code></td>\n<td>wifi驱动</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"android-图形名词\"><a href=\"#android-图形名词\" class=\"headerlink\" title=\"android 图形名词\"></a>android 图形名词</h2><table>\n<thead>\n<tr>\n<th>名词</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>OpenGL</code></td>\n<td>开放图形库（open graphics library）用于生成2D 3D图像</td>\n</tr>\n<tr>\n<td><code>OpenGL ES</code></td>\n<td>（OpenGL for Embedded Systems）是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计</td>\n</tr>\n<tr>\n<td><code>OpenVG</code></td>\n<td>（Open Vector Graphics）2D矢量图形处理标准函式库</td>\n</tr>\n<tr>\n<td><code>OpenCL</code></td>\n<td>（Open Computing Language）开放运算语言</td>\n</tr>\n<tr>\n<td><code>DirectFB</code></td>\n<td>（Direct Frame Buffer），提供硬体图形加速库</td>\n</tr>\n<tr>\n<td><code>GDI</code></td>\n<td>（Graphics Device Interface），图形设备接口，负责系统与绘图程序之间的信息交换</td>\n</tr>\n<tr>\n<td><code>DirectDraw</code></td>\n<td>DirectX中的关于视频输入输出的基本部分，使用DirectDraw可以方便地编制出高效的视频处理程序，只要用户的硬件支持DirectDraw，就能保证你的代码可以处理它们。</td>\n</tr>\n<tr>\n<td><code>Skia</code></td>\n<td>Android中的2D图形库</td>\n</tr>\n<tr>\n<td><code>libagl</code></td>\n<td>Android中通过软件方法实现的一套OpenGL动态库</td>\n</tr>\n<tr>\n<td><code>libhgl</code></td>\n<td>为区别libagl，自定义的一种叫法。特指GPU厂商提供的硬件实现的OpenGL</td>\n</tr>\n<tr>\n<td><code>render</code></td>\n<td>特指使用OpenGL动态库进行3D渲染</td>\n</tr>\n<tr>\n<td><code>copybit</code></td>\n<td>Android使用2D引擎来加速图形操作（主要是Surface之间的composition操作）的一种技术，对应着一个或几个动态库。</td>\n</tr>\n<tr>\n<td><code>pmem</code></td>\n<td>Android特有驱动，从linux内核中reserve物理连续内存，可以为2d、3d引擎、vpu等设备分配物理连续内存。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用GPU硬件加速需要做的工作\"><a href=\"#使用GPU硬件加速需要做的工作\" class=\"headerlink\" title=\"使用GPU硬件加速需要做的工作\"></a>使用GPU硬件加速需要做的工作</h2><ul>\n<li>Linux内核方面：<ul>\n<li>添加GPU驱动支持，以模块方式编译GPU驱动，Android启动时加载内核模块。</li>\n<li>添加PMEM支持，预留内存供GPU使用</li>\n</ul>\n</li>\n<li>Android方面：<ul>\n<li>添加copybit HAL</li>\n<li>修改gralloc gralloc负责显存等的分配，以及对framebuffer操作</li>\n<li>修改libagl</li>\n<li>修改surfaceflinger<h2 id=\"framebuffer\"><a href=\"#framebuffer\" class=\"headerlink\" title=\"framebuffer\"></a>framebuffer</h2>framebuffer字符设备</li>\n</ul>\n</li>\n</ul>\n<p>设备位于<code>/dev/graphics/fb*</code>,主设备号为29<br>相关代码：</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">include/linux/fb.h\ndriver/video/fbmem.c\nfbmem.c    # 提供用户接口\nxxxfb.c    # 提供硬件操作接口\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>用户操作：<br>|函数|说明|<br>|-|-|<br>|<code>ioctl()</code>|获取/设置信息|<br>|<code>mmap()</code>|映射内存|</p>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：gpu知识点</p>\n<h2 id=\"vivante图芯技术有限公司\"><a href=\"#vivante图芯技术有限公司\" class=\"headerlink\" title=\"vivante图芯技术有限公司\"></a>vivante图芯技术有限公司</h2><h2 id=\"硬件抽象层\"><a href=\"#硬件抽象层\" class=\"headerlink\" title=\"硬件抽象层\"></a>硬件抽象层</h2><pre><code>Hardware Abstraction Layer (HAL)\n</code></pre><h2 id=\"Alpha-Blending\"><a href=\"#Alpha-Blending\" class=\"headerlink\" title=\"Alpha Blending\"></a>Alpha Blending</h2><pre><code>是按照“Alpha”混合向量的值来混合源像素和目标像素的一种图像处理技术。\n</code></pre><h2 id=\"android-SurfaceFlinger\"><a href=\"#android-SurfaceFlinger\" class=\"headerlink\" title=\"android SurfaceFlinger\"></a>android SurfaceFlinger</h2><pre><code>SurfaceFlinger服务负责绘制Android应用程序的UI\n</code></pre><h2 id=\"android专有驱动\"><a href=\"#android专有驱动\" class=\"headerlink\" title=\"android专有驱动\"></a>android专有驱动</h2><table>\n<thead>\n<tr>\n<th>驱动</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Android Ashmem</code></td>\n<td>匿名共享内存； 为用户空间程序提供分配内存的机制</td>\n</tr>\n<tr>\n<td><code>Android Logger</code></td>\n<td>轻量级的LOG（日志）驱动</td>\n</tr>\n<tr>\n<td><code>Android Binder</code></td>\n<td>基于 OpenBinder 框架的一个驱动</td>\n</tr>\n<tr>\n<td><code>Android Power Management</code></td>\n<td>电源管理模块</td>\n</tr>\n<tr>\n<td><code>Low Memory Killer</code></td>\n<td>低内存管理器</td>\n</tr>\n<tr>\n<td><code>Android PMEM</code></td>\n<td>物理内存驱动</td>\n</tr>\n<tr>\n<td><code>USB Gadget</code></td>\n<td>USB 驱动（基于 gaeget 框架）</td>\n</tr>\n<tr>\n<td><code>Ram Console</code></td>\n<td>用于调试写入日志信息的设备</td>\n</tr>\n<tr>\n<td><code>Time Device</code></td>\n<td>定时控制设备</td>\n</tr>\n<tr>\n<td><code>Android Alarm</code></td>\n<td>硬件时钟</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"android-上的设备驱动\"><a href=\"#android-上的设备驱动\" class=\"headerlink\" title=\"android 上的设备驱动\"></a>android 上的设备驱动</h2><table>\n<thead>\n<tr>\n<th>驱动</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Framebuff</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>surfaceflinger</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>gralloc</code></td>\n<td>显示驱动</td>\n</tr>\n<tr>\n<td><code>Event</code></td>\n<td>输入设备驱动</td>\n</tr>\n<tr>\n<td><code>ALSA</code></td>\n<td>音频驱动</td>\n</tr>\n<tr>\n<td><code>OSS</code></td>\n<td>音频驱动</td>\n</tr>\n<tr>\n<td><code>v412</code></td>\n<td>摄像头视频驱动</td>\n</tr>\n<tr>\n<td><code>MTD</code></td>\n<td>驱动</td>\n</tr>\n<tr>\n<td></td>\n<td>蓝牙驱动</td>\n</tr>\n<tr>\n<td><code>WLAN</code></td>\n<td>wifi驱动</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"android-图形名词\"><a href=\"#android-图形名词\" class=\"headerlink\" title=\"android 图形名词\"></a>android 图形名词</h2><table>\n<thead>\n<tr>\n<th>名词</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>OpenGL</code></td>\n<td>开放图形库（open graphics library）用于生成2D 3D图像</td>\n</tr>\n<tr>\n<td><code>OpenGL ES</code></td>\n<td>（OpenGL for Embedded Systems）是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计</td>\n</tr>\n<tr>\n<td><code>OpenVG</code></td>\n<td>（Open Vector Graphics）2D矢量图形处理标准函式库</td>\n</tr>\n<tr>\n<td><code>OpenCL</code></td>\n<td>（Open Computing Language）开放运算语言</td>\n</tr>\n<tr>\n<td><code>DirectFB</code></td>\n<td>（Direct Frame Buffer），提供硬体图形加速库</td>\n</tr>\n<tr>\n<td><code>GDI</code></td>\n<td>（Graphics Device Interface），图形设备接口，负责系统与绘图程序之间的信息交换</td>\n</tr>\n<tr>\n<td><code>DirectDraw</code></td>\n<td>DirectX中的关于视频输入输出的基本部分，使用DirectDraw可以方便地编制出高效的视频处理程序，只要用户的硬件支持DirectDraw，就能保证你的代码可以处理它们。</td>\n</tr>\n<tr>\n<td><code>Skia</code></td>\n<td>Android中的2D图形库</td>\n</tr>\n<tr>\n<td><code>libagl</code></td>\n<td>Android中通过软件方法实现的一套OpenGL动态库</td>\n</tr>\n<tr>\n<td><code>libhgl</code></td>\n<td>为区别libagl，自定义的一种叫法。特指GPU厂商提供的硬件实现的OpenGL</td>\n</tr>\n<tr>\n<td><code>render</code></td>\n<td>特指使用OpenGL动态库进行3D渲染</td>\n</tr>\n<tr>\n<td><code>copybit</code></td>\n<td>Android使用2D引擎来加速图形操作（主要是Surface之间的composition操作）的一种技术，对应着一个或几个动态库。</td>\n</tr>\n<tr>\n<td><code>pmem</code></td>\n<td>Android特有驱动，从linux内核中reserve物理连续内存，可以为2d、3d引擎、vpu等设备分配物理连续内存。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"使用GPU硬件加速需要做的工作\"><a href=\"#使用GPU硬件加速需要做的工作\" class=\"headerlink\" title=\"使用GPU硬件加速需要做的工作\"></a>使用GPU硬件加速需要做的工作</h2><ul>\n<li>Linux内核方面：<ul>\n<li>添加GPU驱动支持，以模块方式编译GPU驱动，Android启动时加载内核模块。</li>\n<li>添加PMEM支持，预留内存供GPU使用</li>\n</ul>\n</li>\n<li>Android方面：<ul>\n<li>添加copybit HAL</li>\n<li>修改gralloc gralloc负责显存等的分配，以及对framebuffer操作</li>\n<li>修改libagl</li>\n<li>修改surfaceflinger<h2 id=\"framebuffer\"><a href=\"#framebuffer\" class=\"headerlink\" title=\"framebuffer\"></a>framebuffer</h2>framebuffer字符设备</li>\n</ul>\n</li>\n</ul>\n<p>设备位于<code>/dev/graphics/fb*</code>,主设备号为29<br>相关代码：</p>\n<pre><code class=\"sh\">include/linux/fb.h\ndriver/video/fbmem.c\nfbmem.c    # 提供用户接口\nxxxfb.c    # 提供硬件操作接口\n</code></pre>\n<p>用户操作：<br>|函数|说明|<br>|-|-|<br>|<code>ioctl()</code>|获取/设置信息|<br>|<code>mmap()</code>|映射内存|</p>\n"},{"title":"嵌入式笔记：shell脚本","_content":"嵌入式笔记：shell脚本\n\n# 目录\n\n## shell种类\n<table>\n  <tr>\n  <td>bash</td>\n  <td>csh</td>\n  <td>ksh</td>\n  <td>zsh</td>\n  </tr>\n</table>\n\n## 基本语法\n### 定义和使用变量\n```sh\n#!/bin/sh\na=\" hello world\"\necho $a\necho 'a is xiaxaiwen${a}'\n```\n### if else\n```sh\nif ....; then \n　 .... \nelif ....; then \n　 .... \nelse \n　 .... \nfi \n```\n### [] 条件测试\n> [] 中前后一定要加空格\n\n### shell常用命令\n|                           |                              |\n|---------------------------|------------------------------|\n|`echo`                     |将文字内容打印在屏幕上 |\n|`ls`                       |文件列表 |\n|`wc`                       |计算文件行数(-l),单词数(-w),字符数(-c) |\n|`cp`                       | 文件拷贝 |\n|`mv`                       | 重命名文件或移动文件 |\n|`rm`                       | 删除文件 |\n|`grep`                     | 在文件内搜索字符串比如：grep 'searchstring' file.txt |\n|`cut -b`                   |  指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令 |\n|`cat`                      | 输出文件内容到标准输出设备（屏幕）上 |\n|`file`                     | 得到文件类型 |\n|`read var`                 | 提示用户输入，并将输入赋值给变量 |\n|`sort`                     | 对file.txt文件中的行进行排序 |\n|`uniq`                     | 删除文本文件中出现的行列比如： sort file.txt | uniq |\n|`expr`                     | 进行数学运算Example: add 2 and 3expr 2 \"+\" 3 |\n|`find`                     | 搜索文件比如：根据文件名搜索find . -name filename -print |\n|`tee`                      | 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile |\n|`basename`                 | 返回不包含路径的文件名比如： basename /bin/tux将返回 tux |\n|`dirname`                  | 返回文件所在路径比如：dirname /bin/tux将返回 /bin |\n|`head`                     | 打印文本文件开头几行 |\n|`tail`                     | 打印文本文件末尾几行 |\n|`sed`                      | Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' > newtext.file |\n|awk                        | awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '{print $1 \",\" $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA |\n### shell变量类型\n> shell变量名只能包含数字、字母和下划线\n#### 局部变量\n在脚本或命令中定义，仅在当前shell实例中有效\n#### 环境变量\n\n#### shell变量特殊变量\n\n|特殊变量列表|  说明 |\n|:-:|--------|\n|`$0`|当前脚本的文件名|\n|`$n`|传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是`$1`，第二个参数是`$2`。|\n|`$#`|传递给脚本或函数的参数个数。|\n|`$*`|传递给脚本或函数的所有参数。|\n|`$@`|传递给脚本或函数的所有参数。被双引号(\" \")包含时，与 `$*` 稍有不同，下面将会讲到。|\n|`$?`|上个命令的退出状态，或函数的返回值。|\n|`$$`|当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。|\n\n### 条件语句\nfor\nwhile\nif\n### 特殊符号\n`!!`  表示执行上一条指令\n`!n`  表示执行命令历史中第n条指令\n`*`   匹配零个或多个字符\n`?`   匹配一个字符\n`env` 系统预设的环境变量\n`$?`  上次执行命令或函数的返回值\n`$*`  传递给脚本或函数的所有参数\n`$@`  传递给脚本或函数的所有参数。被双引号(`\" \"`)包含时，与 `$*` 稍有不同，下面将会讲到。\n`$$`  脚本运行的当前进程id\n`$!`  最后执行的后台命令的PID\n`$#`  传递给shell脚本的参数个数\n`反引号` 设置系统的命令输出到变量\n`echo *`  以串行形式，打印当前整个目录\n### 数值比较运算符\n-eq 相等\n-ne 不等\n-gt 大于\n-lt 小于\n-le 小于等于\n-ge 大于等于\n### 字符串比较运算符\n=   相等\n!=  不等\n-z  空串\n-n  非空串\n### 文件比较运算符\n-d  目录\n-f  文件\n-L  链接\n-r  可读\n-w  可写\n-x  可执行\n-s  文件非空\n### 逻辑运算符\n-a  逻辑与\n-o  逻辑或\n!   逻辑否\n\n\n### 替换运算符\n1. `${var_name:-def_Val}`\n    如果变量var_name存在且为非null，返回该变量的值，否则返回默认值def-Val\n    注意var_name与:之间没有空格，:与-之间可以有空格。主要用途，如果变量未定义，则用默认值.\n2. `${var_name:=val}`\n    如果变量var_name存在且为非null，返回该变量的值，否则，把val的值赋给变量var_name，并返回var_name的值val\n    注意var_name与:之间没有空格，:与=之间也不能有空格。\n3. `${var_name:?message}`\n    如果变量var_name存在且为非null，返回该变量的值，否则返回该变量的名字var_name:提示信息meesage，并退出当前命令或脚本\n    注意var_name与:之间没有空格，:与?之间也不能有空格。\n4. `${var_name:+val}`\n    如果变量var_name存在且为非null，返回val，否则返回null\n    注意var_name与`:`之间没有空格，`:`与`+`之间也不能有空格。\n5. \n```sh\n${#val_name}\n```\n    返回变量长度\n6. `$*` `$@`\n    显示所有命令行参数\n7. `$0`\n    脚本程序名称\n8.  `$n`\n    第n个参数\n9.  `$(())`\n    算术运算操作\n10. `$((var1 opr var2))`\n  例如:`$((5+1))` 只能是`+ - * / ()运算符`，并且只能做整数运算\n11. `$()`\n    命令代换 类似于 `反引号` 例如：`echo $(date)`\n\n### 循环语句用法\n```sh\n    for i in $path\n    for i in `seq 1 9`\n    for i in $(seq 1 9)\n    for i in {a..z}\n    for (( i=1; i<=10; i++ ))\n    while [ $cnt -ge  0 ]\n    until [ $cnt -lt 0 ]\n```\n### case语句\n```sh\n    name=`basename $0 .sh`\n    case $1 in\n      s|start)\n        echo \"start...\"\n        ;;\n      stop)\n        echo \"stop ...\"\n            ;;\n      reload)\n            echo \"reload...\"\n            ;;\n      *)\n            echo \"Usage: $name [start|stop|reload]\"\n            exit 1\n            ;;\n    esac\n    exit 0\n```\n    1、*) 相当于其他语言中的default。\n    2、除了*)模式，各个分支中;;是必须的，;;相当于其他语言中的break\n    3、 | 分割多个模式，相当于or\n\n    help    查看所有bash保留的关键词\n    readonly定义变量只读\n    unset   删除变量\n    echo -e \"Value of a is $a \\n\"   使转义字符\\n生效\n        可以使用的转义符：\\\\ \\a \\b \\f \\n \\r \\t \\v\n\n    `${var}`  变量本来的值\n    `${var:-word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n    `${var:=word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n    `${var:?message}` 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n    `${var:+word}`    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\n    val=`expr 2 + 2`算数运算\n    `echo ${#string}`活取字符串长度\n    `echo ${string:1:4}`  输出第1位到第4位的字符串（从0开始）\n    定义数组：\n        array_name=(value0 value1 value2 value3)\n    或者    array_name=(\n        value0\n        value1\n        value2\n        value3\n        )\n    或者    array_name[0]=value0\n        array_name[1]=value1\n        array_name[2]=value2\n    `${array_name[2]}`    获取数组的值\n    `${array_name[*]}`    获取数组的所有元素\n    `${array_name[@]}`    获取数组的所有元素\n    `${#array_name[@]}`   获取数组个数\n    `${#array_name[*]}`   获取数组个数\n    `${#array_name[2]}`   获取数组单个元素的长度\n\n    command 2 > file    将stderr重定向到 file\n    command < file      将stdin重定向到file\n    command > file      将stdout重定向到file\n    command > file 2>&1 将stdout stderr都重定向到file\n    command < file1 >file2  将stdin重定向到file1 stdout重定向到file2\n\n    -cp 表示cp命令报错了不会停止，继续执行下面的操作\n    @cp 终端中不会打印出命令的执行\n    declare \n        -i  整型变量\n        -a  数组\n        -f  列出所有定义过的函数\n        -x  将声明的变量作为脚本的环境变量导出\n    shift   左移参数，shift 3表示`$4`变成`$1` 不带参数的话默认为shift 1\n    file=/dir1/dir2/dir3/my.file.txt\n    `${file#*/}`：    删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt\n    `${file##*/}`：   删掉最后一个/   及其左边的字符串：my.file.txt\n    `${file#*.}`：    删掉第一个.     及其左边的字符串：file.txt\n    `${file##*.}`：   删掉最后一个.   及其左边的字符串：txt\n    `${file%/*}`：    删掉最后一个 /      及其右边的字符串：/dir1/dir2/dir3\n    `${file%%/*}`：   删掉第一个/     及其右边的字符串：(空值)\n    `${file%.*}`：    删掉最后一个 .      及其右边的字符串：/dir1/dir2/dir3/my.file\n    `${file%%.*}`：   删掉第一个 .    及其右边的字符串：/dir1/dir2/dir3/my\n        记忆的方法为：\n        # 是 去掉左边（键盘上#在 `$` 的左边）\n        %是去掉右边（键盘上% 在`$` 的右边）\n        单一符号是最小匹配；两个符号是最大匹配\n    `${file:0:5}`：   提取最左边的5 个字节：/dir1\n    `${file:5:5}`：   提取第5 个字节右边的连续5个字节：/dir2\n    `${file/dir/path}`：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt\n    `${file//dir/path}`：将全部dir 替换为path：/path1/path2/path3/my.file.txt\n    `${#file}`:   计算字符串长度：27\n","source":"_posts/shell.md","raw":"---\ntitle: 嵌入式笔记：shell脚本\n---\n嵌入式笔记：shell脚本\n\n# 目录\n\n## shell种类\n<table>\n  <tr>\n  <td>bash</td>\n  <td>csh</td>\n  <td>ksh</td>\n  <td>zsh</td>\n  </tr>\n</table>\n\n## 基本语法\n### 定义和使用变量\n```sh\n#!/bin/sh\na=\" hello world\"\necho $a\necho 'a is xiaxaiwen${a}'\n```\n### if else\n```sh\nif ....; then \n　 .... \nelif ....; then \n　 .... \nelse \n　 .... \nfi \n```\n### [] 条件测试\n> [] 中前后一定要加空格\n\n### shell常用命令\n|                           |                              |\n|---------------------------|------------------------------|\n|`echo`                     |将文字内容打印在屏幕上 |\n|`ls`                       |文件列表 |\n|`wc`                       |计算文件行数(-l),单词数(-w),字符数(-c) |\n|`cp`                       | 文件拷贝 |\n|`mv`                       | 重命名文件或移动文件 |\n|`rm`                       | 删除文件 |\n|`grep`                     | 在文件内搜索字符串比如：grep 'searchstring' file.txt |\n|`cut -b`                   |  指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令 |\n|`cat`                      | 输出文件内容到标准输出设备（屏幕）上 |\n|`file`                     | 得到文件类型 |\n|`read var`                 | 提示用户输入，并将输入赋值给变量 |\n|`sort`                     | 对file.txt文件中的行进行排序 |\n|`uniq`                     | 删除文本文件中出现的行列比如： sort file.txt | uniq |\n|`expr`                     | 进行数学运算Example: add 2 and 3expr 2 \"+\" 3 |\n|`find`                     | 搜索文件比如：根据文件名搜索find . -name filename -print |\n|`tee`                      | 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile |\n|`basename`                 | 返回不包含路径的文件名比如： basename /bin/tux将返回 tux |\n|`dirname`                  | 返回文件所在路径比如：dirname /bin/tux将返回 /bin |\n|`head`                     | 打印文本文件开头几行 |\n|`tail`                     | 打印文本文件末尾几行 |\n|`sed`                      | Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' > newtext.file |\n|awk                        | awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '{print $1 \",\" $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA |\n### shell变量类型\n> shell变量名只能包含数字、字母和下划线\n#### 局部变量\n在脚本或命令中定义，仅在当前shell实例中有效\n#### 环境变量\n\n#### shell变量特殊变量\n\n|特殊变量列表|  说明 |\n|:-:|--------|\n|`$0`|当前脚本的文件名|\n|`$n`|传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是`$1`，第二个参数是`$2`。|\n|`$#`|传递给脚本或函数的参数个数。|\n|`$*`|传递给脚本或函数的所有参数。|\n|`$@`|传递给脚本或函数的所有参数。被双引号(\" \")包含时，与 `$*` 稍有不同，下面将会讲到。|\n|`$?`|上个命令的退出状态，或函数的返回值。|\n|`$$`|当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。|\n\n### 条件语句\nfor\nwhile\nif\n### 特殊符号\n`!!`  表示执行上一条指令\n`!n`  表示执行命令历史中第n条指令\n`*`   匹配零个或多个字符\n`?`   匹配一个字符\n`env` 系统预设的环境变量\n`$?`  上次执行命令或函数的返回值\n`$*`  传递给脚本或函数的所有参数\n`$@`  传递给脚本或函数的所有参数。被双引号(`\" \"`)包含时，与 `$*` 稍有不同，下面将会讲到。\n`$$`  脚本运行的当前进程id\n`$!`  最后执行的后台命令的PID\n`$#`  传递给shell脚本的参数个数\n`反引号` 设置系统的命令输出到变量\n`echo *`  以串行形式，打印当前整个目录\n### 数值比较运算符\n-eq 相等\n-ne 不等\n-gt 大于\n-lt 小于\n-le 小于等于\n-ge 大于等于\n### 字符串比较运算符\n=   相等\n!=  不等\n-z  空串\n-n  非空串\n### 文件比较运算符\n-d  目录\n-f  文件\n-L  链接\n-r  可读\n-w  可写\n-x  可执行\n-s  文件非空\n### 逻辑运算符\n-a  逻辑与\n-o  逻辑或\n!   逻辑否\n\n\n### 替换运算符\n1. `${var_name:-def_Val}`\n    如果变量var_name存在且为非null，返回该变量的值，否则返回默认值def-Val\n    注意var_name与:之间没有空格，:与-之间可以有空格。主要用途，如果变量未定义，则用默认值.\n2. `${var_name:=val}`\n    如果变量var_name存在且为非null，返回该变量的值，否则，把val的值赋给变量var_name，并返回var_name的值val\n    注意var_name与:之间没有空格，:与=之间也不能有空格。\n3. `${var_name:?message}`\n    如果变量var_name存在且为非null，返回该变量的值，否则返回该变量的名字var_name:提示信息meesage，并退出当前命令或脚本\n    注意var_name与:之间没有空格，:与?之间也不能有空格。\n4. `${var_name:+val}`\n    如果变量var_name存在且为非null，返回val，否则返回null\n    注意var_name与`:`之间没有空格，`:`与`+`之间也不能有空格。\n5. \n```sh\n${#val_name}\n```\n    返回变量长度\n6. `$*` `$@`\n    显示所有命令行参数\n7. `$0`\n    脚本程序名称\n8.  `$n`\n    第n个参数\n9.  `$(())`\n    算术运算操作\n10. `$((var1 opr var2))`\n  例如:`$((5+1))` 只能是`+ - * / ()运算符`，并且只能做整数运算\n11. `$()`\n    命令代换 类似于 `反引号` 例如：`echo $(date)`\n\n### 循环语句用法\n```sh\n    for i in $path\n    for i in `seq 1 9`\n    for i in $(seq 1 9)\n    for i in {a..z}\n    for (( i=1; i<=10; i++ ))\n    while [ $cnt -ge  0 ]\n    until [ $cnt -lt 0 ]\n```\n### case语句\n```sh\n    name=`basename $0 .sh`\n    case $1 in\n      s|start)\n        echo \"start...\"\n        ;;\n      stop)\n        echo \"stop ...\"\n            ;;\n      reload)\n            echo \"reload...\"\n            ;;\n      *)\n            echo \"Usage: $name [start|stop|reload]\"\n            exit 1\n            ;;\n    esac\n    exit 0\n```\n    1、*) 相当于其他语言中的default。\n    2、除了*)模式，各个分支中;;是必须的，;;相当于其他语言中的break\n    3、 | 分割多个模式，相当于or\n\n    help    查看所有bash保留的关键词\n    readonly定义变量只读\n    unset   删除变量\n    echo -e \"Value of a is $a \\n\"   使转义字符\\n生效\n        可以使用的转义符：\\\\ \\a \\b \\f \\n \\r \\t \\v\n\n    `${var}`  变量本来的值\n    `${var:-word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n    `${var:=word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n    `${var:?message}` 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n    `${var:+word}`    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\n    val=`expr 2 + 2`算数运算\n    `echo ${#string}`活取字符串长度\n    `echo ${string:1:4}`  输出第1位到第4位的字符串（从0开始）\n    定义数组：\n        array_name=(value0 value1 value2 value3)\n    或者    array_name=(\n        value0\n        value1\n        value2\n        value3\n        )\n    或者    array_name[0]=value0\n        array_name[1]=value1\n        array_name[2]=value2\n    `${array_name[2]}`    获取数组的值\n    `${array_name[*]}`    获取数组的所有元素\n    `${array_name[@]}`    获取数组的所有元素\n    `${#array_name[@]}`   获取数组个数\n    `${#array_name[*]}`   获取数组个数\n    `${#array_name[2]}`   获取数组单个元素的长度\n\n    command 2 > file    将stderr重定向到 file\n    command < file      将stdin重定向到file\n    command > file      将stdout重定向到file\n    command > file 2>&1 将stdout stderr都重定向到file\n    command < file1 >file2  将stdin重定向到file1 stdout重定向到file2\n\n    -cp 表示cp命令报错了不会停止，继续执行下面的操作\n    @cp 终端中不会打印出命令的执行\n    declare \n        -i  整型变量\n        -a  数组\n        -f  列出所有定义过的函数\n        -x  将声明的变量作为脚本的环境变量导出\n    shift   左移参数，shift 3表示`$4`变成`$1` 不带参数的话默认为shift 1\n    file=/dir1/dir2/dir3/my.file.txt\n    `${file#*/}`：    删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt\n    `${file##*/}`：   删掉最后一个/   及其左边的字符串：my.file.txt\n    `${file#*.}`：    删掉第一个.     及其左边的字符串：file.txt\n    `${file##*.}`：   删掉最后一个.   及其左边的字符串：txt\n    `${file%/*}`：    删掉最后一个 /      及其右边的字符串：/dir1/dir2/dir3\n    `${file%%/*}`：   删掉第一个/     及其右边的字符串：(空值)\n    `${file%.*}`：    删掉最后一个 .      及其右边的字符串：/dir1/dir2/dir3/my.file\n    `${file%%.*}`：   删掉第一个 .    及其右边的字符串：/dir1/dir2/dir3/my\n        记忆的方法为：\n        # 是 去掉左边（键盘上#在 `$` 的左边）\n        %是去掉右边（键盘上% 在`$` 的右边）\n        单一符号是最小匹配；两个符号是最大匹配\n    `${file:0:5}`：   提取最左边的5 个字节：/dir1\n    `${file:5:5}`：   提取第5 个字节右边的连续5个字节：/dir2\n    `${file/dir/path}`：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt\n    `${file//dir/path}`：将全部dir 替换为path：/path1/path2/path3/my.file.txt\n    `${#file}`:   计算字符串长度：27\n","slug":"shell","published":1,"date":"2018-02-28T01:36:59.506Z","updated":"2018-02-28T01:36:59.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbb00069vf7mjlg41u0","content":"<p>嵌入式笔记：shell脚本</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"shell种类\"><a href=\"#shell种类\" class=\"headerlink\" title=\"shell种类\"></a>shell种类</h2><table><br>  <tr><br>  <td>bash</td><br>  <td>csh</td><br>  <td>ksh</td><br>  <td>zsh</td><br>  </tr><br></table>\n\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"定义和使用变量\"><a href=\"#定义和使用变量\" class=\"headerlink\" title=\"定义和使用变量\"></a>定义和使用变量</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">#!/bin/sh\na=\" hello world\"\necho $a\necho 'a is xiaxaiwen${a}'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">if ....; then \n　 .... \nelif ....; then \n　 .... \nelse \n　 .... \nfi \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"条件测试\"><a href=\"#条件测试\" class=\"headerlink\" title=\"[] 条件测试\"></a>[] 条件测试</h3><blockquote>\n<p>[] 中前后一定要加空格</p>\n</blockquote>\n<h3 id=\"shell常用命令\"><a href=\"#shell常用命令\" class=\"headerlink\" title=\"shell常用命令\"></a>shell常用命令</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>echo</code></td>\n<td>将文字内容打印在屏幕上</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>文件列表</td>\n</tr>\n<tr>\n<td><code>wc</code></td>\n<td>计算文件行数(-l),单词数(-w),字符数(-c)</td>\n</tr>\n<tr>\n<td><code>cp</code></td>\n<td>文件拷贝</td>\n</tr>\n<tr>\n<td><code>mv</code></td>\n<td>重命名文件或移动文件</td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td><code>grep</code></td>\n<td>在文件内搜索字符串比如：grep ‘searchstring’ file.txt</td>\n</tr>\n<tr>\n<td><code>cut -b</code></td>\n<td>指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令</td>\n</tr>\n<tr>\n<td><code>cat</code></td>\n<td>输出文件内容到标准输出设备（屏幕）上</td>\n</tr>\n<tr>\n<td><code>file</code></td>\n<td>得到文件类型</td>\n</tr>\n<tr>\n<td><code>read var</code></td>\n<td>提示用户输入，并将输入赋值给变量</td>\n</tr>\n<tr>\n<td><code>sort</code></td>\n<td>对file.txt文件中的行进行排序</td>\n</tr>\n<tr>\n<td><code>uniq</code></td>\n<td>删除文本文件中出现的行列比如： sort file.txt</td>\n<td>uniq</td>\n</tr>\n<tr>\n<td><code>expr</code></td>\n<td>进行数学运算Example: add 2 and 3expr 2 “+” 3</td>\n</tr>\n<tr>\n<td><code>find</code></td>\n<td>搜索文件比如：根据文件名搜索find . -name filename -print</td>\n</tr>\n<tr>\n<td><code>tee</code></td>\n<td>将数据输出到标准输出设备(屏幕) 和文件比如：somecommand</td>\n<td>tee outfile</td>\n</tr>\n<tr>\n<td><code>basename</code></td>\n<td>返回不包含路径的文件名比如： basename /bin/tux将返回 tux</td>\n</tr>\n<tr>\n<td><code>dirname</code></td>\n<td>返回文件所在路径比如：dirname /bin/tux将返回 /bin</td>\n</tr>\n<tr>\n<td><code>head</code></td>\n<td>打印文本文件开头几行</td>\n</tr>\n<tr>\n<td><code>tail</code></td>\n<td>打印文本文件末尾几行</td>\n</tr>\n<tr>\n<td><code>sed</code></td>\n<td>Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file</td>\n<td>sed ‘s/linuxfocus/LinuxFocus/‘ &gt; newtext.file</td>\n</tr>\n<tr>\n<td>awk</td>\n<td>awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt</td>\n<td>awk -F, ‘{print $1 “,” $3 }’这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"shell变量类型\"><a href=\"#shell变量类型\" class=\"headerlink\" title=\"shell变量类型\"></a>shell变量类型</h3><blockquote>\n<p>shell变量名只能包含数字、字母和下划线</p>\n</blockquote>\n<h4 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h4><p>在脚本或命令中定义，仅在当前shell实例中有效</p>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><h4 id=\"shell变量特殊变量\"><a href=\"#shell变量特殊变量\" class=\"headerlink\" title=\"shell变量特殊变量\"></a>shell变量特殊变量</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特殊变量列表</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>$0</code></td>\n<td>当前脚本的文件名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$n</code></td>\n<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<code>$1</code>，第二个参数是<code>$2</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$#</code></td>\n<td>传递给脚本或函数的参数个数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$*</code></td>\n<td>传递给脚本或函数的所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$@</code></td>\n<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 <code>$*</code> 稍有不同，下面将会讲到。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$?</code></td>\n<td>上个命令的退出状态，或函数的返回值。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$$</code></td>\n<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>for<br>while<br>if</p>\n<h3 id=\"特殊符号\"><a href=\"#特殊符号\" class=\"headerlink\" title=\"特殊符号\"></a>特殊符号</h3><p><code>!!</code>  表示执行上一条指令<br><code>!n</code>  表示执行命令历史中第n条指令<br><code>*</code>   匹配零个或多个字符<br><code>?</code>   匹配一个字符<br><code>env</code> 系统预设的环境变量<br><code>$?</code>  上次执行命令或函数的返回值<br><code>$*</code>  传递给脚本或函数的所有参数<br><code>$@</code>  传递给脚本或函数的所有参数。被双引号(<code>&quot; &quot;</code>)包含时，与 <code>$*</code> 稍有不同，下面将会讲到。<br><code>$$</code>  脚本运行的当前进程id<br><code>$!</code>  最后执行的后台命令的PID<br><code>$#</code>  传递给shell脚本的参数个数<br><code>反引号</code> 设置系统的命令输出到变量<br><code>echo *</code>  以串行形式，打印当前整个目录</p>\n<h3 id=\"数值比较运算符\"><a href=\"#数值比较运算符\" class=\"headerlink\" title=\"数值比较运算符\"></a>数值比较运算符</h3><p>-eq 相等<br>-ne 不等<br>-gt 大于<br>-lt 小于<br>-le 小于等于<br>-ge 大于等于</p>\n<h3 id=\"字符串比较运算符\"><a href=\"#字符串比较运算符\" class=\"headerlink\" title=\"字符串比较运算符\"></a>字符串比较运算符</h3><p>=   相等<br>!=  不等<br>-z  空串<br>-n  非空串</p>\n<h3 id=\"文件比较运算符\"><a href=\"#文件比较运算符\" class=\"headerlink\" title=\"文件比较运算符\"></a>文件比较运算符</h3><p>-d  目录<br>-f  文件<br>-L  链接<br>-r  可读<br>-w  可写<br>-x  可执行<br>-s  文件非空</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>-a  逻辑与<br>-o  逻辑或<br>!   逻辑否</p>\n<h3 id=\"替换运算符\"><a href=\"#替换运算符\" class=\"headerlink\" title=\"替换运算符\"></a>替换运算符</h3><ol>\n<li><code>${var_name:-def_Val}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则返回默认值def-Val<br> 注意var_name与:之间没有空格，:与-之间可以有空格。主要用途，如果变量未定义，则用默认值.</li>\n<li><code>${var_name:=val}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则，把val的值赋给变量var_name，并返回var_name的值val<br> 注意var_name与:之间没有空格，:与=之间也不能有空格。</li>\n<li><code>${var_name:?message}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则返回该变量的名字var_name:提示信息meesage，并退出当前命令或脚本<br> 注意var_name与:之间没有空格，:与?之间也不能有空格。</li>\n<li><code>${var_name:+val}</code><br> 如果变量var_name存在且为非null，返回val，否则返回null<br> 注意var_name与<code>:</code>之间没有空格，<code>:</code>与<code>+</code>之间也不能有空格。</li>\n<li><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">${#val_name}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n 返回变量长度</li>\n<li><code>$*</code> <code>$@</code><br> 显示所有命令行参数</li>\n<li><code>$0</code><br> 脚本程序名称</li>\n<li><code>$n</code><br>第n个参数</li>\n<li><code>$(())</code><br>算术运算操作</li>\n<li><code>$((var1 opr var2))</code><br>例如:<code>$((5+1))</code> 只能是<code>+ - * / ()运算符</code>，并且只能做整数运算</li>\n<li><code>$()</code><br>命令代换 类似于 <code>反引号</code> 例如：<code>echo $(date)</code></li>\n</ol>\n<h3 id=\"循环语句用法\"><a href=\"#循环语句用法\" class=\"headerlink\" title=\"循环语句用法\"></a>循环语句用法</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">    for i in $path\n    for i in `seq 1 9`\n    for i in $(seq 1 9)\n    for i in {a..z}\n    for (( i=1; i<=10; i++ ))\n    while [ $cnt -ge  0 ]\n    until [ $cnt -lt 0 ]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">    name=`basename $0 .sh`\n    case $1 in\n      s|start)\n        echo \"start...\"\n        ;;\n      stop)\n        echo \"stop ...\"\n            ;;\n      reload)\n            echo \"reload...\"\n            ;;\n      *)\n            echo \"Usage: $name [start|stop|reload]\"\n            exit 1\n            ;;\n    esac\n    exit 0\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>1、*) 相当于其他语言中的default。\n2、除了*)模式，各个分支中;;是必须的，;;相当于其他语言中的break\n3、 | 分割多个模式，相当于or\n\nhelp    查看所有bash保留的关键词\nreadonly定义变量只读\nunset   删除变量\necho -e &quot;Value of a is $a \\n&quot;   使转义字符\\n生效\n    可以使用的转义符：\\\\ \\a \\b \\f \\n \\r \\t \\v\n\n`${var}`  变量本来的值\n`${var:-word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n`${var:=word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n`${var:?message}` 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n`${var:+word}`    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\nval=`expr 2 + 2`算数运算\n`echo ${#string}`活取字符串长度\n`echo ${string:1:4}`  输出第1位到第4位的字符串（从0开始）\n定义数组：\n    array_name=(value0 value1 value2 value3)\n或者    array_name=(\n    value0\n    value1\n    value2\n    value3\n    )\n或者    array_name[0]=value0\n    array_name[1]=value1\n    array_name[2]=value2\n`${array_name[2]}`    获取数组的值\n`${array_name[*]}`    获取数组的所有元素\n`${array_name[@]}`    获取数组的所有元素\n`${#array_name[@]}`   获取数组个数\n`${#array_name[*]}`   获取数组个数\n`${#array_name[2]}`   获取数组单个元素的长度\n\ncommand 2 &gt; file    将stderr重定向到 file\ncommand &lt; file      将stdin重定向到file\ncommand &gt; file      将stdout重定向到file\ncommand &gt; file 2&gt;&amp;1 将stdout stderr都重定向到file\ncommand &lt; file1 &gt;file2  将stdin重定向到file1 stdout重定向到file2\n\n-cp 表示cp命令报错了不会停止，继续执行下面的操作\n@cp 终端中不会打印出命令的执行\ndeclare \n    -i  整型变量\n    -a  数组\n    -f  列出所有定义过的函数\n    -x  将声明的变量作为脚本的环境变量导出\nshift   左移参数，shift 3表示`$4`变成`$1` 不带参数的话默认为shift 1\nfile=/dir1/dir2/dir3/my.file.txt\n`${file#*/}`：    删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt\n`${file##*/}`：   删掉最后一个/   及其左边的字符串：my.file.txt\n`${file#*.}`：    删掉第一个.     及其左边的字符串：file.txt\n`${file##*.}`：   删掉最后一个.   及其左边的字符串：txt\n`${file%/*}`：    删掉最后一个 /      及其右边的字符串：/dir1/dir2/dir3\n`${file%%/*}`：   删掉第一个/     及其右边的字符串：(空值)\n`${file%.*}`：    删掉最后一个 .      及其右边的字符串：/dir1/dir2/dir3/my.file\n`${file%%.*}`：   删掉第一个 .    及其右边的字符串：/dir1/dir2/dir3/my\n    记忆的方法为：\n    # 是 去掉左边（键盘上#在 `$` 的左边）\n    %是去掉右边（键盘上% 在`$` 的右边）\n    单一符号是最小匹配；两个符号是最大匹配\n`${file:0:5}`：   提取最左边的5 个字节：/dir1\n`${file:5:5}`：   提取第5 个字节右边的连续5个字节：/dir2\n`${file/dir/path}`：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt\n`${file//dir/path}`：将全部dir 替换为path：/path1/path2/path3/my.file.txt\n`${#file}`:   计算字符串长度：27\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：shell脚本</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"shell种类\"><a href=\"#shell种类\" class=\"headerlink\" title=\"shell种类\"></a>shell种类</h2><table><br>  <tr><br>  <td>bash</td><br>  <td>csh</td><br>  <td>ksh</td><br>  <td>zsh</td><br>  </tr><br></table>\n\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"定义和使用变量\"><a href=\"#定义和使用变量\" class=\"headerlink\" title=\"定义和使用变量\"></a>定义和使用变量</h3><pre><code class=\"sh\">#!/bin/sh\na=&quot; hello world&quot;\necho $a\necho &#39;a is xiaxaiwen${a}&#39;\n</code></pre>\n<h3 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h3><pre><code class=\"sh\">if ....; then \n　 .... \nelif ....; then \n　 .... \nelse \n　 .... \nfi \n</code></pre>\n<h3 id=\"条件测试\"><a href=\"#条件测试\" class=\"headerlink\" title=\"[] 条件测试\"></a>[] 条件测试</h3><blockquote>\n<p>[] 中前后一定要加空格</p>\n</blockquote>\n<h3 id=\"shell常用命令\"><a href=\"#shell常用命令\" class=\"headerlink\" title=\"shell常用命令\"></a>shell常用命令</h3><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>echo</code></td>\n<td>将文字内容打印在屏幕上</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>文件列表</td>\n</tr>\n<tr>\n<td><code>wc</code></td>\n<td>计算文件行数(-l),单词数(-w),字符数(-c)</td>\n</tr>\n<tr>\n<td><code>cp</code></td>\n<td>文件拷贝</td>\n</tr>\n<tr>\n<td><code>mv</code></td>\n<td>重命名文件或移动文件</td>\n</tr>\n<tr>\n<td><code>rm</code></td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td><code>grep</code></td>\n<td>在文件内搜索字符串比如：grep ‘searchstring’ file.txt</td>\n</tr>\n<tr>\n<td><code>cut -b</code></td>\n<td>指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令</td>\n</tr>\n<tr>\n<td><code>cat</code></td>\n<td>输出文件内容到标准输出设备（屏幕）上</td>\n</tr>\n<tr>\n<td><code>file</code></td>\n<td>得到文件类型</td>\n</tr>\n<tr>\n<td><code>read var</code></td>\n<td>提示用户输入，并将输入赋值给变量</td>\n</tr>\n<tr>\n<td><code>sort</code></td>\n<td>对file.txt文件中的行进行排序</td>\n</tr>\n<tr>\n<td><code>uniq</code></td>\n<td>删除文本文件中出现的行列比如： sort file.txt</td>\n<td>uniq</td>\n</tr>\n<tr>\n<td><code>expr</code></td>\n<td>进行数学运算Example: add 2 and 3expr 2 “+” 3</td>\n</tr>\n<tr>\n<td><code>find</code></td>\n<td>搜索文件比如：根据文件名搜索find . -name filename -print</td>\n</tr>\n<tr>\n<td><code>tee</code></td>\n<td>将数据输出到标准输出设备(屏幕) 和文件比如：somecommand</td>\n<td>tee outfile</td>\n</tr>\n<tr>\n<td><code>basename</code></td>\n<td>返回不包含路径的文件名比如： basename /bin/tux将返回 tux</td>\n</tr>\n<tr>\n<td><code>dirname</code></td>\n<td>返回文件所在路径比如：dirname /bin/tux将返回 /bin</td>\n</tr>\n<tr>\n<td><code>head</code></td>\n<td>打印文本文件开头几行</td>\n</tr>\n<tr>\n<td><code>tail</code></td>\n<td>打印文本文件末尾几行</td>\n</tr>\n<tr>\n<td><code>sed</code></td>\n<td>Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file</td>\n<td>sed ‘s/linuxfocus/LinuxFocus/‘ &gt; newtext.file</td>\n</tr>\n<tr>\n<td>awk</td>\n<td>awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt</td>\n<td>awk -F, ‘{print $1 “,” $3 }’这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"shell变量类型\"><a href=\"#shell变量类型\" class=\"headerlink\" title=\"shell变量类型\"></a>shell变量类型</h3><blockquote>\n<p>shell变量名只能包含数字、字母和下划线</p>\n</blockquote>\n<h4 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h4><p>在脚本或命令中定义，仅在当前shell实例中有效</p>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><h4 id=\"shell变量特殊变量\"><a href=\"#shell变量特殊变量\" class=\"headerlink\" title=\"shell变量特殊变量\"></a>shell变量特殊变量</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特殊变量列表</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>$0</code></td>\n<td>当前脚本的文件名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$n</code></td>\n<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是<code>$1</code>，第二个参数是<code>$2</code>。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$#</code></td>\n<td>传递给脚本或函数的参数个数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$*</code></td>\n<td>传递给脚本或函数的所有参数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$@</code></td>\n<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 <code>$*</code> 稍有不同，下面将会讲到。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$?</code></td>\n<td>上个命令的退出状态，或函数的返回值。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>$$</code></td>\n<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h3><p>for<br>while<br>if</p>\n<h3 id=\"特殊符号\"><a href=\"#特殊符号\" class=\"headerlink\" title=\"特殊符号\"></a>特殊符号</h3><p><code>!!</code>  表示执行上一条指令<br><code>!n</code>  表示执行命令历史中第n条指令<br><code>*</code>   匹配零个或多个字符<br><code>?</code>   匹配一个字符<br><code>env</code> 系统预设的环境变量<br><code>$?</code>  上次执行命令或函数的返回值<br><code>$*</code>  传递给脚本或函数的所有参数<br><code>$@</code>  传递给脚本或函数的所有参数。被双引号(<code>&quot; &quot;</code>)包含时，与 <code>$*</code> 稍有不同，下面将会讲到。<br><code>$$</code>  脚本运行的当前进程id<br><code>$!</code>  最后执行的后台命令的PID<br><code>$#</code>  传递给shell脚本的参数个数<br><code>反引号</code> 设置系统的命令输出到变量<br><code>echo *</code>  以串行形式，打印当前整个目录</p>\n<h3 id=\"数值比较运算符\"><a href=\"#数值比较运算符\" class=\"headerlink\" title=\"数值比较运算符\"></a>数值比较运算符</h3><p>-eq 相等<br>-ne 不等<br>-gt 大于<br>-lt 小于<br>-le 小于等于<br>-ge 大于等于</p>\n<h3 id=\"字符串比较运算符\"><a href=\"#字符串比较运算符\" class=\"headerlink\" title=\"字符串比较运算符\"></a>字符串比较运算符</h3><p>=   相等<br>!=  不等<br>-z  空串<br>-n  非空串</p>\n<h3 id=\"文件比较运算符\"><a href=\"#文件比较运算符\" class=\"headerlink\" title=\"文件比较运算符\"></a>文件比较运算符</h3><p>-d  目录<br>-f  文件<br>-L  链接<br>-r  可读<br>-w  可写<br>-x  可执行<br>-s  文件非空</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>-a  逻辑与<br>-o  逻辑或<br>!   逻辑否</p>\n<h3 id=\"替换运算符\"><a href=\"#替换运算符\" class=\"headerlink\" title=\"替换运算符\"></a>替换运算符</h3><ol>\n<li><code>${var_name:-def_Val}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则返回默认值def-Val<br> 注意var_name与:之间没有空格，:与-之间可以有空格。主要用途，如果变量未定义，则用默认值.</li>\n<li><code>${var_name:=val}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则，把val的值赋给变量var_name，并返回var_name的值val<br> 注意var_name与:之间没有空格，:与=之间也不能有空格。</li>\n<li><code>${var_name:?message}</code><br> 如果变量var_name存在且为非null，返回该变量的值，否则返回该变量的名字var_name:提示信息meesage，并退出当前命令或脚本<br> 注意var_name与:之间没有空格，:与?之间也不能有空格。</li>\n<li><code>${var_name:+val}</code><br> 如果变量var_name存在且为非null，返回val，否则返回null<br> 注意var_name与<code>:</code>之间没有空格，<code>:</code>与<code>+</code>之间也不能有空格。</li>\n<li><pre><code class=\"sh\">${#val_name}\n</code></pre>\n 返回变量长度</li>\n<li><code>$*</code> <code>$@</code><br> 显示所有命令行参数</li>\n<li><code>$0</code><br> 脚本程序名称</li>\n<li><code>$n</code><br>第n个参数</li>\n<li><code>$(())</code><br>算术运算操作</li>\n<li><code>$((var1 opr var2))</code><br>例如:<code>$((5+1))</code> 只能是<code>+ - * / ()运算符</code>，并且只能做整数运算</li>\n<li><code>$()</code><br>命令代换 类似于 <code>反引号</code> 例如：<code>echo $(date)</code></li>\n</ol>\n<h3 id=\"循环语句用法\"><a href=\"#循环语句用法\" class=\"headerlink\" title=\"循环语句用法\"></a>循环语句用法</h3><pre><code class=\"sh\">    for i in $path\n    for i in `seq 1 9`\n    for i in $(seq 1 9)\n    for i in {a..z}\n    for (( i=1; i&lt;=10; i++ ))\n    while [ $cnt -ge  0 ]\n    until [ $cnt -lt 0 ]\n</code></pre>\n<h3 id=\"case语句\"><a href=\"#case语句\" class=\"headerlink\" title=\"case语句\"></a>case语句</h3><pre><code class=\"sh\">    name=`basename $0 .sh`\n    case $1 in\n      s|start)\n        echo &quot;start...&quot;\n        ;;\n      stop)\n        echo &quot;stop ...&quot;\n            ;;\n      reload)\n            echo &quot;reload...&quot;\n            ;;\n      *)\n            echo &quot;Usage: $name [start|stop|reload]&quot;\n            exit 1\n            ;;\n    esac\n    exit 0\n</code></pre>\n<pre><code>1、*) 相当于其他语言中的default。\n2、除了*)模式，各个分支中;;是必须的，;;相当于其他语言中的break\n3、 | 分割多个模式，相当于or\n\nhelp    查看所有bash保留的关键词\nreadonly定义变量只读\nunset   删除变量\necho -e &quot;Value of a is $a \\n&quot;   使转义字符\\n生效\n    可以使用的转义符：\\\\ \\a \\b \\f \\n \\r \\t \\v\n\n`${var}`  变量本来的值\n`${var:-word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n`${var:=word}`    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n`${var:?message}` 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n`${var:+word}`    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\nval=`expr 2 + 2`算数运算\n`echo ${#string}`活取字符串长度\n`echo ${string:1:4}`  输出第1位到第4位的字符串（从0开始）\n定义数组：\n    array_name=(value0 value1 value2 value3)\n或者    array_name=(\n    value0\n    value1\n    value2\n    value3\n    )\n或者    array_name[0]=value0\n    array_name[1]=value1\n    array_name[2]=value2\n`${array_name[2]}`    获取数组的值\n`${array_name[*]}`    获取数组的所有元素\n`${array_name[@]}`    获取数组的所有元素\n`${#array_name[@]}`   获取数组个数\n`${#array_name[*]}`   获取数组个数\n`${#array_name[2]}`   获取数组单个元素的长度\n\ncommand 2 &gt; file    将stderr重定向到 file\ncommand &lt; file      将stdin重定向到file\ncommand &gt; file      将stdout重定向到file\ncommand &gt; file 2&gt;&amp;1 将stdout stderr都重定向到file\ncommand &lt; file1 &gt;file2  将stdin重定向到file1 stdout重定向到file2\n\n-cp 表示cp命令报错了不会停止，继续执行下面的操作\n@cp 终端中不会打印出命令的执行\ndeclare \n    -i  整型变量\n    -a  数组\n    -f  列出所有定义过的函数\n    -x  将声明的变量作为脚本的环境变量导出\nshift   左移参数，shift 3表示`$4`变成`$1` 不带参数的话默认为shift 1\nfile=/dir1/dir2/dir3/my.file.txt\n`${file#*/}`：    删掉第一个/ 及其左边的字符串：dir1/dir2/dir3/my.file.txt\n`${file##*/}`：   删掉最后一个/   及其左边的字符串：my.file.txt\n`${file#*.}`：    删掉第一个.     及其左边的字符串：file.txt\n`${file##*.}`：   删掉最后一个.   及其左边的字符串：txt\n`${file%/*}`：    删掉最后一个 /      及其右边的字符串：/dir1/dir2/dir3\n`${file%%/*}`：   删掉第一个/     及其右边的字符串：(空值)\n`${file%.*}`：    删掉最后一个 .      及其右边的字符串：/dir1/dir2/dir3/my.file\n`${file%%.*}`：   删掉第一个 .    及其右边的字符串：/dir1/dir2/dir3/my\n    记忆的方法为：\n    # 是 去掉左边（键盘上#在 `$` 的左边）\n    %是去掉右边（键盘上% 在`$` 的右边）\n    单一符号是最小匹配；两个符号是最大匹配\n`${file:0:5}`：   提取最左边的5 个字节：/dir1\n`${file:5:5}`：   提取第5 个字节右边的连续5个字节：/dir2\n`${file/dir/path}`：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt\n`${file//dir/path}`：将全部dir 替换为path：/path1/path2/path3/my.file.txt\n`${#file}`:   计算字符串长度：27\n</code></pre>"},{"title":"嵌入式笔记：Makefile学习","_content":"嵌入式笔记：Makefile学习\n\n# 目录\n\n## 简单的makefile\n```makefile\nCROSS_COMPILE=/opt/4.5.1/bin/arm-linux-\n\nCC=$(CROSS_COMPILE)gcc\nAS=$(CROSS_COMPILE)as\nLD=$(CROSS_COMPILE)ld\n\nCFLAGS=-g -Wall\nLIBS=-lpthread\n\nall:main\n\nmain:main.o gsm_gprs.o socket.o telosb.o wifi.o \n\t$(CC) $(CFLAGS) $(LIBS) $^ -o $@\n\nmain.o: main.c gsm_gprs.h option.h telosb.h\n\t$(CC) $(CFLAGS) -c $<\n\ngsm_gprs.o:gsm_gprs.c gsm_gprs.h socket.h\n\t$(CC) $(CFLAGS) -c $<\n\nsocket.o:socket.c socket.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\ntelosb.o: telosb.c telosb.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\nwifi.o: wifi.c wifi.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\nclean:\n\t-rm main -f *\\.o *\\*~ *~\n```\n\n## makefile赋值\n|赋值|说明|\n|:-:|-|\n|`=`|基本的赋值 会在makefile的最后才赋值|\n|`:=`|覆盖之前的值 会立即赋值|\n|`?=`|如果没有赋值过就赋值|\n|`+=`|添加后面的值|\n\n## .PHONY : clean\n    伪目标\n\n## make命令默认支持的文件名\n> make指令如果没有指定具体的makefile文件，就会自动寻找如下的makefile文件\n\n<table>\n    <tr>\n        <td>GNUmakefile</td>\n        <td>makefile</td>\n        <td>Makefile</td>\n    <tr>\n</table>\n\n## include\n    makefile包含\n\n## -include\n    makefile包含，当include过程中出现错误，不报错继续执行\n\n## MAKEFILES\n    make会自动include这个环境变量中的值\n\n## VPATH\n    指定makefile文件搜寻路径\n\n## vpath\n    make 关键词 设置文件搜寻路径\n\n## Makefile内建函数\n\n### 文本处理和分析函数\n\n#### 替换\n```makefile\n$(subst from,to,text)\n```\n#### 模式替换\n> 可用%（只用第一个%有用），如 `$(patsubst %.c,%.o,x.c.c bar.c)`，结果 `‘x.c.o bar.o’`\n```makefile\n$(patsubst pattern,replacement,text) \n```\n#### 去掉文本两端空格，以及把2个和2个以上的空格换成一个\n```makefile\n$(strip string) \n```\n#### 查找\n```makefile\n$(findstring find,in)\n```\n#### 过滤\n> 只保留pattern部分\n```makefile\n$(filter pattern…,text)\n```\n#### 过滤掉\n> 不保留pattern部分\n```makefile\n$(filter-out pattern…,text)\n```\n#### 排序\n```makefile\n$(sort list)\n```\n#### 取字符串\n```makefile\n$(word n,text)\n```\n#### 取字符串列表\n> 第s(start)个到第e（end）个\n```makefile\n$(wordlist s,e,text)\n# $(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).\n```\n#### 取第一个\n```makefile\n$(firstword names…)\n```\n#### 取最后一个\n```makefile\n$(lastword names…)\n```\n### 文件名处理函数\n#### 取目录\n```makefile\n$(dir names…)\n```\n#### 取文件\n> 但并不完全正确，注意观察，因为这个原理是已斜杠“/”为标识符的，如果文件名中包含斜杠，则返回的文件名就有误\n```makefile\n$(notdir names…)\n```\n#### 取文件后缀\n```makefile\n$(suffix names…)\n```\n#### 取文件名\n> 包括前面的目录部分，如`$(basename src/foo.c src-1.0/bar hacks)`， 结果为`src/foo src-1.0/bar hacks`\n```makefile\n$(basename names…)\n```\n#### 添加后缀\n> example ：`$(addprefix src/,foo bar)`，produces the result `‘src/foo src/bar’`\n```makefile\n$(addsuffix suffix,names…)\n```\n#### 连接函数\n> example: ‘$(join a b,.c .o)’ produces ‘a.c b.o’.\n```makefile\n$(join list1,list2)\n```\n#### 通配符函数\n> 表示可以使用正则表达式的符号。The argument pattern is a file name pattern, typically containing wildcard characters (as in shell file name patterns). The result of wildcard is a space-separated list of the names of existing files that match the pattern\n```makefile\n$(wildcard pattern)\n```\n#### 真实路径\n```makefile\n$(realpath names…)\n```\n#### 绝对路径\n```makefile\n$(abspath names…)\n```\n\n### foreach函数\n`$(foreach var,list,text)`相当于for循环函数，不过最终这里返回的是text的值，这个值是循环得到的一个list，如\n```makefile\nfind_files = $(wildcard $(dir)/*) #“=”等号是延时加载（deferred）\ndirs := a b c d\nfiles := $(foreach dir,$(dirs),$(find_files))\n```\n即\n```makefile\nfiles := $(wildcard a/* b/* c/* d/*)\n```\n \n\n### if函数\n```makefile\nifeq (arg1, arg2)\nifneq (arg1, arg2)\nifdef variable-name\nifndef variable-name\n```\n### call函数\n```makefile\n$(call VARIABLE,PARAM,PARAM,...)\n```\n“call”函数是唯一一个可以创建定制化参数函数的引用函数。使用这个函数可以 实现对用户自己定义函数引用。我们可以将一个变量定义为一个复杂的表达式，用“call” 函数根据不同的参数对它进行展开来获得不同的结果。\n\n如：`reverse = $(2) $(1)   foo = $(call reverse,a,b)`  foo will contain ‘b a\n\n### value函数\n```makefile\n$(value variable)\n```\nThe result of this function is a string containing the value of variable, without any expansion occurring. For example, in this makefile:\n```makefile\nFOO = $PATH\nall:\n    @echo $(FOO)\n    @echo $(value FOO)\n```\nThe first output line would be ATH, since the `$P` would be expanded as a make variable, while the second output line would be the current value of your $PATH environment variable, since the value function avoided the expansion.\n\n### realpath\n```makefile\n$(realpath ../../)\n```\n获取绝对路径\n\n### wildcard\n根据通配符获取列表\n```makefile\nsrc = $(wildcard *.c)\n```\n### origin函数\n```makefile\n$(origin variable)\n```\n获取变量的属性值，如下几个\n1. undefined 变量“VARIABLE”没有被定义。\n2. default 变量“VARIABLE”是一个默认定义（内嵌变量）。如“CC”、“MAKE”、“RM”等变 量。如果在 Makefile 中重新定义这些变量，函数返回值将相应发生变化\n3. environment 变量“VARIABLE”是一个系统环境变量，并且 make 没有使用命令行选项“-e” （Makefile 中不存在同名的变量定义，此变量没有被替代）。\n4. environment override 变量“VARIABLE”是一个系统环境变量，并且 make 使用了命令行选项“-e”。 Makefile 中存在一个同名的变量定义，使用“make -e”时环境变量值替代了文 件中的变量定义。\n5. file 变量“VARIABLE”在某一个 makefile 文件中定义。\n6. command line 变量“VARIABLE”在命令行中定义。\n7. override 变量“VARIABLE”在 makefile 文件中定义并使用“override”指示符声明。\n8. automatic 变量“VARIABLE”是自动化变量。\n### shell函数\n```makefile\ncontents := $(shell cat foo)\nfiles := $(shell echo *.c)\n```\n### make LOG以及控制函数\n```makefile\n$(info text)    #打印log\n$(warning text) #和 error 一样，但是 产生致命错误退出\n$(error text)   #产生致命错误，并提示“text”信息给用户，并退出 make 的执行\n```\n","source":"_posts/makefile.md","raw":"---\ntitle: 嵌入式笔记：Makefile学习\n---\n嵌入式笔记：Makefile学习\n\n# 目录\n\n## 简单的makefile\n```makefile\nCROSS_COMPILE=/opt/4.5.1/bin/arm-linux-\n\nCC=$(CROSS_COMPILE)gcc\nAS=$(CROSS_COMPILE)as\nLD=$(CROSS_COMPILE)ld\n\nCFLAGS=-g -Wall\nLIBS=-lpthread\n\nall:main\n\nmain:main.o gsm_gprs.o socket.o telosb.o wifi.o \n\t$(CC) $(CFLAGS) $(LIBS) $^ -o $@\n\nmain.o: main.c gsm_gprs.h option.h telosb.h\n\t$(CC) $(CFLAGS) -c $<\n\ngsm_gprs.o:gsm_gprs.c gsm_gprs.h socket.h\n\t$(CC) $(CFLAGS) -c $<\n\nsocket.o:socket.c socket.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\ntelosb.o: telosb.c telosb.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\nwifi.o: wifi.c wifi.h option.h\n\t$(CC) $(CFLAGS) -c $<\n\nclean:\n\t-rm main -f *\\.o *\\*~ *~\n```\n\n## makefile赋值\n|赋值|说明|\n|:-:|-|\n|`=`|基本的赋值 会在makefile的最后才赋值|\n|`:=`|覆盖之前的值 会立即赋值|\n|`?=`|如果没有赋值过就赋值|\n|`+=`|添加后面的值|\n\n## .PHONY : clean\n    伪目标\n\n## make命令默认支持的文件名\n> make指令如果没有指定具体的makefile文件，就会自动寻找如下的makefile文件\n\n<table>\n    <tr>\n        <td>GNUmakefile</td>\n        <td>makefile</td>\n        <td>Makefile</td>\n    <tr>\n</table>\n\n## include\n    makefile包含\n\n## -include\n    makefile包含，当include过程中出现错误，不报错继续执行\n\n## MAKEFILES\n    make会自动include这个环境变量中的值\n\n## VPATH\n    指定makefile文件搜寻路径\n\n## vpath\n    make 关键词 设置文件搜寻路径\n\n## Makefile内建函数\n\n### 文本处理和分析函数\n\n#### 替换\n```makefile\n$(subst from,to,text)\n```\n#### 模式替换\n> 可用%（只用第一个%有用），如 `$(patsubst %.c,%.o,x.c.c bar.c)`，结果 `‘x.c.o bar.o’`\n```makefile\n$(patsubst pattern,replacement,text) \n```\n#### 去掉文本两端空格，以及把2个和2个以上的空格换成一个\n```makefile\n$(strip string) \n```\n#### 查找\n```makefile\n$(findstring find,in)\n```\n#### 过滤\n> 只保留pattern部分\n```makefile\n$(filter pattern…,text)\n```\n#### 过滤掉\n> 不保留pattern部分\n```makefile\n$(filter-out pattern…,text)\n```\n#### 排序\n```makefile\n$(sort list)\n```\n#### 取字符串\n```makefile\n$(word n,text)\n```\n#### 取字符串列表\n> 第s(start)个到第e（end）个\n```makefile\n$(wordlist s,e,text)\n# $(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).\n```\n#### 取第一个\n```makefile\n$(firstword names…)\n```\n#### 取最后一个\n```makefile\n$(lastword names…)\n```\n### 文件名处理函数\n#### 取目录\n```makefile\n$(dir names…)\n```\n#### 取文件\n> 但并不完全正确，注意观察，因为这个原理是已斜杠“/”为标识符的，如果文件名中包含斜杠，则返回的文件名就有误\n```makefile\n$(notdir names…)\n```\n#### 取文件后缀\n```makefile\n$(suffix names…)\n```\n#### 取文件名\n> 包括前面的目录部分，如`$(basename src/foo.c src-1.0/bar hacks)`， 结果为`src/foo src-1.0/bar hacks`\n```makefile\n$(basename names…)\n```\n#### 添加后缀\n> example ：`$(addprefix src/,foo bar)`，produces the result `‘src/foo src/bar’`\n```makefile\n$(addsuffix suffix,names…)\n```\n#### 连接函数\n> example: ‘$(join a b,.c .o)’ produces ‘a.c b.o’.\n```makefile\n$(join list1,list2)\n```\n#### 通配符函数\n> 表示可以使用正则表达式的符号。The argument pattern is a file name pattern, typically containing wildcard characters (as in shell file name patterns). The result of wildcard is a space-separated list of the names of existing files that match the pattern\n```makefile\n$(wildcard pattern)\n```\n#### 真实路径\n```makefile\n$(realpath names…)\n```\n#### 绝对路径\n```makefile\n$(abspath names…)\n```\n\n### foreach函数\n`$(foreach var,list,text)`相当于for循环函数，不过最终这里返回的是text的值，这个值是循环得到的一个list，如\n```makefile\nfind_files = $(wildcard $(dir)/*) #“=”等号是延时加载（deferred）\ndirs := a b c d\nfiles := $(foreach dir,$(dirs),$(find_files))\n```\n即\n```makefile\nfiles := $(wildcard a/* b/* c/* d/*)\n```\n \n\n### if函数\n```makefile\nifeq (arg1, arg2)\nifneq (arg1, arg2)\nifdef variable-name\nifndef variable-name\n```\n### call函数\n```makefile\n$(call VARIABLE,PARAM,PARAM,...)\n```\n“call”函数是唯一一个可以创建定制化参数函数的引用函数。使用这个函数可以 实现对用户自己定义函数引用。我们可以将一个变量定义为一个复杂的表达式，用“call” 函数根据不同的参数对它进行展开来获得不同的结果。\n\n如：`reverse = $(2) $(1)   foo = $(call reverse,a,b)`  foo will contain ‘b a\n\n### value函数\n```makefile\n$(value variable)\n```\nThe result of this function is a string containing the value of variable, without any expansion occurring. For example, in this makefile:\n```makefile\nFOO = $PATH\nall:\n    @echo $(FOO)\n    @echo $(value FOO)\n```\nThe first output line would be ATH, since the `$P` would be expanded as a make variable, while the second output line would be the current value of your $PATH environment variable, since the value function avoided the expansion.\n\n### realpath\n```makefile\n$(realpath ../../)\n```\n获取绝对路径\n\n### wildcard\n根据通配符获取列表\n```makefile\nsrc = $(wildcard *.c)\n```\n### origin函数\n```makefile\n$(origin variable)\n```\n获取变量的属性值，如下几个\n1. undefined 变量“VARIABLE”没有被定义。\n2. default 变量“VARIABLE”是一个默认定义（内嵌变量）。如“CC”、“MAKE”、“RM”等变 量。如果在 Makefile 中重新定义这些变量，函数返回值将相应发生变化\n3. environment 变量“VARIABLE”是一个系统环境变量，并且 make 没有使用命令行选项“-e” （Makefile 中不存在同名的变量定义，此变量没有被替代）。\n4. environment override 变量“VARIABLE”是一个系统环境变量，并且 make 使用了命令行选项“-e”。 Makefile 中存在一个同名的变量定义，使用“make -e”时环境变量值替代了文 件中的变量定义。\n5. file 变量“VARIABLE”在某一个 makefile 文件中定义。\n6. command line 变量“VARIABLE”在命令行中定义。\n7. override 变量“VARIABLE”在 makefile 文件中定义并使用“override”指示符声明。\n8. automatic 变量“VARIABLE”是自动化变量。\n### shell函数\n```makefile\ncontents := $(shell cat foo)\nfiles := $(shell echo *.c)\n```\n### make LOG以及控制函数\n```makefile\n$(info text)    #打印log\n$(warning text) #和 error 一样，但是 产生致命错误退出\n$(error text)   #产生致命错误，并提示“text”信息给用户，并退出 make 的执行\n```\n","slug":"makefile","published":1,"date":"2018-02-28T01:21:06.219Z","updated":"2018-02-28T01:13:40.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbd00079vf7yo1t88m3","content":"<p>嵌入式笔记：Makefile学习</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"简单的makefile\"><a href=\"#简单的makefile\" class=\"headerlink\" title=\"简单的makefile\"></a>简单的makefile</h2><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">CROSS_COMPILE<span class=\"token operator\">=</span>/opt/4.5.1/bin/arm-linux-\n\nCC<span class=\"token operator\">=</span><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CROSS_COMPILE<span class=\"token punctuation\">)</span>gcc\nAS<span class=\"token operator\">=</span><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CROSS_COMPILE<span class=\"token punctuation\">)</span>as\nLD<span class=\"token operator\">=</span><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CROSS_COMPILE<span class=\"token punctuation\">)</span>ld\n\nCFLAGS<span class=\"token operator\">=</span>-g -Wall\nLIBS<span class=\"token operator\">=</span>-lpthread\n\n<span class=\"token symbol\">all</span><span class=\"token punctuation\">:</span>main\n\n<span class=\"token symbol\">main</span><span class=\"token punctuation\">:</span>main.o gsm_gprs.o socket.o telosb.o wifi.o \n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>LIBS<span class=\"token punctuation\">)</span> <span class=\"token variable\">$^</span> -o <span class=\"token variable\">$@</span>\n\n<span class=\"token symbol\">main.o</span><span class=\"token punctuation\">:</span> main.c gsm_gprs.h option.h telosb.h\n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> -c <span class=\"token variable\">$&lt;</span>\n\n<span class=\"token symbol\">gsm_gprs.o</span><span class=\"token punctuation\">:</span>gsm_gprs.c gsm_gprs.h socket.h\n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> -c <span class=\"token variable\">$&lt;</span>\n\n<span class=\"token symbol\">socket.o</span><span class=\"token punctuation\">:</span>socket.c socket.h option.h\n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> -c <span class=\"token variable\">$&lt;</span>\n\n<span class=\"token symbol\">telosb.o</span><span class=\"token punctuation\">:</span> telosb.c telosb.h option.h\n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> -c <span class=\"token variable\">$&lt;</span>\n\n<span class=\"token symbol\">wifi.o</span><span class=\"token punctuation\">:</span> wifi.c wifi.h option.h\n    <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CC<span class=\"token punctuation\">)</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>CFLAGS<span class=\"token punctuation\">)</span> -c <span class=\"token variable\">$&lt;</span>\n\n<span class=\"token symbol\">clean</span><span class=\"token punctuation\">:</span>\n    -rm main -f *\\.o *\\*~ *~\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"makefile赋值\"><a href=\"#makefile赋值\" class=\"headerlink\" title=\"makefile赋值\"></a>makefile赋值</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">赋值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>=</code></td>\n<td>基本的赋值 会在makefile的最后才赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>:=</code></td>\n<td>覆盖之前的值 会立即赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>?=</code></td>\n<td>如果没有赋值过就赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>+=</code></td>\n<td>添加后面的值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"PHONY-clean\"><a href=\"#PHONY-clean\" class=\"headerlink\" title=\".PHONY : clean\"></a>.PHONY : clean</h2><pre><code>伪目标\n</code></pre><h2 id=\"make命令默认支持的文件名\"><a href=\"#make命令默认支持的文件名\" class=\"headerlink\" title=\"make命令默认支持的文件名\"></a>make命令默认支持的文件名</h2><blockquote>\n<p>make指令如果没有指定具体的makefile文件，就会自动寻找如下的makefile文件</p>\n</blockquote>\n<table><br>    <tr><br>        <td>GNUmakefile</td><br>        <td>makefile</td><br>        <td>Makefile</td><br>    </tr><tr><br></tr></table>\n\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h2><pre><code>makefile包含\n</code></pre><h2 id=\"include-1\"><a href=\"#include-1\" class=\"headerlink\" title=\"-include\"></a>-include</h2><pre><code>makefile包含，当include过程中出现错误，不报错继续执行\n</code></pre><h2 id=\"MAKEFILES\"><a href=\"#MAKEFILES\" class=\"headerlink\" title=\"MAKEFILES\"></a>MAKEFILES</h2><pre><code>make会自动include这个环境变量中的值\n</code></pre><h2 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h2><pre><code>指定makefile文件搜寻路径\n</code></pre><h2 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h2><pre><code>make 关键词 设置文件搜寻路径\n</code></pre><h2 id=\"Makefile内建函数\"><a href=\"#Makefile内建函数\" class=\"headerlink\" title=\"Makefile内建函数\"></a>Makefile内建函数</h2><h3 id=\"文本处理和分析函数\"><a href=\"#文本处理和分析函数\" class=\"headerlink\" title=\"文本处理和分析函数\"></a>文本处理和分析函数</h3><h4 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">subst</span> from,to,text<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"模式替换\"><a href=\"#模式替换\" class=\"headerlink\" title=\"模式替换\"></a>模式替换</h4><blockquote>\n<p>可用%（只用第一个%有用），如 <code>$(patsubst %.c,%.o,x.c.c bar.c)</code>，结果 <code>‘x.c.o bar.o’</code></p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">patsubst</span> pattern,replacement,text<span class=\"token punctuation\">)</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"去掉文本两端空格，以及把2个和2个以上的空格换成一个\"><a href=\"#去掉文本两端空格，以及把2个和2个以上的空格换成一个\" class=\"headerlink\" title=\"去掉文本两端空格，以及把2个和2个以上的空格换成一个\"></a>去掉文本两端空格，以及把2个和2个以上的空格换成一个</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">strip</span> string<span class=\"token punctuation\">)</span> \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">findstring</span> find,in<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><blockquote>\n<p>只保留pattern部分</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">filter</span> pattern…,text<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"过滤掉\"><a href=\"#过滤掉\" class=\"headerlink\" title=\"过滤掉\"></a>过滤掉</h4><blockquote>\n<p>不保留pattern部分</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">filter-out</span> pattern…,text<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sort</span> list<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"取字符串\"><a href=\"#取字符串\" class=\"headerlink\" title=\"取字符串\"></a>取字符串</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">word</span> n,text<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"取字符串列表\"><a href=\"#取字符串列表\" class=\"headerlink\" title=\"取字符串列表\"></a>取字符串列表</h4><blockquote>\n<p>第s(start)个到第e（end）个<br><code>`</code>makefile<br>$(wordlist s,e,text)</p>\n</blockquote>\n<h1 id=\"words-text-Returns-the-number-of-words-in-text-Thus-the-last-word-of-text-is-word-words-text-text\"><a href=\"#words-text-Returns-the-number-of-words-in-text-Thus-the-last-word-of-text-is-word-words-text-text\" class=\"headerlink\" title=\"$(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).\"></a>$(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).</h1><pre><code>#### 取第一个\n```makefile\n$(firstword names…)\n</code></pre><h4 id=\"取最后一个\"><a href=\"#取最后一个\" class=\"headerlink\" title=\"取最后一个\"></a>取最后一个</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lastword</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"文件名处理函数\"><a href=\"#文件名处理函数\" class=\"headerlink\" title=\"文件名处理函数\"></a>文件名处理函数</h3><h4 id=\"取目录\"><a href=\"#取目录\" class=\"headerlink\" title=\"取目录\"></a>取目录</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">dir</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"取文件\"><a href=\"#取文件\" class=\"headerlink\" title=\"取文件\"></a>取文件</h4><blockquote>\n<p>但并不完全正确，注意观察，因为这个原理是已斜杠“/”为标识符的，如果文件名中包含斜杠，则返回的文件名就有误</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">notdir</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"取文件后缀\"><a href=\"#取文件后缀\" class=\"headerlink\" title=\"取文件后缀\"></a>取文件后缀</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">suffix</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"取文件名\"><a href=\"#取文件名\" class=\"headerlink\" title=\"取文件名\"></a>取文件名</h4><blockquote>\n<p>包括前面的目录部分，如<code>$(basename src/foo.c src-1.0/bar hacks)</code>， 结果为<code>src/foo src-1.0/bar hacks</code></p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">basename</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"添加后缀\"><a href=\"#添加后缀\" class=\"headerlink\" title=\"添加后缀\"></a>添加后缀</h4><blockquote>\n<p>example ：<code>$(addprefix src/,foo bar)</code>，produces the result <code>‘src/foo src/bar’</code></p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">addsuffix</span> suffix,names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"连接函数\"><a href=\"#连接函数\" class=\"headerlink\" title=\"连接函数\"></a>连接函数</h4><blockquote>\n<p>example: ‘$(join a b,.c .o)’ produces ‘a.c b.o’.</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">join</span> list1,list2<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"通配符函数\"><a href=\"#通配符函数\" class=\"headerlink\" title=\"通配符函数\"></a>通配符函数</h4><blockquote>\n<p>表示可以使用正则表达式的符号。The argument pattern is a file name pattern, typically containing wildcard characters (as in shell file name patterns). The result of wildcard is a space-separated list of the names of existing files that match the pattern</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">wildcard</span> pattern<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h4 id=\"真实路径\"><a href=\"#真实路径\" class=\"headerlink\" title=\"真实路径\"></a>真实路径</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">realpath</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h4><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">abspath</span> names…<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"foreach函数\"><a href=\"#foreach函数\" class=\"headerlink\" title=\"foreach函数\"></a>foreach函数</h3><p><code>$(foreach var,list,text)</code>相当于for循环函数，不过最终这里返回的是text的值，这个值是循环得到的一个list，如</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">find_files <span class=\"token operator\">=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">wildcard</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>dir<span class=\"token punctuation\">)</span>/*<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">#“=”等号是延时加载（deferred）</span>\ndirs <span class=\"token operator\">:=</span> a b c d\nfiles <span class=\"token operator\">:=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">foreach</span> dir,<span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>dirs<span class=\"token punctuation\">)</span>,<span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>find_files<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>即</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">files <span class=\"token operator\">:=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">wildcard</span> a/* b/* c/* d/*<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"if函数\"><a href=\"#if函数\" class=\"headerlink\" title=\"if函数\"></a>if函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token keyword\">ifeq</span> <span class=\"token punctuation\">(</span>arg1, arg2<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">ifneq</span> <span class=\"token punctuation\">(</span>arg1, arg2<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">ifdef</span> variable-name\n<span class=\"token keyword\">ifndef</span> variable-name\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"call函数\"><a href=\"#call函数\" class=\"headerlink\" title=\"call函数\"></a>call函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">call</span> VARIABLE,PARAM,PARAM,...<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>“call”函数是唯一一个可以创建定制化参数函数的引用函数。使用这个函数可以 实现对用户自己定义函数引用。我们可以将一个变量定义为一个复杂的表达式，用“call” 函数根据不同的参数对它进行展开来获得不同的结果。</p>\n<p>如：<code>reverse = $(2) $(1)   foo = $(call reverse,a,b)</code>  foo will contain ‘b a</p>\n<h3 id=\"value函数\"><a href=\"#value函数\" class=\"headerlink\" title=\"value函数\"></a>value函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span> variable<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>The result of this function is a string containing the value of variable, without any expansion occurring. For example, in this makefile:</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">FOO <span class=\"token operator\">=</span> <span class=\"token variable\">$PATH</span>\n<span class=\"token symbol\">all</span><span class=\"token punctuation\">:</span>\n    <span class=\"token operator\">@</span>echo <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span>FOO<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">@</span>echo <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">value</span> FOO<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>The first output line would be ATH, since the <code>$P</code> would be expanded as a make variable, while the second output line would be the current value of your $PATH environment variable, since the value function avoided the expansion.</p>\n<h3 id=\"realpath\"><a href=\"#realpath\" class=\"headerlink\" title=\"realpath\"></a>realpath</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">realpath</span> ../../<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>获取绝对路径</p>\n<h3 id=\"wildcard\"><a href=\"#wildcard\" class=\"headerlink\" title=\"wildcard\"></a>wildcard</h3><p>根据通配符获取列表</p>\n<pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">src <span class=\"token operator\">=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">wildcard</span> *.c<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"origin函数\"><a href=\"#origin函数\" class=\"headerlink\" title=\"origin函数\"></a>origin函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">origin</span> variable<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>获取变量的属性值，如下几个</p>\n<ol>\n<li>undefined 变量“VARIABLE”没有被定义。</li>\n<li>default 变量“VARIABLE”是一个默认定义（内嵌变量）。如“CC”、“MAKE”、“RM”等变 量。如果在 Makefile 中重新定义这些变量，函数返回值将相应发生变化</li>\n<li>environment 变量“VARIABLE”是一个系统环境变量，并且 make 没有使用命令行选项“-e” （Makefile 中不存在同名的变量定义，此变量没有被替代）。</li>\n<li>environment override 变量“VARIABLE”是一个系统环境变量，并且 make 使用了命令行选项“-e”。 Makefile 中存在一个同名的变量定义，使用“make -e”时环境变量值替代了文 件中的变量定义。</li>\n<li>file 变量“VARIABLE”在某一个 makefile 文件中定义。</li>\n<li>command line 变量“VARIABLE”在命令行中定义。</li>\n<li>override 变量“VARIABLE”在 makefile 文件中定义并使用“override”指示符声明。</li>\n<li>automatic 变量“VARIABLE”是自动化变量。<h3 id=\"shell函数\"><a href=\"#shell函数\" class=\"headerlink\" title=\"shell函数\"></a>shell函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\">contents <span class=\"token operator\">:=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">shell</span> cat foo<span class=\"token punctuation\">)</span>\nfiles <span class=\"token operator\">:=</span> <span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">shell</span> echo *.c<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"make-LOG以及控制函数\"><a href=\"#make-LOG以及控制函数\" class=\"headerlink\" title=\"make LOG以及控制函数\"></a>make LOG以及控制函数</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">info</span> text<span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\">#打印log</span>\n<span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">warning</span> text<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">#和 error 一样，但是 产生致命错误退出</span>\n<span class=\"token variable\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">error</span> text<span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">#产生致命错误，并提示“text”信息给用户，并退出 make 的执行</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：Makefile学习</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><h2 id=\"简单的makefile\"><a href=\"#简单的makefile\" class=\"headerlink\" title=\"简单的makefile\"></a>简单的makefile</h2><pre><code class=\"makefile\">CROSS_COMPILE=/opt/4.5.1/bin/arm-linux-\n\nCC=$(CROSS_COMPILE)gcc\nAS=$(CROSS_COMPILE)as\nLD=$(CROSS_COMPILE)ld\n\nCFLAGS=-g -Wall\nLIBS=-lpthread\n\nall:main\n\nmain:main.o gsm_gprs.o socket.o telosb.o wifi.o \n    $(CC) $(CFLAGS) $(LIBS) $^ -o $@\n\nmain.o: main.c gsm_gprs.h option.h telosb.h\n    $(CC) $(CFLAGS) -c $&lt;\n\ngsm_gprs.o:gsm_gprs.c gsm_gprs.h socket.h\n    $(CC) $(CFLAGS) -c $&lt;\n\nsocket.o:socket.c socket.h option.h\n    $(CC) $(CFLAGS) -c $&lt;\n\ntelosb.o: telosb.c telosb.h option.h\n    $(CC) $(CFLAGS) -c $&lt;\n\nwifi.o: wifi.c wifi.h option.h\n    $(CC) $(CFLAGS) -c $&lt;\n\nclean:\n    -rm main -f *\\.o *\\*~ *~\n</code></pre>\n<h2 id=\"makefile赋值\"><a href=\"#makefile赋值\" class=\"headerlink\" title=\"makefile赋值\"></a>makefile赋值</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">赋值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>=</code></td>\n<td>基本的赋值 会在makefile的最后才赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>:=</code></td>\n<td>覆盖之前的值 会立即赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>?=</code></td>\n<td>如果没有赋值过就赋值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>+=</code></td>\n<td>添加后面的值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"PHONY-clean\"><a href=\"#PHONY-clean\" class=\"headerlink\" title=\".PHONY : clean\"></a>.PHONY : clean</h2><pre><code>伪目标\n</code></pre><h2 id=\"make命令默认支持的文件名\"><a href=\"#make命令默认支持的文件名\" class=\"headerlink\" title=\"make命令默认支持的文件名\"></a>make命令默认支持的文件名</h2><blockquote>\n<p>make指令如果没有指定具体的makefile文件，就会自动寻找如下的makefile文件</p>\n</blockquote>\n<table><br>    <tr><br>        <td>GNUmakefile</td><br>        <td>makefile</td><br>        <td>Makefile</td><br>    </tr><tr><br></tr></table>\n\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h2><pre><code>makefile包含\n</code></pre><h2 id=\"include-1\"><a href=\"#include-1\" class=\"headerlink\" title=\"-include\"></a>-include</h2><pre><code>makefile包含，当include过程中出现错误，不报错继续执行\n</code></pre><h2 id=\"MAKEFILES\"><a href=\"#MAKEFILES\" class=\"headerlink\" title=\"MAKEFILES\"></a>MAKEFILES</h2><pre><code>make会自动include这个环境变量中的值\n</code></pre><h2 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h2><pre><code>指定makefile文件搜寻路径\n</code></pre><h2 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h2><pre><code>make 关键词 设置文件搜寻路径\n</code></pre><h2 id=\"Makefile内建函数\"><a href=\"#Makefile内建函数\" class=\"headerlink\" title=\"Makefile内建函数\"></a>Makefile内建函数</h2><h3 id=\"文本处理和分析函数\"><a href=\"#文本处理和分析函数\" class=\"headerlink\" title=\"文本处理和分析函数\"></a>文本处理和分析函数</h3><h4 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h4><pre><code class=\"makefile\">$(subst from,to,text)\n</code></pre>\n<h4 id=\"模式替换\"><a href=\"#模式替换\" class=\"headerlink\" title=\"模式替换\"></a>模式替换</h4><blockquote>\n<p>可用%（只用第一个%有用），如 <code>$(patsubst %.c,%.o,x.c.c bar.c)</code>，结果 <code>‘x.c.o bar.o’</code></p>\n<pre><code class=\"makefile\">$(patsubst pattern,replacement,text) \n</code></pre>\n</blockquote>\n<h4 id=\"去掉文本两端空格，以及把2个和2个以上的空格换成一个\"><a href=\"#去掉文本两端空格，以及把2个和2个以上的空格换成一个\" class=\"headerlink\" title=\"去掉文本两端空格，以及把2个和2个以上的空格换成一个\"></a>去掉文本两端空格，以及把2个和2个以上的空格换成一个</h4><pre><code class=\"makefile\">$(strip string) \n</code></pre>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><pre><code class=\"makefile\">$(findstring find,in)\n</code></pre>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><blockquote>\n<p>只保留pattern部分</p>\n<pre><code class=\"makefile\">$(filter pattern…,text)\n</code></pre>\n</blockquote>\n<h4 id=\"过滤掉\"><a href=\"#过滤掉\" class=\"headerlink\" title=\"过滤掉\"></a>过滤掉</h4><blockquote>\n<p>不保留pattern部分</p>\n<pre><code class=\"makefile\">$(filter-out pattern…,text)\n</code></pre>\n</blockquote>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><pre><code class=\"makefile\">$(sort list)\n</code></pre>\n<h4 id=\"取字符串\"><a href=\"#取字符串\" class=\"headerlink\" title=\"取字符串\"></a>取字符串</h4><pre><code class=\"makefile\">$(word n,text)\n</code></pre>\n<h4 id=\"取字符串列表\"><a href=\"#取字符串列表\" class=\"headerlink\" title=\"取字符串列表\"></a>取字符串列表</h4><blockquote>\n<p>第s(start)个到第e（end）个<br><code>`</code>makefile<br>$(wordlist s,e,text)</p>\n</blockquote>\n<h1 id=\"words-text-Returns-the-number-of-words-in-text-Thus-the-last-word-of-text-is-word-words-text-text\"><a href=\"#words-text-Returns-the-number-of-words-in-text-Thus-the-last-word-of-text-is-word-words-text-text\" class=\"headerlink\" title=\"$(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).\"></a>$(words text) Returns the number of words in text. Thus, the last word of text is $(word $(words text),text).</h1><pre><code>#### 取第一个\n```makefile\n$(firstword names…)\n</code></pre><h4 id=\"取最后一个\"><a href=\"#取最后一个\" class=\"headerlink\" title=\"取最后一个\"></a>取最后一个</h4><pre><code class=\"makefile\">$(lastword names…)\n</code></pre>\n<h3 id=\"文件名处理函数\"><a href=\"#文件名处理函数\" class=\"headerlink\" title=\"文件名处理函数\"></a>文件名处理函数</h3><h4 id=\"取目录\"><a href=\"#取目录\" class=\"headerlink\" title=\"取目录\"></a>取目录</h4><pre><code class=\"makefile\">$(dir names…)\n</code></pre>\n<h4 id=\"取文件\"><a href=\"#取文件\" class=\"headerlink\" title=\"取文件\"></a>取文件</h4><blockquote>\n<p>但并不完全正确，注意观察，因为这个原理是已斜杠“/”为标识符的，如果文件名中包含斜杠，则返回的文件名就有误</p>\n<pre><code class=\"makefile\">$(notdir names…)\n</code></pre>\n</blockquote>\n<h4 id=\"取文件后缀\"><a href=\"#取文件后缀\" class=\"headerlink\" title=\"取文件后缀\"></a>取文件后缀</h4><pre><code class=\"makefile\">$(suffix names…)\n</code></pre>\n<h4 id=\"取文件名\"><a href=\"#取文件名\" class=\"headerlink\" title=\"取文件名\"></a>取文件名</h4><blockquote>\n<p>包括前面的目录部分，如<code>$(basename src/foo.c src-1.0/bar hacks)</code>， 结果为<code>src/foo src-1.0/bar hacks</code></p>\n<pre><code class=\"makefile\">$(basename names…)\n</code></pre>\n</blockquote>\n<h4 id=\"添加后缀\"><a href=\"#添加后缀\" class=\"headerlink\" title=\"添加后缀\"></a>添加后缀</h4><blockquote>\n<p>example ：<code>$(addprefix src/,foo bar)</code>，produces the result <code>‘src/foo src/bar’</code></p>\n<pre><code class=\"makefile\">$(addsuffix suffix,names…)\n</code></pre>\n</blockquote>\n<h4 id=\"连接函数\"><a href=\"#连接函数\" class=\"headerlink\" title=\"连接函数\"></a>连接函数</h4><blockquote>\n<p>example: ‘$(join a b,.c .o)’ produces ‘a.c b.o’.</p>\n<pre><code class=\"makefile\">$(join list1,list2)\n</code></pre>\n</blockquote>\n<h4 id=\"通配符函数\"><a href=\"#通配符函数\" class=\"headerlink\" title=\"通配符函数\"></a>通配符函数</h4><blockquote>\n<p>表示可以使用正则表达式的符号。The argument pattern is a file name pattern, typically containing wildcard characters (as in shell file name patterns). The result of wildcard is a space-separated list of the names of existing files that match the pattern</p>\n<pre><code class=\"makefile\">$(wildcard pattern)\n</code></pre>\n</blockquote>\n<h4 id=\"真实路径\"><a href=\"#真实路径\" class=\"headerlink\" title=\"真实路径\"></a>真实路径</h4><pre><code class=\"makefile\">$(realpath names…)\n</code></pre>\n<h4 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h4><pre><code class=\"makefile\">$(abspath names…)\n</code></pre>\n<h3 id=\"foreach函数\"><a href=\"#foreach函数\" class=\"headerlink\" title=\"foreach函数\"></a>foreach函数</h3><p><code>$(foreach var,list,text)</code>相当于for循环函数，不过最终这里返回的是text的值，这个值是循环得到的一个list，如</p>\n<pre><code class=\"makefile\">find_files = $(wildcard $(dir)/*) #“=”等号是延时加载（deferred）\ndirs := a b c d\nfiles := $(foreach dir,$(dirs),$(find_files))\n</code></pre>\n<p>即</p>\n<pre><code class=\"makefile\">files := $(wildcard a/* b/* c/* d/*)\n</code></pre>\n<h3 id=\"if函数\"><a href=\"#if函数\" class=\"headerlink\" title=\"if函数\"></a>if函数</h3><pre><code class=\"makefile\">ifeq (arg1, arg2)\nifneq (arg1, arg2)\nifdef variable-name\nifndef variable-name\n</code></pre>\n<h3 id=\"call函数\"><a href=\"#call函数\" class=\"headerlink\" title=\"call函数\"></a>call函数</h3><pre><code class=\"makefile\">$(call VARIABLE,PARAM,PARAM,...)\n</code></pre>\n<p>“call”函数是唯一一个可以创建定制化参数函数的引用函数。使用这个函数可以 实现对用户自己定义函数引用。我们可以将一个变量定义为一个复杂的表达式，用“call” 函数根据不同的参数对它进行展开来获得不同的结果。</p>\n<p>如：<code>reverse = $(2) $(1)   foo = $(call reverse,a,b)</code>  foo will contain ‘b a</p>\n<h3 id=\"value函数\"><a href=\"#value函数\" class=\"headerlink\" title=\"value函数\"></a>value函数</h3><pre><code class=\"makefile\">$(value variable)\n</code></pre>\n<p>The result of this function is a string containing the value of variable, without any expansion occurring. For example, in this makefile:</p>\n<pre><code class=\"makefile\">FOO = $PATH\nall:\n    @echo $(FOO)\n    @echo $(value FOO)\n</code></pre>\n<p>The first output line would be ATH, since the <code>$P</code> would be expanded as a make variable, while the second output line would be the current value of your $PATH environment variable, since the value function avoided the expansion.</p>\n<h3 id=\"realpath\"><a href=\"#realpath\" class=\"headerlink\" title=\"realpath\"></a>realpath</h3><pre><code class=\"makefile\">$(realpath ../../)\n</code></pre>\n<p>获取绝对路径</p>\n<h3 id=\"wildcard\"><a href=\"#wildcard\" class=\"headerlink\" title=\"wildcard\"></a>wildcard</h3><p>根据通配符获取列表</p>\n<pre><code class=\"makefile\">src = $(wildcard *.c)\n</code></pre>\n<h3 id=\"origin函数\"><a href=\"#origin函数\" class=\"headerlink\" title=\"origin函数\"></a>origin函数</h3><pre><code class=\"makefile\">$(origin variable)\n</code></pre>\n<p>获取变量的属性值，如下几个</p>\n<ol>\n<li>undefined 变量“VARIABLE”没有被定义。</li>\n<li>default 变量“VARIABLE”是一个默认定义（内嵌变量）。如“CC”、“MAKE”、“RM”等变 量。如果在 Makefile 中重新定义这些变量，函数返回值将相应发生变化</li>\n<li>environment 变量“VARIABLE”是一个系统环境变量，并且 make 没有使用命令行选项“-e” （Makefile 中不存在同名的变量定义，此变量没有被替代）。</li>\n<li>environment override 变量“VARIABLE”是一个系统环境变量，并且 make 使用了命令行选项“-e”。 Makefile 中存在一个同名的变量定义，使用“make -e”时环境变量值替代了文 件中的变量定义。</li>\n<li>file 变量“VARIABLE”在某一个 makefile 文件中定义。</li>\n<li>command line 变量“VARIABLE”在命令行中定义。</li>\n<li>override 变量“VARIABLE”在 makefile 文件中定义并使用“override”指示符声明。</li>\n<li>automatic 变量“VARIABLE”是自动化变量。<h3 id=\"shell函数\"><a href=\"#shell函数\" class=\"headerlink\" title=\"shell函数\"></a>shell函数</h3><pre><code class=\"makefile\">contents := $(shell cat foo)\nfiles := $(shell echo *.c)\n</code></pre>\n<h3 id=\"make-LOG以及控制函数\"><a href=\"#make-LOG以及控制函数\" class=\"headerlink\" title=\"make LOG以及控制函数\"></a>make LOG以及控制函数</h3><pre><code class=\"makefile\">$(info text)    #打印log\n$(warning text) #和 error 一样，但是 产生致命错误退出\n$(error text)   #产生致命错误，并提示“text”信息给用户，并退出 make 的执行\n</code></pre>\n</li>\n</ol>\n"},{"title":"嵌入式笔记：linux软件开发","_content":"嵌入式笔记：linux软件开发\n\n# 目录\n* [关键命令说明](#关键命令说明)\n    * [系统关机命令](#系统关机命令)\n    * [linux查看文本的指令](#linux查看文本的指令)\n    * [mount](#mount指令)\n    * [dmesg](#dmesg)\n    * [grep](#grep)\n    * [find](#find)\n    * [lsusb](#lsusb)\n    * [lsof](#lsof)\n* [linux软件开发知识点](#linux软件开发知识点)\n    * [linux进程间通讯方式](#linux进程间通讯方式)\n    * [内存申请函数](#内存申请函数)\n    * [gcc编译过程](#gcc编译过程)\n    * [文件系统](#文件系统)\n    * [硬链接和软连接](#硬链接和软连接)\n    * [linux内核子系统](#linux内核子系统)\n    * [进程几种状态](#进程几种状态)\n    * [文件系统组成](#文件系统组成)\n    * [linux文件类型](#linux文件类型)\n    * [linux常用的系统调用函数](#linux常用的系统调用函数)\n    * [fork函数](#fork函数)\n    * [僵尸进程](#僵尸进程)\n    * [常见文件说明](#常见文件说明)\n    * [/proc目录说明](#/proc目录说明)\n    * [fopen参数说明](#fopen参数说明)\n* [linux驱动开发知识点](#linux驱动开发知识点)\n* [makefile](#makefile)\n* [shell](#shell)\n\n## 关键命令说明\n* [系统关机命令](#系统关机命令)\n* [linux查看文本的指令](#linux查看文本的指令)\n* [mount](#mount指令)\n* [dmesg](#dmesg)\n* [grep](#grep)\n* [find](#find)\n* [lsusb](#lsusb)\n* [lsof](#lsof)\n\n### 系统关机命令\n|指令|说明|\n|:-:|----|\n|shutdown | 命令安全地将系统关机。|\n|halt     | 就是调用shutdown -h。|\n|reboot   | 工作过程差不多跟halt一样﹐不过它是引发主机重启|\n|poweroff | 就是halt的软链接而已|\n|init     | 所有进程的祖先﹐它的进程号始终为1﹐init 0为关机﹐init1为重启。|\n\n### linux查看文本的指令\n<table style=\"text-align:center\">\n   <tr>\n      <td>cat</td>\n      <td>tac</td>\n      <td>sed</td>\n      <td>head</td>\n      <td>tail</td>\n      <td>more</td>\n      <td>less</td>\n      <td>nl</td>\n   </tr>\n</table>\n\n> <strong>tac</strong>： cat的反向指令，从最后一行倒序显示全部内容\n> <strong>head</strong>： 只显示头几行\n> <strong>tail</strong>： 只显示最后几行 tail -f 可以实时显示log文件的更新\n> <strong>nl</strong>： 类似于cat -n，显示时输出行号\n\n### mount\n命令格式：\n```sh\nmount [-t vfstype] [-o options] device dir\n```\n挂载nfs\n```sh\nmount -t nfs 192.168.0.1:/tmp /mnt/nfs \n```\n### dmesg\n```sh\ncat /var/log/messages\n```\n\n### grep\n选项\n```sh\n-c：只输出匹配行的计数。\n-C：匹配的上下文分别显示[number]行。\n-I：不区分大小写(只适用于单字符)。\n-i：不区分大小写。\n-h：查询多文件时不显示文件名。\n-l：查询多文件时只输出包含匹配字符的文件名。\n-L：列出不匹配的文件名。\n-n：显示匹配行及 行号。\n-s：不显示不存在或无匹配文本的错误信息。\n-v：显示不包含匹配文本的所有行。\n-w：只匹配整个单词。\n-E：扩展的正则表达式\n-R：递归搜寻\n--exclude=FILE：跳过FILE\n```\n正则表达式主要参数：\n\t\\：忽略正则表达式中特殊字符的原有含义。\n\t^：匹配正则表达式的开始行。\n\t$：匹配正则表达式的结束行。\n\t\\<：从匹配正则表达式的行开始。\n\t\\>：到匹配正则表达式的行结束。\n\t[]：单个字符，如[A]即A符合要求 。\n\t[-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。\n\t.：所有的单个字符。\n\t*：有字符，长度可以为0。\n\n\n经典使用方法\n```sh\n#所有以d开头的文件，包含test的匹配行\ngrep \"test\" d*\n#包含test或者zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -inE \"test|zephyr\" d*\n#包含test和zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -in \"test\" d* | grep 'zephyr'\n```\n\n主要参数：\n\t－c：只输出匹配行的计数。\n\t－I：不区分大小写(只适用于单字符)。\n\t－h：查询多文件时不显示文件名。\n\t－l：查询多文件时只输出包含匹配字符的文件名。\n\t－L：列出不匹配的文件名\n\t－n：显示匹配行及行号。\n\t－s：不显示不存在或无匹配文本的错误信息。\n\t－v：显示不包含匹配文本的所有行。\n\t－R：递归搜寻\n\t－d skip：不递归搜寻\n\t－w：匹配整个单词\n正则表达式主要参数：\n\t\\：忽略正则表达式中特殊字符的原有含义。\n\t^：匹配正则表达式的开始行。\n\t$：匹配正则表达式的结束行。\n\t\\<：从匹配正则表达式的行开始。\n\t\\>：到匹配正则表达式的行结束。\n\t[]：单个字符，如[A]即A符合要求 。\n\t[-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。\n\t.：所有的单个字符。\n\t*：有字符，长度可以为0。\n\ngrep 'test' d*\t\t显示以d开头的文件中包含的test行\ngrep 'test' aa bb cc \t查找文件aa bb cc 中匹配的test行\ngrep 'test'|'hello' files 匹配test或者hello\ngrep '\\<man' files\t匹配manic 和man 不匹配batman\ngrep '\\<man\\>'\t\t只匹配man 不匹配batman和manic\ngrep '^man' files\t匹配的字符行首\ngrep '$man' files\t匹配的字符串仔行尾\n\n### find\n用法\n```sh\nfind [-path ..] [expression]\n```\n选项\n```sh\n-name     按照文件名\n-iname     按照文件名 忽略大小写\n-perm     按照文件权限\n-user     按照文件拥有者\n-group    按照文件所属的组\n-mtime -n +n 按照文件的更改时间来查找文件， -n：n天以内，+n：n天以前\n-type     查找某一类型：文件类型有：普通文件(f)，目录(d)，字符设备文件(c)，块设备文件(b)，符号链接文件(l)，套接字文件(s)，管道文件(p)\n-size n   查找文件长度为n块（一块等于512字节）的文件，带有c时表示文件长度以字节计。 \n-mount    不跨越文件系统\n-follow   遇到符号链接文件，就跟踪至链接所指向的文件\n-path     匹配文件路径或者文件\n-exec     执行后续命令操作\n-a        and 与操作\n-o        or  或操作\n-not      not 非操作\n```\n经典使用方法\n```sh\n#查找/run中所有的socket文件\nfind /run -type s\n#搜索/dev中所有包含tty的文件\nfind /dev -name \"*tty*\"\n#搜索/dev中大小大于10字节，名称包含bus的文件\nfind /dev -size +10c -name \"*bus*\"\n#或操作，搜索debug开头的文件或者.rst的文件\nfind -name 'debug*' -o -name '*.rst'\n#与操作，搜索debug开头的文件同时是.rst的文件\nfind -name 'debug*' -a -name '*.rst'\n#找出文件大小大于10000块的文件，并复制到当前目录\nfind -size +100000 -exec cp {} . \\;\n```\n### lsusb\n显示系统中以及连接到系统的USB总线信息的工具。\n```sh\n$ lsusb\n\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 002 Device 003: ID 17ef:4811 Lenovo Integrated Webcam [R5U877]\nBus 008 Device 002: ID 0a5c:217f Broadcom Corp. Bluetooth Controller\n```\n> Bus 008 : 指明设备连接到哪（哪条总线）\n> Device 002 : 表明这是连接到总线上的第二台设备\n> ID : 设备的ID\n> Broadcom Corp. Bluetooth Controller :生产商名字和设备名\n\n列出USB详细信息\n```sh\n$ lsusb -v\n```\n列出有多少USB设备\n```sh\n$ find /dev/bus\n```\n打印特定设备的详细信息\n```sh\n$ lsusb -D /dev/bus/usb/008/002\n```\n### lsof\n列出当前系统打开文件的工具\n```sh\n$ sudo lsof\nCOMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAME\ninit       1         root  cwd      DIR       3,3       1024       2         /\ninit       1         root  rtd      DIR       3,3       1024       2         /\ninit       1         root  txt      REG       3,3       38432      1763452  /sbin/init\ninit       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.so\ninit       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.so\ninit       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1\ninit       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1\ninit       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.so\ninit       1         root  10u      FIFO      0,15                  1309     /dev/initctl\n```\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>COMMAND</td>\n      <td>进程的名称</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>PID</td>\n      <td>进程标识符</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>USER</td>\n      <td>进程所有者</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>FD</td>\n      <td>文件描述符</td>\n      <td>应用程序通过文件描述符识别该文件。如cwd、txt、mem等</td>\n   </tr>\n   <tr>\n      <td>TYPE</td>\n      <td>文件类型</td>\n      <td>REG(文件) DIR(目录) CHR(字符) BLK(块设备) FIFO(管道) UNIX(UNIX 域套接字) IPv4(IP套接字)</td>\n   </tr>\n   <tr>\n      <td>DEVICE</td>\n      <td>指定磁盘的名称</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>SIZE</td>\n      <td>文件大小</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>NODE</td>\n      <td>文件inode</td>\n      <td>每个文件都有一个唯一的inode</td>\n   </tr>\n   <tr>\n      <td>NAME</td>\n      <td>文件名称</td>\n      <td></td>\n   </tr>\n</table>\n\n参数列表\n```sh\nlsof  filename      显示打开指定文件的所有进程\nlsof -a             表示两个参数都必须满足时才显示结果\nlsof -c string      显示COMMAND列中包含指定字符的进程所有打开的文件\nlsof -u username    显示所属user进程打开的文件\nlsof -g gid         显示归属gid的进程情况\nlsof +d /DIR/       显示目录下被进程打开的文件\nlsof +D /DIR/       同上，但是会搜索目录下的所有目录，时间相对较长\nlsof -d FD          显示指定文件描述符的进程\nlsof -n             不将IP转换为hostname，缺省是不加上-n参数\nlsof -i             用以显示符合条件的进程情况\nlsof -i[46] [protocol][@hostname|hostaddr][:service|port]\n                    46 --> IPv4 or IPv6\n                    protocol --> TCP or UDP\n                    hostname --> Internet host name\n                    hostaddr --> IPv4地址\n                    service --> /etc/service中的 service name (可以不只一个)\n                    port --> 端口号 (可以不只一个)\n```\n查找应用程序打开的文件的名称和数目\n```sh\n#显示打开指定文件的所有进程\n$ lsof  filename\n#例如:打开所有使用/dev/urandom的进程\n$ lsof /dev/urandom\n#查看22端口现在运行的情况 \n$ lsof -i :22\n#查看所属xiaxiaowen用户进程所打开的文件类型为txt的文件\n$ lsof -a -u xiaxiaowen -d txt\n#查找谁在使用文件系统\n$ lsof /media/xiaxiaowen/机械硬盘\nCOMMAND  PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nzsh     8465 xiaxiaowen  cwd    DIR   8,17     8192    5 /media/xiaxiaowen/机械硬盘\n```\n\n## linux软件开发知识点\n* [linux进程间通讯方式](#linux进程间通讯方式)\n* [内存申请函数](#内存申请函数)\n* [linux内存分配说明](#linux内存分配说明)\n* [gcc编译过程](#gcc编译过程)\n* [文件系统](#文件系统)\n* [硬链接和软连接](#硬链接和软连接)\n* [linux内核子系统](#linux内核子系统)\n* [进程几种状态](#进程几种状态)\n* [文件系统组成](#文件系统组成)\n* [linux文件类型](#linux文件类型)\n* [linux常用的系统调用函数](#linux常用的系统调用函数)\n* [fork函数](#fork函数)\n* [僵尸进程](#僵尸进程)\n* [常见文件说明](#常见文件说明)\n* [proc目录说明](#proc目录说明)\n* [fopen参数说明](#fopen参数说明)\n\n### linux进程间通讯方式\n1. 管道（Pipe）及有名管道（named pipe）\n2. 信号（Signal）\n3. 报文（Message）队列（消息队列）：\n4. 共享内存\n5. 信号量（semaphore）\n6. 套接口（Socket）\n\n### 内存申请函数\n1. calloc\n2. malloc\n3. realloc\n### linux内存分配说明\n|内存|存放数据|说明\n|:---:|---|---|\n|静态存储区|静态数据、全局数据、常量|在程序编译的时候就已经分配好|\n|栈区     |局部变量、函数参数|栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限|\n|堆区     |malloc申请的内存|动态内存分配,需要手动释放|\n|代码区    |代码|存放函数体的二进制代码|\n|文字常量区|常量字符串|程序结束后由系统释放|\n### gcc编译过程\n\n<table style=\"text-align:center\">\n   <tr>\n      <td><strong>过程</td>\n      <td><strong>生成文件</td>\n   </tr>\n   <tr>\n      <td>预编译</td>\n      <td>*.i</td>\n   </tr>\n   <tr>\n      <td>编译</td>\n      <td>*.s</td>\n   </tr>\n   <tr>\n      <td>汇编</td>\n      <td>*.o</td>\n   </tr>\n   <tr>\n      <td>链接</td>\n      <td>可执行文件</td>\n   </tr>\n</table>\n\n### 文件系统\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>fat</td>\n      <td>fat32</td>\n      <td>ntfs</td>\n      <td>ext2</td>\n      <td>ext3</td>\n      <td>ext4</td>\n      <td>nfs</td>\n   </tr>\n</table>\n\n### 硬链接和软连接\n#### 硬链接\n* 硬链接直接指向文件的i节点\n* 硬链接和原文件的i节点是一样的\n* 硬链接文件显示的大小是跟原文件是一样的\n* 硬链接不能链接目录文件。\n```sh\nln file2 /home/xiaxiaowen/file2hard\n```\n#### 软链接(符号链接)\n* 软链接则是建立了一个新文件\n* 这个文件指向链接的文件，i节点不一样\n* 可以链接目录\n```sh\nln -s file2 /home/xiaxiaowen/file2soft\n```\n\n### linux内核子系统\n1. 进程管理\n2. 内存管理\n3. I/O管理\n4. 文件系统管理\n\n### 进程几种状态\n1. 运行态\n2. 就绪态\n3. 阻塞态\n\n### 文件系统组成\n1. <strong>超级块</strong>：存放文件系统本身的信息，比如记录了每个区域的大小，或未被使用的磁盘块的信息。（不同版本稍有差别）\n2. <strong>i-节点表</strong>：每个文件都有其属性，大小，最近修改时间等等，这些被存储在ino_t 的结构体中，所有的i-节点都有一样的大小，i-节点表就是这样一些节点的列表。（表中的每个i-节点都通过位置来标志，例如标志为2的i-节点位于文件系统i-节点表中的第3个位置 ）\n3. <strong>数据块</strong>：存放文件内容，因为块的大小一定，所以有时一个文件会分布在多个磁盘上。\n### i 节点\ni 节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.\n\n### linux文件类型\n<table style=\"text-align:center\">\n   <tr>\n      <td><strong>文件类型</strong></td>\n      <td>普通文件</td>\n      <td>目录</td>\n      <td>字符设备文件</td>\n      <td>块设备文件</td>\n      <td>符号链接文件</td>\n      <td>套接字文件</td>\n      <td>管道文件</td>\n   </tr>\n   <tr>\n      <td><strong>属性</strong></td>\n      <td>-</td>\n      <td>d</td>\n      <td>c</td>\n      <td>b</td>\n      <td>l</td>\n      <td>s</td>\n      <td>p</td>\n   </tr>\n</table>\n\n### linux常用的系统调用函数\n* [进程控制函数](#进程控制函数)\n* [文件操作函数](#文件操作函数)\n* [文件系统操作函数](#文件系统操作函数)\n* [系统控制函数](#系统控制函数)\n* [内存管理函数](#内存管理函数)\n* [网络管理函数](#网络管理函数)\n* [socket函数](#socket函数)\n* [用户管理函数](#用户管理函数)\n* [进程间通信函数](#进程间通信函数)\n* [信号相关函数](#信号相关函数)\n* [消息相关函数](#消息相关函数)\n* [管道相关函数](#管道相关函数)\n* [信号量相关函数](#信号量相关函数)\n* [共享内存相关函数](#共享内存相关函数)\n\n#### 进程控制函数\n<table>\n   <tr style=\"color:red\">\n      <td>fork</td>\n      <td>创建一个新进程</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>clone</td>\n      <td>按指定条件创建子进程</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>execve</td>\n      <td>运行可执行文件</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>exit</td>\n      <td>中止进程</td>\n   </tr>\n   <tr>\n      <td>_exit</td>\n      <td>立即中止当前进程</td>\n   </tr>\n   <tr>\n      <td>getdtablesize</td>\n      <td>进程所能打开的最大文件数</td>\n   </tr>\n   <tr>\n      <td>getpgid</td>\n      <td>获取指定进程组标识号</td>\n   </tr>\n   <tr>\n      <td>setpgid</td>\n      <td>设置指定进程组标志号</td>\n   </tr>\n   <tr>\n      <td>getpgrp</td>\n      <td>获取当前进程组标识号</td>\n   </tr>\n   <tr>\n      <td>setpgrp</td>\n      <td>设置当前进程组标志号</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>getpid</td>\n          <td>获取进程标识号</td>\n    </tr>\n      <tr>\n          <td>getppid</td>\n          <td>获取父进程标识号</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>getpriority</td>\n          <td>获取调度优先级</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>setpriority</td>\n          <td>设置调度优先级</td>\n    </tr>\n      <tr>\n          <td>modify_ldt</td>\n          <td>读写进程的本地描述表</td>\n    </tr>\n      <tr>\n          <td>nanosleep</td>\n          <td>使进程睡眠指定的时间</td>\n    </tr>\n      <tr>\n          <td>nice</td>\n          <td>改变分时进程的优先级</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>pause</td>\n          <td>挂起进程，等待信号</td>\n    </tr>\n      <tr>\n          <td>personality</td>\n          <td>设置进程运行域</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>prctl</td>\n          <td>对进程进行特定操作</td>\n    </tr>\n      <tr>\n          <td>ptrace</td>\n          <td>进程跟踪</td>\n    </tr>\n      <tr>\n          <td>sched_get_priority_max</td>\n          <td>取得静态优先级的上限</td>\n    </tr>\n      <tr>\n          <td>sched_get_priority_min</td>\n          <td>取得静态优先级的下限</td>\n    </tr>\n      <tr>\n          <td>sched_getparam</td>\n          <td>取得进程的调度参数</td>\n    </tr>\n      <tr>\n          <td>sched_getscheduler</td>\n          <td>取得指定进程的调度策略</td>\n    </tr>\n      <tr>\n          <td>sched_rr_get_interval</td>\n          <td>取得按RR算法调度的实时进程的时间片长度</td>\n    </tr>\n      <tr>\n          <td>sched_setparam</td>\n          <td>设置进程的调度参数</td>\n    </tr>\n      <tr>\n          <td>sched_setscheduler</td>\n          <td>设置指定进程的调度策略和参数</td>\n    </tr>\n      <tr>\n          <td>sched_yield</td>\n          <td>进程主动让出处理器,并将自己等候调度队列队尾</td>\n    </tr>\n      <tr>\n          <td>vfork</td>\n          <td>创建一个子进程，以供执行新程序，常与execve等同时使用</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>wait</td>\n          <td>等待子进程终止</td>\n    </tr>\n      <tr>\n          <td>wait3</td>\n          <td>参见wait</td>\n    </tr>\n      <tr>\n          <td>waitpid</td>\n          <td>等待指定子进程终止</td>\n    </tr>\n      <tr>\n          <td>wait4</td>\n          <td>参见waitpid</td>\n    </tr>\n      <tr>\n          <td>capget</td>\n          <td>获取进程权限</td>\n    </tr>\n      <tr>\n          <td>capset</td>\n          <td>设置进程权限</td>\n    </tr>\n      <tr>\n          <td>getsid</td>\n          <td>获取会晤标识号</td>\n    </tr>\n      <tr>\n          <td>setsid</td>\n          <td>设置会晤标识号</td>\n      </tr>\n</table>\n\n#### 文件操作函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>fcntl</td>\n      <td>文件控制</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>open</td>\n      <td>打开文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>creat</td>\n      <td>创建新文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>close</td>\n      <td>关闭文件描述字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>read</td>\n      <td>读文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>write</td>\n      <td>写文件</td>\n  </tr>\n  <tr>\n      <td>readv</td>\n      <td>从文件读入数据到缓冲数组中</td>\n  </tr>\n  <tr>\n      <td>writev</td>\n      <td>将缓冲数组里的数据写入文件</td>\n  </tr>\n  <tr>\n      <td>pread</td>\n      <td>对文件随机读</td>\n  </tr>\n  <tr>\n      <td>pwrite</td>\n      <td>对文件随机写</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>lseek</td>\n      <td>移动文件指针</td>\n  </tr>\n  <tr>\n      <td>_llseek</td>\n      <td>在64位地址空间里移动文件指针</td>\n  </tr>\n  <tr>\n      <td>dup</td>\n      <td>复制已打开的文件描述字</td>\n  </tr>\n  <tr>\n      <td>dup2</td>\n      <td>按指定条件复制文件描述字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>flock</td>\n      <td>文件加/解锁</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>poll</td>\n      <td>I/O多路转换</td>\n  </tr>\n  <tr>\n      <td>truncate</td>\n      <td>截断文件</td>\n  </tr>\n  <tr>\n      <td>ftruncate</td>\n      <td>参见truncate</td>\n  </tr>\n  <tr>\n      <td>umask</td>\n      <td>设置文件权限掩码</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>fsync</td>\n      <td>把文件在内存中的部分写回磁盘</td>\n  </tr>\n</table>\n\n#### 文件系统操作函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>access</td>\n      <td>确定文件的可存取性</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chdir</td>\n      <td>改变当前工作目录</td>\n  </tr>\n  <tr>\n      <td>fchdir</td>\n      <td>参见chdir</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chmod</td>\n      <td>改变文件方式</td>\n  </tr>\n  <tr>\n      <td>fchmod</td>\n      <td>参见chmod</td>\n  </tr>\n  <tr>\n      <td>chown</td>\n      <td>改变文件的属主或用户组</td>\n  </tr>\n  <tr>\n      <td>fchown</td>\n      <td>参见chown</td>\n  </tr>\n  <tr>\n      <td>lchown</td>\n      <td>参见chown</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chroot</td>\n      <td>改变根目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>stat</td>\n      <td>取文件状态信息</td>\n  </tr>\n  <tr>\n      <td>lstat</td>\n      <td>参见stat</td>\n  </tr>\n  <tr>\n      <td>fstat</td>\n      <td>参见stat</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>statfs</td>\n      <td>取文件系统信息</td>\n  </tr>\n  <tr>\n      <td>fstatfs</td>\n      <td>参见statfs</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>readdir</td>\n      <td>读取目录项</td>\n  </tr>\n  <tr>\n      <td>getdents</td>\n      <td>读取目录项</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>mkdir</td>\n      <td>创建目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>mknod</td>\n      <td>创建索引节点</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>rmdir</td>\n      <td>删除目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>rename</td>\n      <td>文件改名</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>link</td>\n      <td>创建链接</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>symlink</td>\n      <td>创建符号链接</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>unlink</td>\n      <td>删除链接</td>\n  </tr>\n  <tr>\n      <td>readlink</td>\n      <td>读符号链接的值</td>\n  </tr>\n  <tr>\n      <td>mount</td>\n      <td>安装文件系统</td>\n  </tr>\n  <tr>\n      <td>umount</td>\n      <td>卸下文件系统</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>ustat</td>\n      <td>取文件系统信息</td>\n  </tr>\n  <tr>\n      <td>utime</td>\n      <td>改变文件的访问修改时间</td>\n  </tr>\n  <tr>\n      <td>utimes</td>\n      <td>参见utime</td>\n  </tr>\n  <tr>\n      <td>quotactl</td>\n      <td>控制磁盘配额</td>\n  </tr>\n</table>\n\n#### 系统控制函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>ioctl</td>\n      <td>I/O总控制函数</td>\n  </tr>\n  <tr>\n      <td>_sysctl</td>\n      <td>读/写系统参数</td>\n  </tr>\n  <tr>\n      <td>acct</td>\n      <td>启用或禁止进程记账</td>\n  </tr>\n  <tr>\n      <td>getrlimit</td>\n      <td>获取系统资源上限</td>\n  </tr>\n  <tr>\n      <td>setrlimit</td>\n      <td>设置系统资源上限</td>\n  </tr>\n  <tr>\n      <td>getrusage</td>\n      <td>获取系统资源使用情况</td>\n  </tr>\n  <tr>\n      <td>uselib</td>\n      <td>选择要使用的二进制函数库</td>\n  </tr>\n  <tr>\n      <td>ioperm</td>\n      <td>设置端口I/O权限</td>\n  </tr>\n  <tr>\n      <td>iopl</td>\n      <td>改变进程I/O权限级别</td>\n  </tr>\n  <tr>\n      <td>outb</td>\n      <td>低级端口操作</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>reboot</td>\n      <td>重新启动</td>\n  </tr>\n  <tr>\n      <td>swapon</td>\n      <td>打开交换文件和设备</td>\n  </tr>\n  <tr>\n      <td>swapoff</td>\n      <td>关闭交换文件和设备</td>\n  </tr>\n  <tr>\n      <td>bdflush</td>\n      <td>控制bdflush守护进程</td>\n  </tr>\n  <tr>\n      <td>sysfs</td>\n      <td>取核心支持的文件系统类型</td>\n  </tr>\n  <tr>\n      <td>sysinfo</td>\n      <td>取得系统信息</td>\n  </tr>\n  <tr>\n      <td>adjtimex</td>\n      <td>调整系统时钟</td>\n  </tr>\n  <tr>\n      <td>alarm</td>\n      <td>设置进程的闹钟</td>\n  </tr>\n  <tr>\n      <td>getitimer</td>\n      <td>获取计时器值</td>\n  </tr>\n  <tr>\n      <td>setitimer</td>\n      <td>设置计时器值</td>\n  </tr>\n  <tr>\n      <td>gettimeofday</td>\n      <td>取时间和时区</td>\n  </tr>\n  <tr>\n      <td>settimeofday</td>\n      <td>设置时间和时区</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>stime</td>\n      <td>设置系统日期和时间</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>time</td>\n      <td>取得系统时间</td>\n  </tr>\n  <tr>\n      <td>times</td>\n      <td>取进程运行时间</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>uname</td>\n      <td>获取当前UNIX系统的名称、版本和主机等信息</td>\n  </tr>\n  <tr>\n      <td>vhangup</td>\n      <td>挂起当前终端</td>\n  </tr>\n  <tr>\n      <td>nfsservctl</td>\n      <td>对NFS守护进程进行控制</td>\n  </tr>\n  <tr>\n      <td>vm86</td>\n      <td>进入模拟8086模式</td>\n  </tr>\n  <tr>\n      <td>create_module</td>\n      <td>创建可装载的模块项</td>\n  </tr>\n  <tr>\n      <td>delete_module</td>\n      <td>删除可装载的模块项</td>\n  </tr>\n  <tr>\n      <td>init_module</td>\n      <td>初始化模块</td>\n  </tr>\n  <tr>\n      <td>query_module</td>\n      <td>查询模块信息</td>\n  </tr>\n  <tr>\n      <td>*get_kernel_syms</td>\n      <td>取得核心符号,已被query_module代替</td>\n  </tr>\n</table>\n\n#### 内存管理函数\n\n<table>\n  <tr>\n      <td>brk</td>\n      <td>改变数据段空间的分配</td>\n  </tr>\n  <tr>\n      <td>sbrk</td>\n      <td>参见brk</td>\n  </tr>\n  <tr>\n      <td>mlock</td>\n      <td>内存页面加锁</td>\n  </tr>\n  <tr>\n      <td>munlock</td>\n      <td>内存页面解锁</td>\n  </tr>\n  <tr>\n      <td>mlockall</td>\n      <td>调用进程所有内存页面加锁</td>\n  </tr>\n    <tr>\n      <td>munlockall</td>\n      <td>调用进程所有内存页面解锁</td>\n  </tr>\n  <tr>\n      <td>mmap</td>\n      <td>映射虚拟内存页</td>\n  </tr>\n  <tr>\n      <td>munmap</td>\n      <td>去除内存页映射</td>\n  </tr>\n  <tr>\n      <td>mremap</td>\n      <td>重新映射虚拟内存地址</td>\n  </tr>\n  <tr>\n      <td>msync</td>\n      <td>将映射内存中的数据写回磁盘</td>\n  </tr>\n  <tr>\n      <td>mprotect</td>\n      <td>设置内存映像保护</td>\n  </tr>\n  <tr>\n      <td>getpagesize</td>\n      <td>获取页面大小</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sync</td>\n      <td>将内存缓冲区数据写回硬盘</td>\n  </tr>\n  <tr>\n      <td>cacheflush</td>\n      <td>dddd将指定缓冲区中的内容写回磁盘dd</td>\n  </tr>\n</table>\n\n#### 网络管理函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>getdomainname</td>\n      <td>取域名</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>setdomainname</td>\n      <td>设置域名</td>\n  </tr>\n  <tr>\n      <td>gethostid</td>\n      <td>获取主机标识号</td>\n  </tr>\n  <tr>\n      <td>sethostid</td>\n      <td>设置主机标识号</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>gethostname</td>\n      <td>获取本主机名称</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sethostname</td>\n      <td>设置主机名称</td>\n  </tr>\n</table>\n\n#### socket函数\n\n<table>\n  <tr>\n      <td>socketcall</td>\n      <td>socket系统调用</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>socket</td>\n      <td>建立socket</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>bind</td>\n      <td>绑定socket到端口</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>connect</td>\n      <td>连接远程主机</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>accept</td>\n      <td>响应socket连接请求</td>\n  </tr style=\"color:red\">\n    <tr>\n      <td>send</td>\n      <td>通过socket发送信息</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sendto</td>\n      <td>发送UDP信息</td>\n  </tr>\n  <tr>\n      <td>sendmsg</td>\n      <td>参见send</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>recv</td>\n      <td>通过socket接收信息</td>\n  </tr>\n    <tr style=\"color:red\">\n      <td>recvfrom</td>\n      <td>接收UDP信息</td>\n  </tr>\n  <tr>\n      <td>recvmsg</td>\n      <td>参见recv</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>listen</td>\n      <td>监听socket端口</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>select</td>\n      <td>对多路同步I/O进行轮询</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>close</td>\n      <td>关闭socket上的连接</td>\n  </tr>\n  <tr>\n      <td>getsockname</td>\n      <td>取得本地socket名字</td>\n  </tr>\n  <tr>\n      <td>getpeername</td>\n      <td>获取通信对方的socket名字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>getsockopt</td>\n      <td>取端口设置</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>setsockopt</td>\n      <td>设置端口参数</td>\n  </tr>\n  <tr>\n      <td>sendfile</td>\n      <td>在文件或端口间传输数据</td>\n  </tr>\n  <tr>\n      <td>socketpair</td>\n      <td>创建一对已联接的无名socket</td>\n  </tr>\n</table>\n\n#### 用户管理函数\n\n<table>\n  <tr>\n      <td>getuid</td>\n      <td>获取用户标识号</td>\n  </tr>\n  <tr>\n      <td>setuid</td>\n      <td>设置用户标志号</td>\n  </tr>\n  <tr>\n      <td>getgid</td>\n      <td>获取组标识号</td>\n  </tr>\n  <tr>\n      <td>setgid</td>\n      <td>设置组标志号</td>\n  </tr>\n  <tr>\n      <td>getegid</td>\n      <td>获取有效组标识号</td>\n  </tr>\n  <tr>\n      <td>setegid</td>\n      <td>设置有效组标识号</td>\n  </tr>\n  <tr>\n      <td>geteuid</td>\n      <td>获取有效用户标识号</td>\n  </tr>\n  <tr>\n      <td>seteuid</td>\n      <td>设置有效用户标识号</td>\n  </tr>\n  <tr>\n      <td>setregid</td>\n      <td>分别设置真实和有效的的组标识号</td>\n  </tr>\n  <tr>\n      <td>setreuid</td>\n      <td>分别设置真实和有效的用户标识号</td>\n  </tr>\n  <tr>\n      <td>getresgid</td>\n      <td>分别获取真实的,有效的和保存过的组标识号</td>\n  </tr>\n  <tr>\n      <td>setresgid</td>\n      <td>分别设置真实的,有效的和保存过的组标识号</td>\n  </tr>\n  <tr>\n      <td>getresuid</td>\n      <td>分别获取真实的,有效的和保存过的用户标识号</td>\n  </tr>\n  <tr>\n      <td>setresuid</td>\n      <td>分别设置真实的,有效的和保存过的用户标识号</td>\n  </tr>\n  <tr>\n      <td>setfsgid</td>\n      <td>设置文件系统检查时使用的组标识号</td>\n  </tr>\n  <tr>\n      <td>setfsuid</td>\n      <td>设置文件系统检查时使用的用户标识号</td>\n  </tr>\n  <tr>\n      <td>getgroups</td>\n      <td>获取后补组标志清单</td>\n  </tr>\n  <tr>\n      <td>setgroups</td>\n      <td>设置后补组标志清单</td>\n  </tr>\n</table>\n\n#### 进程间通信函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>ipc</td>\n      <td>进程间通信总控制调用</td>\n  </tr>\n</table>\n\n#### 信号相关函数\n\n<table>\n  <tr>\n      <td>sigaction</td>\n      <td>设置对指定信号的处理方法</td>\n  </tr>\n  <tr>\n      <td>sigprocmask</td>\n      <td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>\n  </tr>\n  <tr>\n      <td>sigpending</td>\n      <td>为指定的被阻塞信号设置队列</td>\n  </tr>\n  <tr>\n      <td>sigsuspend</td>\n      <td>挂起进程等待特定信号</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>signal</td>\n      <td>参见signal</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>kill</td>\n      <td>向进程或进程组发信号</td>\n  </tr>\n  <tr>\n      <td>*sigblock</td>\n      <td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*siggetmask</td>\n      <td>取得现有阻塞信号掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigsetmask</td>\n      <td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigmask</td>\n      <td>将给定的信号转化为掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigpause</td>\n      <td>作用同sigsuspend,已被sigsuspend代替</td>\n  </tr>\n  <tr>\n      <td>sigvec</td>\n      <td>为兼容BSD而设的信号处理函数,作用类似sigaction</td>\n  </tr>\n  <tr>\n      <td>ssetmask</td>\n      <td>ANSI C的信号处理函数,作用类似sigaction</td>\n  </tr>\n</table>\n\n#### 消息相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>msgctl</td>\n      <td>消息控制操作</td>\n  </tr>\n  <tr>\n      <td>msgget</td>\n      <td>获取消息队列</td>\n  </tr>\n  <tr>\n      <td>msgsnd</td>\n      <td>发消息</td>\n  </tr>\n  <tr>\n      <td>msgrcv</td>\n      <td>取消息</td>\n  </tr>\n</table>\n\n#### 管道相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>pipe</td>\n      <td>创建管道</td>\n  </tr>\n</table>\n\n#### 信号量相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>semctl</td>\n      <td>信号量控制</td>\n  </tr>\n  <tr>\n      <td>semget</td>\n      <td>获取一组信号量</td>\n  </tr>\n  <tr>\n      <td>semop</td>\n      <td>信号量操作</td>\n  </tr>\n</table>\n\n#### 共享内存相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>shmctl</td>\n      <td>控制共享内存</td>\n  </tr>\n  <tr>\n      <td>shmget</td>\n      <td>获取共享内存</td>\n  </tr>\n  <tr>\n      <td>shmat</td>\n      <td>连接共享内存</td>\n  </tr>\n  <tr>\n      <td>shmdt</td>\n      <td>拆卸共享内存</td>\n  </tr>\n</table>\n\n### fork函数\nfork是用来创建子进程的，这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，我们可以通过返回值来判断其返回点：\n```c\npid_t child = fork();\nif( child < 0  ) {     //fork error.\n    perror(\"fork process fail.\\n\");\n} else if( child ==0  ) {   // in child process\n    printf(\" fork succ, this run in child process\\n \");\n} else {                        // in parent process\n    printf(\" this run in parent process\\n \");\n}\n```\n### 僵尸进程\n* [僵尸进程产生原因](#僵尸进程产生原因)\n* [僵尸进程解决办法](#僵尸进程解决办法)\n* [ps指令查看僵尸进程](#ps指令查看僵尸进程)\n\n#### 僵尸进程产生原因\n  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。\n\n#### 僵尸进程解决办法\n1. 通过信号机制\n  子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。\n2. fork两次\n  父进程创建子进程A，子进程A再创建子进程B，然后子进程A退出，z这样子进程B就交给init进程处理了。init进程可以处理僵尸进程.\n\n#### ps指令查看僵尸进程\n```sh\nps -A -ostat,pid,cmd |grep -iE '^z'\n```\n> -A 显示所有任务\n  -o 按照指定格式输出\n  grep -iE 显示z开头的行，不区分大小写\n\n### 常见文件说明\n/var/log/boot.log 系统引导日志\n/var/log/dmesg    系统核心启动日志\n/var/log/messages 核心系统日志\n/var/log/maillog  邮件系统日志\n/var/log/xferlog  FTP系统日志\n/var/log/syslog   系统出问题的日志\n/var/log/secure   安全信息和系统登录与网络连接的信息\n/var/log/wtmp     登录记录\n/var/spool/clientmqueue\n/proc/interrupts\n/etc/fstab        Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.\n### proc目录说明\n```sh\nproc文件系统是一个伪文件系统，它只存在内存当中。\n/proc/buddyinfo   每个内存区中的每个order有多少块可用，和内存碎片问题有关\n/proc/cmdline     启动时传递给kernel的参数信息\n/proc/cpuinfo     cpu的信息\n/proc/crypto      内核使用的所有已安装的加密密码及细节\n/proc/devices     已经加载的设备并分类\n/proc/dma         已注册使用的ISA DMA频道列表\n/proc/execdomains Linux内核当前支持的execution domains\n/proc/fb          帧缓冲设备列表，包括数量和控制它的驱动\n/proc/filesystems 内核当前支持的文件系统类型\n/proc/interrupts  x86架构中的每个IRQ中断数\n/proc/iomem       每个物理设备当前在系统内存中的映射\n/proc/ioports     一个设备的输入输出所使用的注册端口范围\n/proc/kcore       代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb\n/proc/kmsg        记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理\n/proc/loadavg     根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关\n/proc/locks       内核锁住的文件列表\n/proc/mdstat      多硬盘，RAID配置信息(md=multiple disks)\n/proc/meminfo     RAM使用的相关信息\n/proc/misc        其他的主要设备(设备号为10)上注册的驱动\n/proc/modules     所有加载到内核的模块列表\n/proc/mounts      系统中使用的所有挂载\n/proc/mtrr        系统使用的Memory Type Range Registers (MTRRs)\n/proc/partitions  分区中的块分配信息\n/proc/pci         系统中的PCI设备列表\n/proc/slabinfo    系统中所有活动的 slab 缓存信息\n/proc/stat        所有的CPU活动信息\n/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的\n/proc/uptime      系统已经运行了多久\n/proc/swaps       交换空间的使用情况\n/proc/version     Linux内核版本和gcc版本\n/proc/bus         系统总线(Bus)信息，例如pci/usb等\n/proc/driver      驱动信息\n/proc/fs          文件系统信息\n/proc/ide         ide设备信息\n/proc/irq         中断请求设备信息\n/proc/net         网卡设备信息\n/proc/scsi        scsi设备信息\n/proc/tty         tty设备信息\n/proc/net/dev     显示网络适配器及统计信息\n/proc/vmstat      虚拟内存统计信息\n/proc/vmcore      内核panic时的内存映像\n/proc/diskstats   取得磁盘信息\n/proc/schedstat   kernel调度器的统计信息\n/proc/zoneinfo    显示内存空间的统计信息，对分析虚拟内存行为很有用\n#### 以下是/proc目录中进程N的信息\n/proc/N           pid为N的进程信息\n/proc/N/cmdline   进程启动命令\n/proc/N/cwd       链接到进程当前工作目录\n/proc/N/environ   进程环境变量列表\n/proc/N/exe       链接到进程的执行命令文件\n/proc/N/fd        包含进程相关的所有的文件描述符\n/proc/N/maps      与进程相关的内存映射信息\n/proc/N/mem       指代进程持有的内存，不可读\n/proc/N/root      链接到进程的根目录\n/proc/N/stat      进程的状态\n/proc/N/statm     进程使用的内存的状态\n/proc/N/status    进程状态信息，比stat/statm更具可读性\n/proc/self        链接到当前正在运行的进程\n```\n### fopen参数说明\n|参数  |说明|\n|:---:|---|\n| r   |以只读方式打开文件，该文件必须存在。|\n| r+  |以可读写方式打开文件，该文件必须存在。|\n| rb+ |读写打开一个二进制文件，允许读写数据，文件必须存在。|\n| w   |打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。|\n| w+  |打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。|\n| a   |以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）|\n| a+  |以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）|\n| wb  |只写打开或新建一个二进制文件；只允许写数据。|\n| wb+ |读写打开或建立一个二进制文件，允许读和写。|\n| ab+ |读写打开一个二进制文件，允许读或在文件末追加数据。|\n| wx  |创建文本文件,只允许写入数据.[C11]|\n| wbx |创建一个二进制文件,只允许写入数据.[C11]|\n| w+x |创建一个文本文件,允许读写.[C11]|\n| wb+x|创建一个二进制文件,允许读写.[C11]|\n| w+bx|和\"wb+x\"相同[C11]|\n> 以x结尾的模式为独占模式,文件已存在或者无法创建(一般是路径不正确)都会导致fopen失败.文件以操作系统支持的独占模式打开.[C11]\n\n\n\n## linux驱动开发知识点\n\n### insmod rmmod 加载 卸载模块\n### i.max6UL\n#### 系统框图\n![i.max6ul系统框图](./res/IMX6UL-BD.png)\n### linux启动过程\n系统上电--->bootrom--->uboot--->kernel加载--->init--->应用程序\n## makefile\n### makefile的规则\n```makefile\ntarget xxx : prerequisites aaa\n\t[command]\n\t...\n\t...\n```\n> prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行\n\n### gcc工具链\n|命令|描述|\n|---|----|\n|Binutils |由汇编器（as）产生的目标代码（*.o）是不能直接在computer上运行的，它必须经过链接器（ld）的处理才能生成可执行代码。|\n|add2line |将地址转换成文件名或行号对，以便调试程序|\n|ar       |从文件中创建、修改、扩展文件|\n|gasp     |汇编宏处理器|\n|nm       |从目标文件列举所有变量|\n|objcopy  |使用GNU BSD库把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。|\n|objdump  |显示目标文件信息可发编译二进制文件，也可以对对象文件进行反汇编，并查看机器代码。|\n|readelf  |显示elf文件信息|\n|ranlib   |生成索引以加快对归档文件的访问，并将其保存到这个归档文件中。|\n|size     |列出目标模块或文件的代码尺寸。|\n|strings  |打印可打印的目标代码符号（至少4个字符）|\n|strip    |放弃所有符号连接，一般应用程序最终都要strip处理|\n|C++filt  |链接器ld通过该命令可过滤C++符号和JAVA符号，防止重载函数冲突。|\n|gprof    |显示程序调用段的各种数据|\n\n### nm命令\n显示二进制目标文件的符号表\n```sh\n-A：每个符号前显示文件名；\n-D：显示动态符号；\n-g：仅显示外部符号；\n-r：反序显示符号表。\n```\n\n### ldd命令\n用于打印程序或者库文件所依赖的共享库列表。\n```sh\n-v：详细信息模式，打印所有相关信息；\n-u：打印未使用的直接依赖；\n-d：执行重定位和报告任何丢失的对象；\n-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；\n```\n\n### 交叉编译工具链说明\n\n#### gcc 交叉编译器\n> 将写好的C程序代码编译为ARM架构下的可执行文件.\n\n```sh\ngcc hello.c -o hello\n```\n#### ld 交叉链接器\n> 将多个编译后产生的过程文件连接为一个最终的可执行文件。\n\n```sh\nld [options] 链接器脚本 -o 文件名.elf\n```\n#### readelf 交叉ELF文件查看器\n> 用来查看一个可执行文件的相关信息\n\n可以查看elf文件的运行架构，大小端等信息:\n```sh\nreadelf -a 文件名.elf\n```\n显示程序需要的动态链接库:\n```sh\nreadelf -d 文件名.elf\n```\n#### objdump 交叉反汇编器\n> 将一个可执行文件转换为汇编下的程序\n\n```sh\n-objdump -D -S elf文件名 >目标文件\n```\n\n#### objcopy 交叉转换器\n> 将elf格式文件转换成其他的格式\n\n```sh\nobjcopy -O 目标文件格式 原ELF文件 目标文件\n```\n例子:\n```sh\nobjcopy -O binary a.elf a.bin\n```\n","source":"_posts/linux.md","raw":"---\ntitle: 嵌入式笔记：linux软件开发\n---\n嵌入式笔记：linux软件开发\n\n# 目录\n* [关键命令说明](#关键命令说明)\n    * [系统关机命令](#系统关机命令)\n    * [linux查看文本的指令](#linux查看文本的指令)\n    * [mount](#mount指令)\n    * [dmesg](#dmesg)\n    * [grep](#grep)\n    * [find](#find)\n    * [lsusb](#lsusb)\n    * [lsof](#lsof)\n* [linux软件开发知识点](#linux软件开发知识点)\n    * [linux进程间通讯方式](#linux进程间通讯方式)\n    * [内存申请函数](#内存申请函数)\n    * [gcc编译过程](#gcc编译过程)\n    * [文件系统](#文件系统)\n    * [硬链接和软连接](#硬链接和软连接)\n    * [linux内核子系统](#linux内核子系统)\n    * [进程几种状态](#进程几种状态)\n    * [文件系统组成](#文件系统组成)\n    * [linux文件类型](#linux文件类型)\n    * [linux常用的系统调用函数](#linux常用的系统调用函数)\n    * [fork函数](#fork函数)\n    * [僵尸进程](#僵尸进程)\n    * [常见文件说明](#常见文件说明)\n    * [/proc目录说明](#/proc目录说明)\n    * [fopen参数说明](#fopen参数说明)\n* [linux驱动开发知识点](#linux驱动开发知识点)\n* [makefile](#makefile)\n* [shell](#shell)\n\n## 关键命令说明\n* [系统关机命令](#系统关机命令)\n* [linux查看文本的指令](#linux查看文本的指令)\n* [mount](#mount指令)\n* [dmesg](#dmesg)\n* [grep](#grep)\n* [find](#find)\n* [lsusb](#lsusb)\n* [lsof](#lsof)\n\n### 系统关机命令\n|指令|说明|\n|:-:|----|\n|shutdown | 命令安全地将系统关机。|\n|halt     | 就是调用shutdown -h。|\n|reboot   | 工作过程差不多跟halt一样﹐不过它是引发主机重启|\n|poweroff | 就是halt的软链接而已|\n|init     | 所有进程的祖先﹐它的进程号始终为1﹐init 0为关机﹐init1为重启。|\n\n### linux查看文本的指令\n<table style=\"text-align:center\">\n   <tr>\n      <td>cat</td>\n      <td>tac</td>\n      <td>sed</td>\n      <td>head</td>\n      <td>tail</td>\n      <td>more</td>\n      <td>less</td>\n      <td>nl</td>\n   </tr>\n</table>\n\n> <strong>tac</strong>： cat的反向指令，从最后一行倒序显示全部内容\n> <strong>head</strong>： 只显示头几行\n> <strong>tail</strong>： 只显示最后几行 tail -f 可以实时显示log文件的更新\n> <strong>nl</strong>： 类似于cat -n，显示时输出行号\n\n### mount\n命令格式：\n```sh\nmount [-t vfstype] [-o options] device dir\n```\n挂载nfs\n```sh\nmount -t nfs 192.168.0.1:/tmp /mnt/nfs \n```\n### dmesg\n```sh\ncat /var/log/messages\n```\n\n### grep\n选项\n```sh\n-c：只输出匹配行的计数。\n-C：匹配的上下文分别显示[number]行。\n-I：不区分大小写(只适用于单字符)。\n-i：不区分大小写。\n-h：查询多文件时不显示文件名。\n-l：查询多文件时只输出包含匹配字符的文件名。\n-L：列出不匹配的文件名。\n-n：显示匹配行及 行号。\n-s：不显示不存在或无匹配文本的错误信息。\n-v：显示不包含匹配文本的所有行。\n-w：只匹配整个单词。\n-E：扩展的正则表达式\n-R：递归搜寻\n--exclude=FILE：跳过FILE\n```\n正则表达式主要参数：\n\t\\：忽略正则表达式中特殊字符的原有含义。\n\t^：匹配正则表达式的开始行。\n\t$：匹配正则表达式的结束行。\n\t\\<：从匹配正则表达式的行开始。\n\t\\>：到匹配正则表达式的行结束。\n\t[]：单个字符，如[A]即A符合要求 。\n\t[-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。\n\t.：所有的单个字符。\n\t*：有字符，长度可以为0。\n\n\n经典使用方法\n```sh\n#所有以d开头的文件，包含test的匹配行\ngrep \"test\" d*\n#包含test或者zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -inE \"test|zephyr\" d*\n#包含test和zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -in \"test\" d* | grep 'zephyr'\n```\n\n主要参数：\n\t－c：只输出匹配行的计数。\n\t－I：不区分大小写(只适用于单字符)。\n\t－h：查询多文件时不显示文件名。\n\t－l：查询多文件时只输出包含匹配字符的文件名。\n\t－L：列出不匹配的文件名\n\t－n：显示匹配行及行号。\n\t－s：不显示不存在或无匹配文本的错误信息。\n\t－v：显示不包含匹配文本的所有行。\n\t－R：递归搜寻\n\t－d skip：不递归搜寻\n\t－w：匹配整个单词\n正则表达式主要参数：\n\t\\：忽略正则表达式中特殊字符的原有含义。\n\t^：匹配正则表达式的开始行。\n\t$：匹配正则表达式的结束行。\n\t\\<：从匹配正则表达式的行开始。\n\t\\>：到匹配正则表达式的行结束。\n\t[]：单个字符，如[A]即A符合要求 。\n\t[-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。\n\t.：所有的单个字符。\n\t*：有字符，长度可以为0。\n\ngrep 'test' d*\t\t显示以d开头的文件中包含的test行\ngrep 'test' aa bb cc \t查找文件aa bb cc 中匹配的test行\ngrep 'test'|'hello' files 匹配test或者hello\ngrep '\\<man' files\t匹配manic 和man 不匹配batman\ngrep '\\<man\\>'\t\t只匹配man 不匹配batman和manic\ngrep '^man' files\t匹配的字符行首\ngrep '$man' files\t匹配的字符串仔行尾\n\n### find\n用法\n```sh\nfind [-path ..] [expression]\n```\n选项\n```sh\n-name     按照文件名\n-iname     按照文件名 忽略大小写\n-perm     按照文件权限\n-user     按照文件拥有者\n-group    按照文件所属的组\n-mtime -n +n 按照文件的更改时间来查找文件， -n：n天以内，+n：n天以前\n-type     查找某一类型：文件类型有：普通文件(f)，目录(d)，字符设备文件(c)，块设备文件(b)，符号链接文件(l)，套接字文件(s)，管道文件(p)\n-size n   查找文件长度为n块（一块等于512字节）的文件，带有c时表示文件长度以字节计。 \n-mount    不跨越文件系统\n-follow   遇到符号链接文件，就跟踪至链接所指向的文件\n-path     匹配文件路径或者文件\n-exec     执行后续命令操作\n-a        and 与操作\n-o        or  或操作\n-not      not 非操作\n```\n经典使用方法\n```sh\n#查找/run中所有的socket文件\nfind /run -type s\n#搜索/dev中所有包含tty的文件\nfind /dev -name \"*tty*\"\n#搜索/dev中大小大于10字节，名称包含bus的文件\nfind /dev -size +10c -name \"*bus*\"\n#或操作，搜索debug开头的文件或者.rst的文件\nfind -name 'debug*' -o -name '*.rst'\n#与操作，搜索debug开头的文件同时是.rst的文件\nfind -name 'debug*' -a -name '*.rst'\n#找出文件大小大于10000块的文件，并复制到当前目录\nfind -size +100000 -exec cp {} . \\;\n```\n### lsusb\n显示系统中以及连接到系统的USB总线信息的工具。\n```sh\n$ lsusb\n\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 002 Device 003: ID 17ef:4811 Lenovo Integrated Webcam [R5U877]\nBus 008 Device 002: ID 0a5c:217f Broadcom Corp. Bluetooth Controller\n```\n> Bus 008 : 指明设备连接到哪（哪条总线）\n> Device 002 : 表明这是连接到总线上的第二台设备\n> ID : 设备的ID\n> Broadcom Corp. Bluetooth Controller :生产商名字和设备名\n\n列出USB详细信息\n```sh\n$ lsusb -v\n```\n列出有多少USB设备\n```sh\n$ find /dev/bus\n```\n打印特定设备的详细信息\n```sh\n$ lsusb -D /dev/bus/usb/008/002\n```\n### lsof\n列出当前系统打开文件的工具\n```sh\n$ sudo lsof\nCOMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAME\ninit       1         root  cwd      DIR       3,3       1024       2         /\ninit       1         root  rtd      DIR       3,3       1024       2         /\ninit       1         root  txt      REG       3,3       38432      1763452  /sbin/init\ninit       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.so\ninit       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.so\ninit       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1\ninit       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1\ninit       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.so\ninit       1         root  10u      FIFO      0,15                  1309     /dev/initctl\n```\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>COMMAND</td>\n      <td>进程的名称</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>PID</td>\n      <td>进程标识符</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>USER</td>\n      <td>进程所有者</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>FD</td>\n      <td>文件描述符</td>\n      <td>应用程序通过文件描述符识别该文件。如cwd、txt、mem等</td>\n   </tr>\n   <tr>\n      <td>TYPE</td>\n      <td>文件类型</td>\n      <td>REG(文件) DIR(目录) CHR(字符) BLK(块设备) FIFO(管道) UNIX(UNIX 域套接字) IPv4(IP套接字)</td>\n   </tr>\n   <tr>\n      <td>DEVICE</td>\n      <td>指定磁盘的名称</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>SIZE</td>\n      <td>文件大小</td>\n      <td></td>\n   </tr>\n   <tr>\n      <td>NODE</td>\n      <td>文件inode</td>\n      <td>每个文件都有一个唯一的inode</td>\n   </tr>\n   <tr>\n      <td>NAME</td>\n      <td>文件名称</td>\n      <td></td>\n   </tr>\n</table>\n\n参数列表\n```sh\nlsof  filename      显示打开指定文件的所有进程\nlsof -a             表示两个参数都必须满足时才显示结果\nlsof -c string      显示COMMAND列中包含指定字符的进程所有打开的文件\nlsof -u username    显示所属user进程打开的文件\nlsof -g gid         显示归属gid的进程情况\nlsof +d /DIR/       显示目录下被进程打开的文件\nlsof +D /DIR/       同上，但是会搜索目录下的所有目录，时间相对较长\nlsof -d FD          显示指定文件描述符的进程\nlsof -n             不将IP转换为hostname，缺省是不加上-n参数\nlsof -i             用以显示符合条件的进程情况\nlsof -i[46] [protocol][@hostname|hostaddr][:service|port]\n                    46 --> IPv4 or IPv6\n                    protocol --> TCP or UDP\n                    hostname --> Internet host name\n                    hostaddr --> IPv4地址\n                    service --> /etc/service中的 service name (可以不只一个)\n                    port --> 端口号 (可以不只一个)\n```\n查找应用程序打开的文件的名称和数目\n```sh\n#显示打开指定文件的所有进程\n$ lsof  filename\n#例如:打开所有使用/dev/urandom的进程\n$ lsof /dev/urandom\n#查看22端口现在运行的情况 \n$ lsof -i :22\n#查看所属xiaxiaowen用户进程所打开的文件类型为txt的文件\n$ lsof -a -u xiaxiaowen -d txt\n#查找谁在使用文件系统\n$ lsof /media/xiaxiaowen/机械硬盘\nCOMMAND  PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nzsh     8465 xiaxiaowen  cwd    DIR   8,17     8192    5 /media/xiaxiaowen/机械硬盘\n```\n\n## linux软件开发知识点\n* [linux进程间通讯方式](#linux进程间通讯方式)\n* [内存申请函数](#内存申请函数)\n* [linux内存分配说明](#linux内存分配说明)\n* [gcc编译过程](#gcc编译过程)\n* [文件系统](#文件系统)\n* [硬链接和软连接](#硬链接和软连接)\n* [linux内核子系统](#linux内核子系统)\n* [进程几种状态](#进程几种状态)\n* [文件系统组成](#文件系统组成)\n* [linux文件类型](#linux文件类型)\n* [linux常用的系统调用函数](#linux常用的系统调用函数)\n* [fork函数](#fork函数)\n* [僵尸进程](#僵尸进程)\n* [常见文件说明](#常见文件说明)\n* [proc目录说明](#proc目录说明)\n* [fopen参数说明](#fopen参数说明)\n\n### linux进程间通讯方式\n1. 管道（Pipe）及有名管道（named pipe）\n2. 信号（Signal）\n3. 报文（Message）队列（消息队列）：\n4. 共享内存\n5. 信号量（semaphore）\n6. 套接口（Socket）\n\n### 内存申请函数\n1. calloc\n2. malloc\n3. realloc\n### linux内存分配说明\n|内存|存放数据|说明\n|:---:|---|---|\n|静态存储区|静态数据、全局数据、常量|在程序编译的时候就已经分配好|\n|栈区     |局部变量、函数参数|栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限|\n|堆区     |malloc申请的内存|动态内存分配,需要手动释放|\n|代码区    |代码|存放函数体的二进制代码|\n|文字常量区|常量字符串|程序结束后由系统释放|\n### gcc编译过程\n\n<table style=\"text-align:center\">\n   <tr>\n      <td><strong>过程</td>\n      <td><strong>生成文件</td>\n   </tr>\n   <tr>\n      <td>预编译</td>\n      <td>*.i</td>\n   </tr>\n   <tr>\n      <td>编译</td>\n      <td>*.s</td>\n   </tr>\n   <tr>\n      <td>汇编</td>\n      <td>*.o</td>\n   </tr>\n   <tr>\n      <td>链接</td>\n      <td>可执行文件</td>\n   </tr>\n</table>\n\n### 文件系统\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>fat</td>\n      <td>fat32</td>\n      <td>ntfs</td>\n      <td>ext2</td>\n      <td>ext3</td>\n      <td>ext4</td>\n      <td>nfs</td>\n   </tr>\n</table>\n\n### 硬链接和软连接\n#### 硬链接\n* 硬链接直接指向文件的i节点\n* 硬链接和原文件的i节点是一样的\n* 硬链接文件显示的大小是跟原文件是一样的\n* 硬链接不能链接目录文件。\n```sh\nln file2 /home/xiaxiaowen/file2hard\n```\n#### 软链接(符号链接)\n* 软链接则是建立了一个新文件\n* 这个文件指向链接的文件，i节点不一样\n* 可以链接目录\n```sh\nln -s file2 /home/xiaxiaowen/file2soft\n```\n\n### linux内核子系统\n1. 进程管理\n2. 内存管理\n3. I/O管理\n4. 文件系统管理\n\n### 进程几种状态\n1. 运行态\n2. 就绪态\n3. 阻塞态\n\n### 文件系统组成\n1. <strong>超级块</strong>：存放文件系统本身的信息，比如记录了每个区域的大小，或未被使用的磁盘块的信息。（不同版本稍有差别）\n2. <strong>i-节点表</strong>：每个文件都有其属性，大小，最近修改时间等等，这些被存储在ino_t 的结构体中，所有的i-节点都有一样的大小，i-节点表就是这样一些节点的列表。（表中的每个i-节点都通过位置来标志，例如标志为2的i-节点位于文件系统i-节点表中的第3个位置 ）\n3. <strong>数据块</strong>：存放文件内容，因为块的大小一定，所以有时一个文件会分布在多个磁盘上。\n### i 节点\ni 节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.\n\n### linux文件类型\n<table style=\"text-align:center\">\n   <tr>\n      <td><strong>文件类型</strong></td>\n      <td>普通文件</td>\n      <td>目录</td>\n      <td>字符设备文件</td>\n      <td>块设备文件</td>\n      <td>符号链接文件</td>\n      <td>套接字文件</td>\n      <td>管道文件</td>\n   </tr>\n   <tr>\n      <td><strong>属性</strong></td>\n      <td>-</td>\n      <td>d</td>\n      <td>c</td>\n      <td>b</td>\n      <td>l</td>\n      <td>s</td>\n      <td>p</td>\n   </tr>\n</table>\n\n### linux常用的系统调用函数\n* [进程控制函数](#进程控制函数)\n* [文件操作函数](#文件操作函数)\n* [文件系统操作函数](#文件系统操作函数)\n* [系统控制函数](#系统控制函数)\n* [内存管理函数](#内存管理函数)\n* [网络管理函数](#网络管理函数)\n* [socket函数](#socket函数)\n* [用户管理函数](#用户管理函数)\n* [进程间通信函数](#进程间通信函数)\n* [信号相关函数](#信号相关函数)\n* [消息相关函数](#消息相关函数)\n* [管道相关函数](#管道相关函数)\n* [信号量相关函数](#信号量相关函数)\n* [共享内存相关函数](#共享内存相关函数)\n\n#### 进程控制函数\n<table>\n   <tr style=\"color:red\">\n      <td>fork</td>\n      <td>创建一个新进程</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>clone</td>\n      <td>按指定条件创建子进程</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>execve</td>\n      <td>运行可执行文件</td>\n   </tr>\n   <tr style=\"color:red\">\n      <td>exit</td>\n      <td>中止进程</td>\n   </tr>\n   <tr>\n      <td>_exit</td>\n      <td>立即中止当前进程</td>\n   </tr>\n   <tr>\n      <td>getdtablesize</td>\n      <td>进程所能打开的最大文件数</td>\n   </tr>\n   <tr>\n      <td>getpgid</td>\n      <td>获取指定进程组标识号</td>\n   </tr>\n   <tr>\n      <td>setpgid</td>\n      <td>设置指定进程组标志号</td>\n   </tr>\n   <tr>\n      <td>getpgrp</td>\n      <td>获取当前进程组标识号</td>\n   </tr>\n   <tr>\n      <td>setpgrp</td>\n      <td>设置当前进程组标志号</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>getpid</td>\n          <td>获取进程标识号</td>\n    </tr>\n      <tr>\n          <td>getppid</td>\n          <td>获取父进程标识号</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>getpriority</td>\n          <td>获取调度优先级</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>setpriority</td>\n          <td>设置调度优先级</td>\n    </tr>\n      <tr>\n          <td>modify_ldt</td>\n          <td>读写进程的本地描述表</td>\n    </tr>\n      <tr>\n          <td>nanosleep</td>\n          <td>使进程睡眠指定的时间</td>\n    </tr>\n      <tr>\n          <td>nice</td>\n          <td>改变分时进程的优先级</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>pause</td>\n          <td>挂起进程，等待信号</td>\n    </tr>\n      <tr>\n          <td>personality</td>\n          <td>设置进程运行域</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>prctl</td>\n          <td>对进程进行特定操作</td>\n    </tr>\n      <tr>\n          <td>ptrace</td>\n          <td>进程跟踪</td>\n    </tr>\n      <tr>\n          <td>sched_get_priority_max</td>\n          <td>取得静态优先级的上限</td>\n    </tr>\n      <tr>\n          <td>sched_get_priority_min</td>\n          <td>取得静态优先级的下限</td>\n    </tr>\n      <tr>\n          <td>sched_getparam</td>\n          <td>取得进程的调度参数</td>\n    </tr>\n      <tr>\n          <td>sched_getscheduler</td>\n          <td>取得指定进程的调度策略</td>\n    </tr>\n      <tr>\n          <td>sched_rr_get_interval</td>\n          <td>取得按RR算法调度的实时进程的时间片长度</td>\n    </tr>\n      <tr>\n          <td>sched_setparam</td>\n          <td>设置进程的调度参数</td>\n    </tr>\n      <tr>\n          <td>sched_setscheduler</td>\n          <td>设置指定进程的调度策略和参数</td>\n    </tr>\n      <tr>\n          <td>sched_yield</td>\n          <td>进程主动让出处理器,并将自己等候调度队列队尾</td>\n    </tr>\n      <tr>\n          <td>vfork</td>\n          <td>创建一个子进程，以供执行新程序，常与execve等同时使用</td>\n    </tr>\n      <tr style=\"color:red\">\n          <td>wait</td>\n          <td>等待子进程终止</td>\n    </tr>\n      <tr>\n          <td>wait3</td>\n          <td>参见wait</td>\n    </tr>\n      <tr>\n          <td>waitpid</td>\n          <td>等待指定子进程终止</td>\n    </tr>\n      <tr>\n          <td>wait4</td>\n          <td>参见waitpid</td>\n    </tr>\n      <tr>\n          <td>capget</td>\n          <td>获取进程权限</td>\n    </tr>\n      <tr>\n          <td>capset</td>\n          <td>设置进程权限</td>\n    </tr>\n      <tr>\n          <td>getsid</td>\n          <td>获取会晤标识号</td>\n    </tr>\n      <tr>\n          <td>setsid</td>\n          <td>设置会晤标识号</td>\n      </tr>\n</table>\n\n#### 文件操作函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>fcntl</td>\n      <td>文件控制</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>open</td>\n      <td>打开文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>creat</td>\n      <td>创建新文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>close</td>\n      <td>关闭文件描述字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>read</td>\n      <td>读文件</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>write</td>\n      <td>写文件</td>\n  </tr>\n  <tr>\n      <td>readv</td>\n      <td>从文件读入数据到缓冲数组中</td>\n  </tr>\n  <tr>\n      <td>writev</td>\n      <td>将缓冲数组里的数据写入文件</td>\n  </tr>\n  <tr>\n      <td>pread</td>\n      <td>对文件随机读</td>\n  </tr>\n  <tr>\n      <td>pwrite</td>\n      <td>对文件随机写</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>lseek</td>\n      <td>移动文件指针</td>\n  </tr>\n  <tr>\n      <td>_llseek</td>\n      <td>在64位地址空间里移动文件指针</td>\n  </tr>\n  <tr>\n      <td>dup</td>\n      <td>复制已打开的文件描述字</td>\n  </tr>\n  <tr>\n      <td>dup2</td>\n      <td>按指定条件复制文件描述字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>flock</td>\n      <td>文件加/解锁</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>poll</td>\n      <td>I/O多路转换</td>\n  </tr>\n  <tr>\n      <td>truncate</td>\n      <td>截断文件</td>\n  </tr>\n  <tr>\n      <td>ftruncate</td>\n      <td>参见truncate</td>\n  </tr>\n  <tr>\n      <td>umask</td>\n      <td>设置文件权限掩码</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>fsync</td>\n      <td>把文件在内存中的部分写回磁盘</td>\n  </tr>\n</table>\n\n#### 文件系统操作函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>access</td>\n      <td>确定文件的可存取性</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chdir</td>\n      <td>改变当前工作目录</td>\n  </tr>\n  <tr>\n      <td>fchdir</td>\n      <td>参见chdir</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chmod</td>\n      <td>改变文件方式</td>\n  </tr>\n  <tr>\n      <td>fchmod</td>\n      <td>参见chmod</td>\n  </tr>\n  <tr>\n      <td>chown</td>\n      <td>改变文件的属主或用户组</td>\n  </tr>\n  <tr>\n      <td>fchown</td>\n      <td>参见chown</td>\n  </tr>\n  <tr>\n      <td>lchown</td>\n      <td>参见chown</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>chroot</td>\n      <td>改变根目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>stat</td>\n      <td>取文件状态信息</td>\n  </tr>\n  <tr>\n      <td>lstat</td>\n      <td>参见stat</td>\n  </tr>\n  <tr>\n      <td>fstat</td>\n      <td>参见stat</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>statfs</td>\n      <td>取文件系统信息</td>\n  </tr>\n  <tr>\n      <td>fstatfs</td>\n      <td>参见statfs</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>readdir</td>\n      <td>读取目录项</td>\n  </tr>\n  <tr>\n      <td>getdents</td>\n      <td>读取目录项</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>mkdir</td>\n      <td>创建目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>mknod</td>\n      <td>创建索引节点</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>rmdir</td>\n      <td>删除目录</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>rename</td>\n      <td>文件改名</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>link</td>\n      <td>创建链接</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>symlink</td>\n      <td>创建符号链接</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>unlink</td>\n      <td>删除链接</td>\n  </tr>\n  <tr>\n      <td>readlink</td>\n      <td>读符号链接的值</td>\n  </tr>\n  <tr>\n      <td>mount</td>\n      <td>安装文件系统</td>\n  </tr>\n  <tr>\n      <td>umount</td>\n      <td>卸下文件系统</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>ustat</td>\n      <td>取文件系统信息</td>\n  </tr>\n  <tr>\n      <td>utime</td>\n      <td>改变文件的访问修改时间</td>\n  </tr>\n  <tr>\n      <td>utimes</td>\n      <td>参见utime</td>\n  </tr>\n  <tr>\n      <td>quotactl</td>\n      <td>控制磁盘配额</td>\n  </tr>\n</table>\n\n#### 系统控制函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>ioctl</td>\n      <td>I/O总控制函数</td>\n  </tr>\n  <tr>\n      <td>_sysctl</td>\n      <td>读/写系统参数</td>\n  </tr>\n  <tr>\n      <td>acct</td>\n      <td>启用或禁止进程记账</td>\n  </tr>\n  <tr>\n      <td>getrlimit</td>\n      <td>获取系统资源上限</td>\n  </tr>\n  <tr>\n      <td>setrlimit</td>\n      <td>设置系统资源上限</td>\n  </tr>\n  <tr>\n      <td>getrusage</td>\n      <td>获取系统资源使用情况</td>\n  </tr>\n  <tr>\n      <td>uselib</td>\n      <td>选择要使用的二进制函数库</td>\n  </tr>\n  <tr>\n      <td>ioperm</td>\n      <td>设置端口I/O权限</td>\n  </tr>\n  <tr>\n      <td>iopl</td>\n      <td>改变进程I/O权限级别</td>\n  </tr>\n  <tr>\n      <td>outb</td>\n      <td>低级端口操作</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>reboot</td>\n      <td>重新启动</td>\n  </tr>\n  <tr>\n      <td>swapon</td>\n      <td>打开交换文件和设备</td>\n  </tr>\n  <tr>\n      <td>swapoff</td>\n      <td>关闭交换文件和设备</td>\n  </tr>\n  <tr>\n      <td>bdflush</td>\n      <td>控制bdflush守护进程</td>\n  </tr>\n  <tr>\n      <td>sysfs</td>\n      <td>取核心支持的文件系统类型</td>\n  </tr>\n  <tr>\n      <td>sysinfo</td>\n      <td>取得系统信息</td>\n  </tr>\n  <tr>\n      <td>adjtimex</td>\n      <td>调整系统时钟</td>\n  </tr>\n  <tr>\n      <td>alarm</td>\n      <td>设置进程的闹钟</td>\n  </tr>\n  <tr>\n      <td>getitimer</td>\n      <td>获取计时器值</td>\n  </tr>\n  <tr>\n      <td>setitimer</td>\n      <td>设置计时器值</td>\n  </tr>\n  <tr>\n      <td>gettimeofday</td>\n      <td>取时间和时区</td>\n  </tr>\n  <tr>\n      <td>settimeofday</td>\n      <td>设置时间和时区</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>stime</td>\n      <td>设置系统日期和时间</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>time</td>\n      <td>取得系统时间</td>\n  </tr>\n  <tr>\n      <td>times</td>\n      <td>取进程运行时间</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>uname</td>\n      <td>获取当前UNIX系统的名称、版本和主机等信息</td>\n  </tr>\n  <tr>\n      <td>vhangup</td>\n      <td>挂起当前终端</td>\n  </tr>\n  <tr>\n      <td>nfsservctl</td>\n      <td>对NFS守护进程进行控制</td>\n  </tr>\n  <tr>\n      <td>vm86</td>\n      <td>进入模拟8086模式</td>\n  </tr>\n  <tr>\n      <td>create_module</td>\n      <td>创建可装载的模块项</td>\n  </tr>\n  <tr>\n      <td>delete_module</td>\n      <td>删除可装载的模块项</td>\n  </tr>\n  <tr>\n      <td>init_module</td>\n      <td>初始化模块</td>\n  </tr>\n  <tr>\n      <td>query_module</td>\n      <td>查询模块信息</td>\n  </tr>\n  <tr>\n      <td>*get_kernel_syms</td>\n      <td>取得核心符号,已被query_module代替</td>\n  </tr>\n</table>\n\n#### 内存管理函数\n\n<table>\n  <tr>\n      <td>brk</td>\n      <td>改变数据段空间的分配</td>\n  </tr>\n  <tr>\n      <td>sbrk</td>\n      <td>参见brk</td>\n  </tr>\n  <tr>\n      <td>mlock</td>\n      <td>内存页面加锁</td>\n  </tr>\n  <tr>\n      <td>munlock</td>\n      <td>内存页面解锁</td>\n  </tr>\n  <tr>\n      <td>mlockall</td>\n      <td>调用进程所有内存页面加锁</td>\n  </tr>\n    <tr>\n      <td>munlockall</td>\n      <td>调用进程所有内存页面解锁</td>\n  </tr>\n  <tr>\n      <td>mmap</td>\n      <td>映射虚拟内存页</td>\n  </tr>\n  <tr>\n      <td>munmap</td>\n      <td>去除内存页映射</td>\n  </tr>\n  <tr>\n      <td>mremap</td>\n      <td>重新映射虚拟内存地址</td>\n  </tr>\n  <tr>\n      <td>msync</td>\n      <td>将映射内存中的数据写回磁盘</td>\n  </tr>\n  <tr>\n      <td>mprotect</td>\n      <td>设置内存映像保护</td>\n  </tr>\n  <tr>\n      <td>getpagesize</td>\n      <td>获取页面大小</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sync</td>\n      <td>将内存缓冲区数据写回硬盘</td>\n  </tr>\n  <tr>\n      <td>cacheflush</td>\n      <td>dddd将指定缓冲区中的内容写回磁盘dd</td>\n  </tr>\n</table>\n\n#### 网络管理函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>getdomainname</td>\n      <td>取域名</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>setdomainname</td>\n      <td>设置域名</td>\n  </tr>\n  <tr>\n      <td>gethostid</td>\n      <td>获取主机标识号</td>\n  </tr>\n  <tr>\n      <td>sethostid</td>\n      <td>设置主机标识号</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>gethostname</td>\n      <td>获取本主机名称</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sethostname</td>\n      <td>设置主机名称</td>\n  </tr>\n</table>\n\n#### socket函数\n\n<table>\n  <tr>\n      <td>socketcall</td>\n      <td>socket系统调用</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>socket</td>\n      <td>建立socket</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>bind</td>\n      <td>绑定socket到端口</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>connect</td>\n      <td>连接远程主机</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>accept</td>\n      <td>响应socket连接请求</td>\n  </tr style=\"color:red\">\n    <tr>\n      <td>send</td>\n      <td>通过socket发送信息</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>sendto</td>\n      <td>发送UDP信息</td>\n  </tr>\n  <tr>\n      <td>sendmsg</td>\n      <td>参见send</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>recv</td>\n      <td>通过socket接收信息</td>\n  </tr>\n    <tr style=\"color:red\">\n      <td>recvfrom</td>\n      <td>接收UDP信息</td>\n  </tr>\n  <tr>\n      <td>recvmsg</td>\n      <td>参见recv</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>listen</td>\n      <td>监听socket端口</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>select</td>\n      <td>对多路同步I/O进行轮询</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>close</td>\n      <td>关闭socket上的连接</td>\n  </tr>\n  <tr>\n      <td>getsockname</td>\n      <td>取得本地socket名字</td>\n  </tr>\n  <tr>\n      <td>getpeername</td>\n      <td>获取通信对方的socket名字</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>getsockopt</td>\n      <td>取端口设置</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>setsockopt</td>\n      <td>设置端口参数</td>\n  </tr>\n  <tr>\n      <td>sendfile</td>\n      <td>在文件或端口间传输数据</td>\n  </tr>\n  <tr>\n      <td>socketpair</td>\n      <td>创建一对已联接的无名socket</td>\n  </tr>\n</table>\n\n#### 用户管理函数\n\n<table>\n  <tr>\n      <td>getuid</td>\n      <td>获取用户标识号</td>\n  </tr>\n  <tr>\n      <td>setuid</td>\n      <td>设置用户标志号</td>\n  </tr>\n  <tr>\n      <td>getgid</td>\n      <td>获取组标识号</td>\n  </tr>\n  <tr>\n      <td>setgid</td>\n      <td>设置组标志号</td>\n  </tr>\n  <tr>\n      <td>getegid</td>\n      <td>获取有效组标识号</td>\n  </tr>\n  <tr>\n      <td>setegid</td>\n      <td>设置有效组标识号</td>\n  </tr>\n  <tr>\n      <td>geteuid</td>\n      <td>获取有效用户标识号</td>\n  </tr>\n  <tr>\n      <td>seteuid</td>\n      <td>设置有效用户标识号</td>\n  </tr>\n  <tr>\n      <td>setregid</td>\n      <td>分别设置真实和有效的的组标识号</td>\n  </tr>\n  <tr>\n      <td>setreuid</td>\n      <td>分别设置真实和有效的用户标识号</td>\n  </tr>\n  <tr>\n      <td>getresgid</td>\n      <td>分别获取真实的,有效的和保存过的组标识号</td>\n  </tr>\n  <tr>\n      <td>setresgid</td>\n      <td>分别设置真实的,有效的和保存过的组标识号</td>\n  </tr>\n  <tr>\n      <td>getresuid</td>\n      <td>分别获取真实的,有效的和保存过的用户标识号</td>\n  </tr>\n  <tr>\n      <td>setresuid</td>\n      <td>分别设置真实的,有效的和保存过的用户标识号</td>\n  </tr>\n  <tr>\n      <td>setfsgid</td>\n      <td>设置文件系统检查时使用的组标识号</td>\n  </tr>\n  <tr>\n      <td>setfsuid</td>\n      <td>设置文件系统检查时使用的用户标识号</td>\n  </tr>\n  <tr>\n      <td>getgroups</td>\n      <td>获取后补组标志清单</td>\n  </tr>\n  <tr>\n      <td>setgroups</td>\n      <td>设置后补组标志清单</td>\n  </tr>\n</table>\n\n#### 进程间通信函数\n\n<table>\n  <tr style=\"color:red\">\n      <td>ipc</td>\n      <td>进程间通信总控制调用</td>\n  </tr>\n</table>\n\n#### 信号相关函数\n\n<table>\n  <tr>\n      <td>sigaction</td>\n      <td>设置对指定信号的处理方法</td>\n  </tr>\n  <tr>\n      <td>sigprocmask</td>\n      <td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>\n  </tr>\n  <tr>\n      <td>sigpending</td>\n      <td>为指定的被阻塞信号设置队列</td>\n  </tr>\n  <tr>\n      <td>sigsuspend</td>\n      <td>挂起进程等待特定信号</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>signal</td>\n      <td>参见signal</td>\n  </tr>\n  <tr style=\"color:red\">\n      <td>kill</td>\n      <td>向进程或进程组发信号</td>\n  </tr>\n  <tr>\n      <td>*sigblock</td>\n      <td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*siggetmask</td>\n      <td>取得现有阻塞信号掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigsetmask</td>\n      <td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigmask</td>\n      <td>将给定的信号转化为掩码,已被sigprocmask代替</td>\n  </tr>\n  <tr>\n      <td>*sigpause</td>\n      <td>作用同sigsuspend,已被sigsuspend代替</td>\n  </tr>\n  <tr>\n      <td>sigvec</td>\n      <td>为兼容BSD而设的信号处理函数,作用类似sigaction</td>\n  </tr>\n  <tr>\n      <td>ssetmask</td>\n      <td>ANSI C的信号处理函数,作用类似sigaction</td>\n  </tr>\n</table>\n\n#### 消息相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>msgctl</td>\n      <td>消息控制操作</td>\n  </tr>\n  <tr>\n      <td>msgget</td>\n      <td>获取消息队列</td>\n  </tr>\n  <tr>\n      <td>msgsnd</td>\n      <td>发消息</td>\n  </tr>\n  <tr>\n      <td>msgrcv</td>\n      <td>取消息</td>\n  </tr>\n</table>\n\n#### 管道相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>pipe</td>\n      <td>创建管道</td>\n  </tr>\n</table>\n\n#### 信号量相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>semctl</td>\n      <td>信号量控制</td>\n  </tr>\n  <tr>\n      <td>semget</td>\n      <td>获取一组信号量</td>\n  </tr>\n  <tr>\n      <td>semop</td>\n      <td>信号量操作</td>\n  </tr>\n</table>\n\n#### 共享内存相关函数\n\n<table style=\"color:red\">\n  <tr>\n      <td>shmctl</td>\n      <td>控制共享内存</td>\n  </tr>\n  <tr>\n      <td>shmget</td>\n      <td>获取共享内存</td>\n  </tr>\n  <tr>\n      <td>shmat</td>\n      <td>连接共享内存</td>\n  </tr>\n  <tr>\n      <td>shmdt</td>\n      <td>拆卸共享内存</td>\n  </tr>\n</table>\n\n### fork函数\nfork是用来创建子进程的，这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，我们可以通过返回值来判断其返回点：\n```c\npid_t child = fork();\nif( child < 0  ) {     //fork error.\n    perror(\"fork process fail.\\n\");\n} else if( child ==0  ) {   // in child process\n    printf(\" fork succ, this run in child process\\n \");\n} else {                        // in parent process\n    printf(\" this run in parent process\\n \");\n}\n```\n### 僵尸进程\n* [僵尸进程产生原因](#僵尸进程产生原因)\n* [僵尸进程解决办法](#僵尸进程解决办法)\n* [ps指令查看僵尸进程](#ps指令查看僵尸进程)\n\n#### 僵尸进程产生原因\n  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。\n\n#### 僵尸进程解决办法\n1. 通过信号机制\n  子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。\n2. fork两次\n  父进程创建子进程A，子进程A再创建子进程B，然后子进程A退出，z这样子进程B就交给init进程处理了。init进程可以处理僵尸进程.\n\n#### ps指令查看僵尸进程\n```sh\nps -A -ostat,pid,cmd |grep -iE '^z'\n```\n> -A 显示所有任务\n  -o 按照指定格式输出\n  grep -iE 显示z开头的行，不区分大小写\n\n### 常见文件说明\n/var/log/boot.log 系统引导日志\n/var/log/dmesg    系统核心启动日志\n/var/log/messages 核心系统日志\n/var/log/maillog  邮件系统日志\n/var/log/xferlog  FTP系统日志\n/var/log/syslog   系统出问题的日志\n/var/log/secure   安全信息和系统登录与网络连接的信息\n/var/log/wtmp     登录记录\n/var/spool/clientmqueue\n/proc/interrupts\n/etc/fstab        Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.\n### proc目录说明\n```sh\nproc文件系统是一个伪文件系统，它只存在内存当中。\n/proc/buddyinfo   每个内存区中的每个order有多少块可用，和内存碎片问题有关\n/proc/cmdline     启动时传递给kernel的参数信息\n/proc/cpuinfo     cpu的信息\n/proc/crypto      内核使用的所有已安装的加密密码及细节\n/proc/devices     已经加载的设备并分类\n/proc/dma         已注册使用的ISA DMA频道列表\n/proc/execdomains Linux内核当前支持的execution domains\n/proc/fb          帧缓冲设备列表，包括数量和控制它的驱动\n/proc/filesystems 内核当前支持的文件系统类型\n/proc/interrupts  x86架构中的每个IRQ中断数\n/proc/iomem       每个物理设备当前在系统内存中的映射\n/proc/ioports     一个设备的输入输出所使用的注册端口范围\n/proc/kcore       代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb\n/proc/kmsg        记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理\n/proc/loadavg     根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关\n/proc/locks       内核锁住的文件列表\n/proc/mdstat      多硬盘，RAID配置信息(md=multiple disks)\n/proc/meminfo     RAM使用的相关信息\n/proc/misc        其他的主要设备(设备号为10)上注册的驱动\n/proc/modules     所有加载到内核的模块列表\n/proc/mounts      系统中使用的所有挂载\n/proc/mtrr        系统使用的Memory Type Range Registers (MTRRs)\n/proc/partitions  分区中的块分配信息\n/proc/pci         系统中的PCI设备列表\n/proc/slabinfo    系统中所有活动的 slab 缓存信息\n/proc/stat        所有的CPU活动信息\n/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的\n/proc/uptime      系统已经运行了多久\n/proc/swaps       交换空间的使用情况\n/proc/version     Linux内核版本和gcc版本\n/proc/bus         系统总线(Bus)信息，例如pci/usb等\n/proc/driver      驱动信息\n/proc/fs          文件系统信息\n/proc/ide         ide设备信息\n/proc/irq         中断请求设备信息\n/proc/net         网卡设备信息\n/proc/scsi        scsi设备信息\n/proc/tty         tty设备信息\n/proc/net/dev     显示网络适配器及统计信息\n/proc/vmstat      虚拟内存统计信息\n/proc/vmcore      内核panic时的内存映像\n/proc/diskstats   取得磁盘信息\n/proc/schedstat   kernel调度器的统计信息\n/proc/zoneinfo    显示内存空间的统计信息，对分析虚拟内存行为很有用\n#### 以下是/proc目录中进程N的信息\n/proc/N           pid为N的进程信息\n/proc/N/cmdline   进程启动命令\n/proc/N/cwd       链接到进程当前工作目录\n/proc/N/environ   进程环境变量列表\n/proc/N/exe       链接到进程的执行命令文件\n/proc/N/fd        包含进程相关的所有的文件描述符\n/proc/N/maps      与进程相关的内存映射信息\n/proc/N/mem       指代进程持有的内存，不可读\n/proc/N/root      链接到进程的根目录\n/proc/N/stat      进程的状态\n/proc/N/statm     进程使用的内存的状态\n/proc/N/status    进程状态信息，比stat/statm更具可读性\n/proc/self        链接到当前正在运行的进程\n```\n### fopen参数说明\n|参数  |说明|\n|:---:|---|\n| r   |以只读方式打开文件，该文件必须存在。|\n| r+  |以可读写方式打开文件，该文件必须存在。|\n| rb+ |读写打开一个二进制文件，允许读写数据，文件必须存在。|\n| w   |打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。|\n| w+  |打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。|\n| a   |以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）|\n| a+  |以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）|\n| wb  |只写打开或新建一个二进制文件；只允许写数据。|\n| wb+ |读写打开或建立一个二进制文件，允许读和写。|\n| ab+ |读写打开一个二进制文件，允许读或在文件末追加数据。|\n| wx  |创建文本文件,只允许写入数据.[C11]|\n| wbx |创建一个二进制文件,只允许写入数据.[C11]|\n| w+x |创建一个文本文件,允许读写.[C11]|\n| wb+x|创建一个二进制文件,允许读写.[C11]|\n| w+bx|和\"wb+x\"相同[C11]|\n> 以x结尾的模式为独占模式,文件已存在或者无法创建(一般是路径不正确)都会导致fopen失败.文件以操作系统支持的独占模式打开.[C11]\n\n\n\n## linux驱动开发知识点\n\n### insmod rmmod 加载 卸载模块\n### i.max6UL\n#### 系统框图\n![i.max6ul系统框图](./res/IMX6UL-BD.png)\n### linux启动过程\n系统上电--->bootrom--->uboot--->kernel加载--->init--->应用程序\n## makefile\n### makefile的规则\n```makefile\ntarget xxx : prerequisites aaa\n\t[command]\n\t...\n\t...\n```\n> prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行\n\n### gcc工具链\n|命令|描述|\n|---|----|\n|Binutils |由汇编器（as）产生的目标代码（*.o）是不能直接在computer上运行的，它必须经过链接器（ld）的处理才能生成可执行代码。|\n|add2line |将地址转换成文件名或行号对，以便调试程序|\n|ar       |从文件中创建、修改、扩展文件|\n|gasp     |汇编宏处理器|\n|nm       |从目标文件列举所有变量|\n|objcopy  |使用GNU BSD库把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。|\n|objdump  |显示目标文件信息可发编译二进制文件，也可以对对象文件进行反汇编，并查看机器代码。|\n|readelf  |显示elf文件信息|\n|ranlib   |生成索引以加快对归档文件的访问，并将其保存到这个归档文件中。|\n|size     |列出目标模块或文件的代码尺寸。|\n|strings  |打印可打印的目标代码符号（至少4个字符）|\n|strip    |放弃所有符号连接，一般应用程序最终都要strip处理|\n|C++filt  |链接器ld通过该命令可过滤C++符号和JAVA符号，防止重载函数冲突。|\n|gprof    |显示程序调用段的各种数据|\n\n### nm命令\n显示二进制目标文件的符号表\n```sh\n-A：每个符号前显示文件名；\n-D：显示动态符号；\n-g：仅显示外部符号；\n-r：反序显示符号表。\n```\n\n### ldd命令\n用于打印程序或者库文件所依赖的共享库列表。\n```sh\n-v：详细信息模式，打印所有相关信息；\n-u：打印未使用的直接依赖；\n-d：执行重定位和报告任何丢失的对象；\n-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；\n```\n\n### 交叉编译工具链说明\n\n#### gcc 交叉编译器\n> 将写好的C程序代码编译为ARM架构下的可执行文件.\n\n```sh\ngcc hello.c -o hello\n```\n#### ld 交叉链接器\n> 将多个编译后产生的过程文件连接为一个最终的可执行文件。\n\n```sh\nld [options] 链接器脚本 -o 文件名.elf\n```\n#### readelf 交叉ELF文件查看器\n> 用来查看一个可执行文件的相关信息\n\n可以查看elf文件的运行架构，大小端等信息:\n```sh\nreadelf -a 文件名.elf\n```\n显示程序需要的动态链接库:\n```sh\nreadelf -d 文件名.elf\n```\n#### objdump 交叉反汇编器\n> 将一个可执行文件转换为汇编下的程序\n\n```sh\n-objdump -D -S elf文件名 >目标文件\n```\n\n#### objcopy 交叉转换器\n> 将elf格式文件转换成其他的格式\n\n```sh\nobjcopy -O 目标文件格式 原ELF文件 目标文件\n```\n例子:\n```sh\nobjcopy -O binary a.elf a.bin\n```\n","slug":"linux","published":1,"date":"2018-02-28T01:20:58.912Z","updated":"2018-02-28T01:13:19.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbe00089vf7ar4xdxyg","content":"<p>嵌入式笔记：linux软件开发</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#关键命令说明\">关键命令说明</a><ul>\n<li><a href=\"#系统关机命令\">系统关机命令</a></li>\n<li><a href=\"#linux查看文本的指令\">linux查看文本的指令</a></li>\n<li><a href=\"#mount指令\">mount</a></li>\n<li><a href=\"#dmesg\">dmesg</a></li>\n<li><a href=\"#grep\">grep</a></li>\n<li><a href=\"#find\">find</a></li>\n<li><a href=\"#lsusb\">lsusb</a></li>\n<li><a href=\"#lsof\">lsof</a></li>\n</ul>\n</li>\n<li><a href=\"#linux软件开发知识点\">linux软件开发知识点</a><ul>\n<li><a href=\"#linux进程间通讯方式\">linux进程间通讯方式</a></li>\n<li><a href=\"#内存申请函数\">内存申请函数</a></li>\n<li><a href=\"#gcc编译过程\">gcc编译过程</a></li>\n<li><a href=\"#文件系统\">文件系统</a></li>\n<li><a href=\"#硬链接和软连接\">硬链接和软连接</a></li>\n<li><a href=\"#linux内核子系统\">linux内核子系统</a></li>\n<li><a href=\"#进程几种状态\">进程几种状态</a></li>\n<li><a href=\"#文件系统组成\">文件系统组成</a></li>\n<li><a href=\"#linux文件类型\">linux文件类型</a></li>\n<li><a href=\"#linux常用的系统调用函数\">linux常用的系统调用函数</a></li>\n<li><a href=\"#fork函数\">fork函数</a></li>\n<li><a href=\"#僵尸进程\">僵尸进程</a></li>\n<li><a href=\"#常见文件说明\">常见文件说明</a></li>\n<li><a href=\"#/proc目录说明\">/proc目录说明</a></li>\n<li><a href=\"#fopen参数说明\">fopen参数说明</a></li>\n</ul>\n</li>\n<li><a href=\"#linux驱动开发知识点\">linux驱动开发知识点</a></li>\n<li><a href=\"#makefile\">makefile</a></li>\n<li><a href=\"#shell\">shell</a></li>\n</ul>\n<h2 id=\"关键命令说明\"><a href=\"#关键命令说明\" class=\"headerlink\" title=\"关键命令说明\"></a>关键命令说明</h2><ul>\n<li><a href=\"#系统关机命令\">系统关机命令</a></li>\n<li><a href=\"#linux查看文本的指令\">linux查看文本的指令</a></li>\n<li><a href=\"#mount指令\">mount</a></li>\n<li><a href=\"#dmesg\">dmesg</a></li>\n<li><a href=\"#grep\">grep</a></li>\n<li><a href=\"#find\">find</a></li>\n<li><a href=\"#lsusb\">lsusb</a></li>\n<li><a href=\"#lsof\">lsof</a></li>\n</ul>\n<h3 id=\"系统关机命令\"><a href=\"#系统关机命令\" class=\"headerlink\" title=\"系统关机命令\"></a>系统关机命令</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">shutdown</td>\n<td>命令安全地将系统关机。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">halt</td>\n<td>就是调用shutdown -h。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">reboot</td>\n<td>工作过程差不多跟halt一样﹐不过它是引发主机重启</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">poweroff</td>\n<td>就是halt的软链接而已</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">init</td>\n<td>所有进程的祖先﹐它的进程号始终为1﹐init 0为关机﹐init1为重启。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"linux查看文本的指令\"><a href=\"#linux查看文本的指令\" class=\"headerlink\" title=\"linux查看文本的指令\"></a>linux查看文本的指令</h3><table style=\"text-align:center\"><br>   <tr><br>      <td>cat</td><br>      <td>tac</td><br>      <td>sed</td><br>      <td>head</td><br>      <td>tail</td><br>      <td>more</td><br>      <td>less</td><br>      <td>nl</td><br>   </tr><br></table>\n\n<blockquote>\n<p><strong>tac</strong>： cat的反向指令，从最后一行倒序显示全部内容<br><strong>head</strong>： 只显示头几行<br><strong>tail</strong>： 只显示最后几行 tail -f 可以实时显示log文件的更新<br><strong>nl</strong>： 类似于cat -n，显示时输出行号</p>\n</blockquote>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p>命令格式：</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">mount [-t vfstype] [-o options] device dir\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>挂载nfs</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">mount -t nfs 192.168.0.1:/tmp /mnt/nfs \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"dmesg\"><a href=\"#dmesg\" class=\"headerlink\" title=\"dmesg\"></a>dmesg</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">cat /var/log/messages\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>选项</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">-c：只输出匹配行的计数。\n-C：匹配的上下文分别显示[number]行。\n-I：不区分大小写(只适用于单字符)。\n-i：不区分大小写。\n-h：查询多文件时不显示文件名。\n-l：查询多文件时只输出包含匹配字符的文件名。\n-L：列出不匹配的文件名。\n-n：显示匹配行及 行号。\n-s：不显示不存在或无匹配文本的错误信息。\n-v：显示不包含匹配文本的所有行。\n-w：只匹配整个单词。\n-E：扩展的正则表达式\n-R：递归搜寻\n--exclude=FILE：跳过FILE\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>正则表达式主要参数：<br>    \\：忽略正则表达式中特殊字符的原有含义。<br>    ^：匹配正则表达式的开始行。<br>    $：匹配正则表达式的结束行。<br>    \\&lt;：从匹配正则表达式的行开始。<br>    >：到匹配正则表达式的行结束。<br>    []：单个字符，如[A]即A符合要求 。<br>    [-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>    .：所有的单个字符。<br>    *：有字符，长度可以为0。</p>\n<p>经典使用方法</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">#所有以d开头的文件，包含test的匹配行\ngrep \"test\" d*\n#包含test或者zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -inE \"test|zephyr\" d*\n#包含test和zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -in \"test\" d* | grep 'zephyr'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>主要参数：<br>    －c：只输出匹配行的计数。<br>    －I：不区分大小写(只适用于单字符)。<br>    －h：查询多文件时不显示文件名。<br>    －l：查询多文件时只输出包含匹配字符的文件名。<br>    －L：列出不匹配的文件名<br>    －n：显示匹配行及行号。<br>    －s：不显示不存在或无匹配文本的错误信息。<br>    －v：显示不包含匹配文本的所有行。<br>    －R：递归搜寻<br>    －d skip：不递归搜寻<br>    －w：匹配整个单词<br>正则表达式主要参数：<br>    \\：忽略正则表达式中特殊字符的原有含义。<br>    ^：匹配正则表达式的开始行。<br>    $：匹配正则表达式的结束行。<br>    \\&lt;：从匹配正则表达式的行开始。<br>    >：到匹配正则表达式的行结束。<br>    []：单个字符，如[A]即A符合要求 。<br>    [-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>    .：所有的单个字符。<br>    *：有字符，长度可以为0。</p>\n<p>grep ‘test’ d*        显示以d开头的文件中包含的test行<br>grep ‘test’ aa bb cc     查找文件aa bb cc 中匹配的test行<br>grep ‘test’|’hello’ files 匹配test或者hello<br>grep ‘\\&lt;man’ files    匹配manic 和man 不匹配batman<br>grep ‘\\&lt;man>‘        只匹配man 不匹配batman和manic<br>grep ‘^man’ files    匹配的字符行首<br>grep ‘$man’ files    匹配的字符串仔行尾</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>用法</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">find [-path ..] [expression]\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>选项</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">-name     按照文件名\n-iname     按照文件名 忽略大小写\n-perm     按照文件权限\n-user     按照文件拥有者\n-group    按照文件所属的组\n-mtime -n +n 按照文件的更改时间来查找文件， -n：n天以内，+n：n天以前\n-type     查找某一类型：文件类型有：普通文件(f)，目录(d)，字符设备文件(c)，块设备文件(b)，符号链接文件(l)，套接字文件(s)，管道文件(p)\n-size n   查找文件长度为n块（一块等于512字节）的文件，带有c时表示文件长度以字节计。 \n-mount    不跨越文件系统\n-follow   遇到符号链接文件，就跟踪至链接所指向的文件\n-path     匹配文件路径或者文件\n-exec     执行后续命令操作\n-a        and 与操作\n-o        or  或操作\n-not      not 非操作\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>经典使用方法</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">#查找/run中所有的socket文件\nfind /run -type s\n#搜索/dev中所有包含tty的文件\nfind /dev -name \"*tty*\"\n#搜索/dev中大小大于10字节，名称包含bus的文件\nfind /dev -size +10c -name \"*bus*\"\n#或操作，搜索debug开头的文件或者.rst的文件\nfind -name 'debug*' -o -name '*.rst'\n#与操作，搜索debug开头的文件同时是.rst的文件\nfind -name 'debug*' -a -name '*.rst'\n#找出文件大小大于10000块的文件，并复制到当前目录\nfind -size +100000 -exec cp {} . \\;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"lsusb\"><a href=\"#lsusb\" class=\"headerlink\" title=\"lsusb\"></a>lsusb</h3><p>显示系统中以及连接到系统的USB总线信息的工具。</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">$ lsusb\n\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 002 Device 003: ID 17ef:4811 Lenovo Integrated Webcam [R5U877]\nBus 008 Device 002: ID 0a5c:217f Broadcom Corp. Bluetooth Controller\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>Bus 008 : 指明设备连接到哪（哪条总线）<br>Device 002 : 表明这是连接到总线上的第二台设备<br>ID : 设备的ID<br>Broadcom Corp. Bluetooth Controller :生产商名字和设备名</p>\n</blockquote>\n<p>列出USB详细信息</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">$ lsusb -v\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>列出有多少USB设备</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">$ find /dev/bus\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>打印特定设备的详细信息</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">$ lsusb -D /dev/bus/usb/008/002\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"lsof\"><a href=\"#lsof\" class=\"headerlink\" title=\"lsof\"></a>lsof</h3><p>列出当前系统打开文件的工具</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">$ sudo lsof\nCOMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAME\ninit       1         root  cwd      DIR       3,3       1024       2         /\ninit       1         root  rtd      DIR       3,3       1024       2         /\ninit       1         root  txt      REG       3,3       38432      1763452  /sbin/init\ninit       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.so\ninit       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.so\ninit       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1\ninit       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1\ninit       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.so\ninit       1         root  10u      FIFO      0,15                  1309     /dev/initctl\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>COMMAND</td><br>      <td>进程的名称</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>PID</td><br>      <td>进程标识符</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>USER</td><br>      <td>进程所有者</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>FD</td><br>      <td>文件描述符</td><br>      <td>应用程序通过文件描述符识别该文件。如cwd、txt、mem等</td><br>   </tr><br>   <tr><br>      <td>TYPE</td><br>      <td>文件类型</td><br>      <td>REG(文件) DIR(目录) CHR(字符) BLK(块设备) FIFO(管道) UNIX(UNIX 域套接字) IPv4(IP套接字)</td><br>   </tr><br>   <tr><br>      <td>DEVICE</td><br>      <td>指定磁盘的名称</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>SIZE</td><br>      <td>文件大小</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>NODE</td><br>      <td>文件inode</td><br>      <td>每个文件都有一个唯一的inode</td><br>   </tr><br>   <tr><br>      <td>NAME</td><br>      <td>文件名称</td><br>      <td></td><br>   </tr><br></table>\n\n<p>参数列表</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">lsof  filename      显示打开指定文件的所有进程\nlsof -a             表示两个参数都必须满足时才显示结果\nlsof -c string      显示COMMAND列中包含指定字符的进程所有打开的文件\nlsof -u username    显示所属user进程打开的文件\nlsof -g gid         显示归属gid的进程情况\nlsof +d /DIR/       显示目录下被进程打开的文件\nlsof +D /DIR/       同上，但是会搜索目录下的所有目录，时间相对较长\nlsof -d FD          显示指定文件描述符的进程\nlsof -n             不将IP转换为hostname，缺省是不加上-n参数\nlsof -i             用以显示符合条件的进程情况\nlsof -i[46] [protocol][@hostname|hostaddr][:service|port]\n                    46 --> IPv4 or IPv6\n                    protocol --> TCP or UDP\n                    hostname --> Internet host name\n                    hostaddr --> IPv4地址\n                    service --> /etc/service中的 service name (可以不只一个)\n                    port --> 端口号 (可以不只一个)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>查找应用程序打开的文件的名称和数目</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">#显示打开指定文件的所有进程\n$ lsof  filename\n#例如:打开所有使用/dev/urandom的进程\n$ lsof /dev/urandom\n#查看22端口现在运行的情况 \n$ lsof -i :22\n#查看所属xiaxiaowen用户进程所打开的文件类型为txt的文件\n$ lsof -a -u xiaxiaowen -d txt\n#查找谁在使用文件系统\n$ lsof /media/xiaxiaowen/机械硬盘\nCOMMAND  PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nzsh     8465 xiaxiaowen  cwd    DIR   8,17     8192    5 /media/xiaxiaowen/机械硬盘\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"linux软件开发知识点\"><a href=\"#linux软件开发知识点\" class=\"headerlink\" title=\"linux软件开发知识点\"></a>linux软件开发知识点</h2><ul>\n<li><a href=\"#linux进程间通讯方式\">linux进程间通讯方式</a></li>\n<li><a href=\"#内存申请函数\">内存申请函数</a></li>\n<li><a href=\"#linux内存分配说明\">linux内存分配说明</a></li>\n<li><a href=\"#gcc编译过程\">gcc编译过程</a></li>\n<li><a href=\"#文件系统\">文件系统</a></li>\n<li><a href=\"#硬链接和软连接\">硬链接和软连接</a></li>\n<li><a href=\"#linux内核子系统\">linux内核子系统</a></li>\n<li><a href=\"#进程几种状态\">进程几种状态</a></li>\n<li><a href=\"#文件系统组成\">文件系统组成</a></li>\n<li><a href=\"#linux文件类型\">linux文件类型</a></li>\n<li><a href=\"#linux常用的系统调用函数\">linux常用的系统调用函数</a></li>\n<li><a href=\"#fork函数\">fork函数</a></li>\n<li><a href=\"#僵尸进程\">僵尸进程</a></li>\n<li><a href=\"#常见文件说明\">常见文件说明</a></li>\n<li><a href=\"#proc目录说明\">proc目录说明</a></li>\n<li><a href=\"#fopen参数说明\">fopen参数说明</a></li>\n</ul>\n<h3 id=\"linux进程间通讯方式\"><a href=\"#linux进程间通讯方式\" class=\"headerlink\" title=\"linux进程间通讯方式\"></a>linux进程间通讯方式</h3><ol>\n<li>管道（Pipe）及有名管道（named pipe）</li>\n<li>信号（Signal）</li>\n<li>报文（Message）队列（消息队列）：</li>\n<li>共享内存</li>\n<li>信号量（semaphore）</li>\n<li>套接口（Socket）</li>\n</ol>\n<h3 id=\"内存申请函数\"><a href=\"#内存申请函数\" class=\"headerlink\" title=\"内存申请函数\"></a>内存申请函数</h3><ol>\n<li>calloc</li>\n<li>malloc</li>\n<li>realloc<h3 id=\"linux内存分配说明\"><a href=\"#linux内存分配说明\" class=\"headerlink\" title=\"linux内存分配说明\"></a>linux内存分配说明</h3>|内存|存放数据|说明<br>|:—:|—|—|<br>|静态存储区|静态数据、全局数据、常量|在程序编译的时候就已经分配好|<br>|栈区     |局部变量、函数参数|栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限|<br>|堆区     |malloc申请的内存|动态内存分配,需要手动释放|<br>|代码区    |代码|存放函数体的二进制代码|<br>|文字常量区|常量字符串|程序结束后由系统释放|<h3 id=\"gcc编译过程\"><a href=\"#gcc编译过程\" class=\"headerlink\" title=\"gcc编译过程\"></a>gcc编译过程</h3></li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td><strong>过程</strong></td><br>      <td><strong>生成文件</strong></td><br>   </tr><br>   <tr><br>      <td>预编译</td><br>      <td><em>.i</em></td><br>   </tr><br>   <tr><br>      <td>编译</td><br>      <td>.s</td><br>   </tr><br>   <tr><br>      <td>汇编</td><br>      <td>*.o</td><br>   </tr><br>   <tr><br>      <td>链接</td><br>      <td>可执行文件</td><br>   </tr><br></table>\n\n<h3 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h3><table style=\"text-align:center\"><br>   <tr><br>      <td>fat</td><br>      <td>fat32</td><br>      <td>ntfs</td><br>      <td>ext2</td><br>      <td>ext3</td><br>      <td>ext4</td><br>      <td>nfs</td><br>   </tr><br></table>\n\n<h3 id=\"硬链接和软连接\"><a href=\"#硬链接和软连接\" class=\"headerlink\" title=\"硬链接和软连接\"></a>硬链接和软连接</h3><h4 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h4><ul>\n<li>硬链接直接指向文件的i节点</li>\n<li>硬链接和原文件的i节点是一样的</li>\n<li>硬链接文件显示的大小是跟原文件是一样的</li>\n<li>硬链接不能链接目录文件。<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">ln file2 /home/xiaxiaowen/file2hard\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"软链接-符号链接\"><a href=\"#软链接-符号链接\" class=\"headerlink\" title=\"软链接(符号链接)\"></a>软链接(符号链接)</h4></li>\n<li>软链接则是建立了一个新文件</li>\n<li>这个文件指向链接的文件，i节点不一样</li>\n<li>可以链接目录<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">ln -s file2 /home/xiaxiaowen/file2soft\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"linux内核子系统\"><a href=\"#linux内核子系统\" class=\"headerlink\" title=\"linux内核子系统\"></a>linux内核子系统</h3><ol>\n<li>进程管理</li>\n<li>内存管理</li>\n<li>I/O管理</li>\n<li>文件系统管理</li>\n</ol>\n<h3 id=\"进程几种状态\"><a href=\"#进程几种状态\" class=\"headerlink\" title=\"进程几种状态\"></a>进程几种状态</h3><ol>\n<li>运行态</li>\n<li>就绪态</li>\n<li>阻塞态</li>\n</ol>\n<h3 id=\"文件系统组成\"><a href=\"#文件系统组成\" class=\"headerlink\" title=\"文件系统组成\"></a>文件系统组成</h3><ol>\n<li><strong>超级块</strong>：存放文件系统本身的信息，比如记录了每个区域的大小，或未被使用的磁盘块的信息。（不同版本稍有差别）</li>\n<li><strong>i-节点表</strong>：每个文件都有其属性，大小，最近修改时间等等，这些被存储在ino_t 的结构体中，所有的i-节点都有一样的大小，i-节点表就是这样一些节点的列表。（表中的每个i-节点都通过位置来标志，例如标志为2的i-节点位于文件系统i-节点表中的第3个位置 ）</li>\n<li><strong>数据块</strong>：存放文件内容，因为块的大小一定，所以有时一个文件会分布在多个磁盘上。<h3 id=\"i-节点\"><a href=\"#i-节点\" class=\"headerlink\" title=\"i 节点\"></a>i 节点</h3>i 节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.</li>\n</ol>\n<h3 id=\"linux文件类型\"><a href=\"#linux文件类型\" class=\"headerlink\" title=\"linux文件类型\"></a>linux文件类型</h3><table style=\"text-align:center\"><br>   <tr><br>      <td><strong>文件类型</strong></td><br>      <td>普通文件</td><br>      <td>目录</td><br>      <td>字符设备文件</td><br>      <td>块设备文件</td><br>      <td>符号链接文件</td><br>      <td>套接字文件</td><br>      <td>管道文件</td><br>   </tr><br>   <tr><br>      <td><strong>属性</strong></td><br>      <td>-</td><br>      <td>d</td><br>      <td>c</td><br>      <td>b</td><br>      <td>l</td><br>      <td>s</td><br>      <td>p</td><br>   </tr><br></table>\n\n<h3 id=\"linux常用的系统调用函数\"><a href=\"#linux常用的系统调用函数\" class=\"headerlink\" title=\"linux常用的系统调用函数\"></a>linux常用的系统调用函数</h3><ul>\n<li><a href=\"#进程控制函数\">进程控制函数</a></li>\n<li><a href=\"#文件操作函数\">文件操作函数</a></li>\n<li><a href=\"#文件系统操作函数\">文件系统操作函数</a></li>\n<li><a href=\"#系统控制函数\">系统控制函数</a></li>\n<li><a href=\"#内存管理函数\">内存管理函数</a></li>\n<li><a href=\"#网络管理函数\">网络管理函数</a></li>\n<li><a href=\"#socket函数\">socket函数</a></li>\n<li><a href=\"#用户管理函数\">用户管理函数</a></li>\n<li><a href=\"#进程间通信函数\">进程间通信函数</a></li>\n<li><a href=\"#信号相关函数\">信号相关函数</a></li>\n<li><a href=\"#消息相关函数\">消息相关函数</a></li>\n<li><a href=\"#管道相关函数\">管道相关函数</a></li>\n<li><a href=\"#信号量相关函数\">信号量相关函数</a></li>\n<li><a href=\"#共享内存相关函数\">共享内存相关函数</a></li>\n</ul>\n<h4 id=\"进程控制函数\"><a href=\"#进程控制函数\" class=\"headerlink\" title=\"进程控制函数\"></a>进程控制函数</h4><table><br>   <tr style=\"color:red\"><br>      <td>fork</td><br>      <td>创建一个新进程</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>clone</td><br>      <td>按指定条件创建子进程</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>execve</td><br>      <td>运行可执行文件</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>exit</td><br>      <td>中止进程</td><br>   </tr><br>   <tr><br>      <td>_exit</td><br>      <td>立即中止当前进程</td><br>   </tr><br>   <tr><br>      <td>getdtablesize</td><br>      <td>进程所能打开的最大文件数</td><br>   </tr><br>   <tr><br>      <td>getpgid</td><br>      <td>获取指定进程组标识号</td><br>   </tr><br>   <tr><br>      <td>setpgid</td><br>      <td>设置指定进程组标志号</td><br>   </tr><br>   <tr><br>      <td>getpgrp</td><br>      <td>获取当前进程组标识号</td><br>   </tr><br>   <tr><br>      <td>setpgrp</td><br>      <td>设置当前进程组标志号</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>getpid</td><br>          <td>获取进程标识号</td><br>    </tr><br>      <tr><br>          <td>getppid</td><br>          <td>获取父进程标识号</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>getpriority</td><br>          <td>获取调度优先级</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>setpriority</td><br>          <td>设置调度优先级</td><br>    </tr><br>      <tr><br>          <td>modify_ldt</td><br>          <td>读写进程的本地描述表</td><br>    </tr><br>      <tr><br>          <td>nanosleep</td><br>          <td>使进程睡眠指定的时间</td><br>    </tr><br>      <tr><br>          <td>nice</td><br>          <td>改变分时进程的优先级</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>pause</td><br>          <td>挂起进程，等待信号</td><br>    </tr><br>      <tr><br>          <td>personality</td><br>          <td>设置进程运行域</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>prctl</td><br>          <td>对进程进行特定操作</td><br>    </tr><br>      <tr><br>          <td>ptrace</td><br>          <td>进程跟踪</td><br>    </tr><br>      <tr><br>          <td>sched_get_priority_max</td><br>          <td>取得静态优先级的上限</td><br>    </tr><br>      <tr><br>          <td>sched_get_priority_min</td><br>          <td>取得静态优先级的下限</td><br>    </tr><br>      <tr><br>          <td>sched_getparam</td><br>          <td>取得进程的调度参数</td><br>    </tr><br>      <tr><br>          <td>sched_getscheduler</td><br>          <td>取得指定进程的调度策略</td><br>    </tr><br>      <tr><br>          <td>sched_rr_get_interval</td><br>          <td>取得按RR算法调度的实时进程的时间片长度</td><br>    </tr><br>      <tr><br>          <td>sched_setparam</td><br>          <td>设置进程的调度参数</td><br>    </tr><br>      <tr><br>          <td>sched_setscheduler</td><br>          <td>设置指定进程的调度策略和参数</td><br>    </tr><br>      <tr><br>          <td>sched_yield</td><br>          <td>进程主动让出处理器,并将自己等候调度队列队尾</td><br>    </tr><br>      <tr><br>          <td>vfork</td><br>          <td>创建一个子进程，以供执行新程序，常与execve等同时使用</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>wait</td><br>          <td>等待子进程终止</td><br>    </tr><br>      <tr><br>          <td>wait3</td><br>          <td>参见wait</td><br>    </tr><br>      <tr><br>          <td>waitpid</td><br>          <td>等待指定子进程终止</td><br>    </tr><br>      <tr><br>          <td>wait4</td><br>          <td>参见waitpid</td><br>    </tr><br>      <tr><br>          <td>capget</td><br>          <td>获取进程权限</td><br>    </tr><br>      <tr><br>          <td>capset</td><br>          <td>设置进程权限</td><br>    </tr><br>      <tr><br>          <td>getsid</td><br>          <td>获取会晤标识号</td><br>    </tr><br>      <tr><br>          <td>setsid</td><br>          <td>设置会晤标识号</td><br>      </tr><br></table>\n\n<h4 id=\"文件操作函数\"><a href=\"#文件操作函数\" class=\"headerlink\" title=\"文件操作函数\"></a>文件操作函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>fcntl</td><br>      <td>文件控制</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>open</td><br>      <td>打开文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>creat</td><br>      <td>创建新文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>close</td><br>      <td>关闭文件描述字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>read</td><br>      <td>读文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>write</td><br>      <td>写文件</td><br>  </tr><br>  <tr><br>      <td>readv</td><br>      <td>从文件读入数据到缓冲数组中</td><br>  </tr><br>  <tr><br>      <td>writev</td><br>      <td>将缓冲数组里的数据写入文件</td><br>  </tr><br>  <tr><br>      <td>pread</td><br>      <td>对文件随机读</td><br>  </tr><br>  <tr><br>      <td>pwrite</td><br>      <td>对文件随机写</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>lseek</td><br>      <td>移动文件指针</td><br>  </tr><br>  <tr><br>      <td>_llseek</td><br>      <td>在64位地址空间里移动文件指针</td><br>  </tr><br>  <tr><br>      <td>dup</td><br>      <td>复制已打开的文件描述字</td><br>  </tr><br>  <tr><br>      <td>dup2</td><br>      <td>按指定条件复制文件描述字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>flock</td><br>      <td>文件加/解锁</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>poll</td><br>      <td>I/O多路转换</td><br>  </tr><br>  <tr><br>      <td>truncate</td><br>      <td>截断文件</td><br>  </tr><br>  <tr><br>      <td>ftruncate</td><br>      <td>参见truncate</td><br>  </tr><br>  <tr><br>      <td>umask</td><br>      <td>设置文件权限掩码</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>fsync</td><br>      <td>把文件在内存中的部分写回磁盘</td><br>  </tr><br></table>\n\n<h4 id=\"文件系统操作函数\"><a href=\"#文件系统操作函数\" class=\"headerlink\" title=\"文件系统操作函数\"></a>文件系统操作函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>access</td><br>      <td>确定文件的可存取性</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chdir</td><br>      <td>改变当前工作目录</td><br>  </tr><br>  <tr><br>      <td>fchdir</td><br>      <td>参见chdir</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chmod</td><br>      <td>改变文件方式</td><br>  </tr><br>  <tr><br>      <td>fchmod</td><br>      <td>参见chmod</td><br>  </tr><br>  <tr><br>      <td>chown</td><br>      <td>改变文件的属主或用户组</td><br>  </tr><br>  <tr><br>      <td>fchown</td><br>      <td>参见chown</td><br>  </tr><br>  <tr><br>      <td>lchown</td><br>      <td>参见chown</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chroot</td><br>      <td>改变根目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>stat</td><br>      <td>取文件状态信息</td><br>  </tr><br>  <tr><br>      <td>lstat</td><br>      <td>参见stat</td><br>  </tr><br>  <tr><br>      <td>fstat</td><br>      <td>参见stat</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>statfs</td><br>      <td>取文件系统信息</td><br>  </tr><br>  <tr><br>      <td>fstatfs</td><br>      <td>参见statfs</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>readdir</td><br>      <td>读取目录项</td><br>  </tr><br>  <tr><br>      <td>getdents</td><br>      <td>读取目录项</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>mkdir</td><br>      <td>创建目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>mknod</td><br>      <td>创建索引节点</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>rmdir</td><br>      <td>删除目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>rename</td><br>      <td>文件改名</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>link</td><br>      <td>创建链接</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>symlink</td><br>      <td>创建符号链接</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>unlink</td><br>      <td>删除链接</td><br>  </tr><br>  <tr><br>      <td>readlink</td><br>      <td>读符号链接的值</td><br>  </tr><br>  <tr><br>      <td>mount</td><br>      <td>安装文件系统</td><br>  </tr><br>  <tr><br>      <td>umount</td><br>      <td>卸下文件系统</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>ustat</td><br>      <td>取文件系统信息</td><br>  </tr><br>  <tr><br>      <td>utime</td><br>      <td>改变文件的访问修改时间</td><br>  </tr><br>  <tr><br>      <td>utimes</td><br>      <td>参见utime</td><br>  </tr><br>  <tr><br>      <td>quotactl</td><br>      <td>控制磁盘配额</td><br>  </tr><br></table>\n\n<h4 id=\"系统控制函数\"><a href=\"#系统控制函数\" class=\"headerlink\" title=\"系统控制函数\"></a>系统控制函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>ioctl</td><br>      <td>I/O总控制函数</td><br>  </tr><br>  <tr><br>      <td>_sysctl</td><br>      <td>读/写系统参数</td><br>  </tr><br>  <tr><br>      <td>acct</td><br>      <td>启用或禁止进程记账</td><br>  </tr><br>  <tr><br>      <td>getrlimit</td><br>      <td>获取系统资源上限</td><br>  </tr><br>  <tr><br>      <td>setrlimit</td><br>      <td>设置系统资源上限</td><br>  </tr><br>  <tr><br>      <td>getrusage</td><br>      <td>获取系统资源使用情况</td><br>  </tr><br>  <tr><br>      <td>uselib</td><br>      <td>选择要使用的二进制函数库</td><br>  </tr><br>  <tr><br>      <td>ioperm</td><br>      <td>设置端口I/O权限</td><br>  </tr><br>  <tr><br>      <td>iopl</td><br>      <td>改变进程I/O权限级别</td><br>  </tr><br>  <tr><br>      <td>outb</td><br>      <td>低级端口操作</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>reboot</td><br>      <td>重新启动</td><br>  </tr><br>  <tr><br>      <td>swapon</td><br>      <td>打开交换文件和设备</td><br>  </tr><br>  <tr><br>      <td>swapoff</td><br>      <td>关闭交换文件和设备</td><br>  </tr><br>  <tr><br>      <td>bdflush</td><br>      <td>控制bdflush守护进程</td><br>  </tr><br>  <tr><br>      <td>sysfs</td><br>      <td>取核心支持的文件系统类型</td><br>  </tr><br>  <tr><br>      <td>sysinfo</td><br>      <td>取得系统信息</td><br>  </tr><br>  <tr><br>      <td>adjtimex</td><br>      <td>调整系统时钟</td><br>  </tr><br>  <tr><br>      <td>alarm</td><br>      <td>设置进程的闹钟</td><br>  </tr><br>  <tr><br>      <td>getitimer</td><br>      <td>获取计时器值</td><br>  </tr><br>  <tr><br>      <td>setitimer</td><br>      <td>设置计时器值</td><br>  </tr><br>  <tr><br>      <td>gettimeofday</td><br>      <td>取时间和时区</td><br>  </tr><br>  <tr><br>      <td>settimeofday</td><br>      <td>设置时间和时区</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>stime</td><br>      <td>设置系统日期和时间</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>time</td><br>      <td>取得系统时间</td><br>  </tr><br>  <tr><br>      <td>times</td><br>      <td>取进程运行时间</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>uname</td><br>      <td>获取当前UNIX系统的名称、版本和主机等信息</td><br>  </tr><br>  <tr><br>      <td>vhangup</td><br>      <td>挂起当前终端</td><br>  </tr><br>  <tr><br>      <td>nfsservctl</td><br>      <td>对NFS守护进程进行控制</td><br>  </tr><br>  <tr><br>      <td>vm86</td><br>      <td>进入模拟8086模式</td><br>  </tr><br>  <tr><br>      <td>create_module</td><br>      <td>创建可装载的模块项</td><br>  </tr><br>  <tr><br>      <td>delete_module</td><br>      <td>删除可装载的模块项</td><br>  </tr><br>  <tr><br>      <td>init_module</td><br>      <td>初始化模块</td><br>  </tr><br>  <tr><br>      <td>query_module</td><br>      <td>查询模块信息</td><br>  </tr><br>  <tr><br>      <td>*get_kernel_syms</td><br>      <td>取得核心符号,已被query_module代替</td><br>  </tr><br></table>\n\n<h4 id=\"内存管理函数\"><a href=\"#内存管理函数\" class=\"headerlink\" title=\"内存管理函数\"></a>内存管理函数</h4><table><br>  <tr><br>      <td>brk</td><br>      <td>改变数据段空间的分配</td><br>  </tr><br>  <tr><br>      <td>sbrk</td><br>      <td>参见brk</td><br>  </tr><br>  <tr><br>      <td>mlock</td><br>      <td>内存页面加锁</td><br>  </tr><br>  <tr><br>      <td>munlock</td><br>      <td>内存页面解锁</td><br>  </tr><br>  <tr><br>      <td>mlockall</td><br>      <td>调用进程所有内存页面加锁</td><br>  </tr><br>    <tr><br>      <td>munlockall</td><br>      <td>调用进程所有内存页面解锁</td><br>  </tr><br>  <tr><br>      <td>mmap</td><br>      <td>映射虚拟内存页</td><br>  </tr><br>  <tr><br>      <td>munmap</td><br>      <td>去除内存页映射</td><br>  </tr><br>  <tr><br>      <td>mremap</td><br>      <td>重新映射虚拟内存地址</td><br>  </tr><br>  <tr><br>      <td>msync</td><br>      <td>将映射内存中的数据写回磁盘</td><br>  </tr><br>  <tr><br>      <td>mprotect</td><br>      <td>设置内存映像保护</td><br>  </tr><br>  <tr><br>      <td>getpagesize</td><br>      <td>获取页面大小</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sync</td><br>      <td>将内存缓冲区数据写回硬盘</td><br>  </tr><br>  <tr><br>      <td>cacheflush</td><br>      <td>dddd将指定缓冲区中的内容写回磁盘dd</td><br>  </tr><br></table>\n\n<h4 id=\"网络管理函数\"><a href=\"#网络管理函数\" class=\"headerlink\" title=\"网络管理函数\"></a>网络管理函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>getdomainname</td><br>      <td>取域名</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>setdomainname</td><br>      <td>设置域名</td><br>  </tr><br>  <tr><br>      <td>gethostid</td><br>      <td>获取主机标识号</td><br>  </tr><br>  <tr><br>      <td>sethostid</td><br>      <td>设置主机标识号</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>gethostname</td><br>      <td>获取本主机名称</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sethostname</td><br>      <td>设置主机名称</td><br>  </tr><br></table>\n\n<h4 id=\"socket函数\"><a href=\"#socket函数\" class=\"headerlink\" title=\"socket函数\"></a>socket函数</h4><table><br>  <tr><br>      <td>socketcall</td><br>      <td>socket系统调用</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>socket</td><br>      <td>建立socket</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>bind</td><br>      <td>绑定socket到端口</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>connect</td><br>      <td>连接远程主机</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>accept</td><br>      <td>响应socket连接请求</td><br>  </tr><br>    <tr><br>      <td>send</td><br>      <td>通过socket发送信息</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sendto</td><br>      <td>发送UDP信息</td><br>  </tr><br>  <tr><br>      <td>sendmsg</td><br>      <td>参见send</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>recv</td><br>      <td>通过socket接收信息</td><br>  </tr><br>    <tr style=\"color:red\"><br>      <td>recvfrom</td><br>      <td>接收UDP信息</td><br>  </tr><br>  <tr><br>      <td>recvmsg</td><br>      <td>参见recv</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>listen</td><br>      <td>监听socket端口</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>select</td><br>      <td>对多路同步I/O进行轮询</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>close</td><br>      <td>关闭socket上的连接</td><br>  </tr><br>  <tr><br>      <td>getsockname</td><br>      <td>取得本地socket名字</td><br>  </tr><br>  <tr><br>      <td>getpeername</td><br>      <td>获取通信对方的socket名字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>getsockopt</td><br>      <td>取端口设置</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>setsockopt</td><br>      <td>设置端口参数</td><br>  </tr><br>  <tr><br>      <td>sendfile</td><br>      <td>在文件或端口间传输数据</td><br>  </tr><br>  <tr><br>      <td>socketpair</td><br>      <td>创建一对已联接的无名socket</td><br>  </tr><br></table>\n\n<h4 id=\"用户管理函数\"><a href=\"#用户管理函数\" class=\"headerlink\" title=\"用户管理函数\"></a>用户管理函数</h4><table><br>  <tr><br>      <td>getuid</td><br>      <td>获取用户标识号</td><br>  </tr><br>  <tr><br>      <td>setuid</td><br>      <td>设置用户标志号</td><br>  </tr><br>  <tr><br>      <td>getgid</td><br>      <td>获取组标识号</td><br>  </tr><br>  <tr><br>      <td>setgid</td><br>      <td>设置组标志号</td><br>  </tr><br>  <tr><br>      <td>getegid</td><br>      <td>获取有效组标识号</td><br>  </tr><br>  <tr><br>      <td>setegid</td><br>      <td>设置有效组标识号</td><br>  </tr><br>  <tr><br>      <td>geteuid</td><br>      <td>获取有效用户标识号</td><br>  </tr><br>  <tr><br>      <td>seteuid</td><br>      <td>设置有效用户标识号</td><br>  </tr><br>  <tr><br>      <td>setregid</td><br>      <td>分别设置真实和有效的的组标识号</td><br>  </tr><br>  <tr><br>      <td>setreuid</td><br>      <td>分别设置真实和有效的用户标识号</td><br>  </tr><br>  <tr><br>      <td>getresgid</td><br>      <td>分别获取真实的,有效的和保存过的组标识号</td><br>  </tr><br>  <tr><br>      <td>setresgid</td><br>      <td>分别设置真实的,有效的和保存过的组标识号</td><br>  </tr><br>  <tr><br>      <td>getresuid</td><br>      <td>分别获取真实的,有效的和保存过的用户标识号</td><br>  </tr><br>  <tr><br>      <td>setresuid</td><br>      <td>分别设置真实的,有效的和保存过的用户标识号</td><br>  </tr><br>  <tr><br>      <td>setfsgid</td><br>      <td>设置文件系统检查时使用的组标识号</td><br>  </tr><br>  <tr><br>      <td>setfsuid</td><br>      <td>设置文件系统检查时使用的用户标识号</td><br>  </tr><br>  <tr><br>      <td>getgroups</td><br>      <td>获取后补组标志清单</td><br>  </tr><br>  <tr><br>      <td>setgroups</td><br>      <td>设置后补组标志清单</td><br>  </tr><br></table>\n\n<h4 id=\"进程间通信函数\"><a href=\"#进程间通信函数\" class=\"headerlink\" title=\"进程间通信函数\"></a>进程间通信函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>ipc</td><br>      <td>进程间通信总控制调用</td><br>  </tr><br></table>\n\n<h4 id=\"信号相关函数\"><a href=\"#信号相关函数\" class=\"headerlink\" title=\"信号相关函数\"></a>信号相关函数</h4><table><br>  <tr><br>      <td>sigaction</td><br>      <td>设置对指定信号的处理方法</td><br>  </tr><br>  <tr><br>      <td>sigprocmask</td><br>      <td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td><br>  </tr><br>  <tr><br>      <td>sigpending</td><br>      <td>为指定的被阻塞信号设置队列</td><br>  </tr><br>  <tr><br>      <td>sigsuspend</td><br>      <td>挂起进程等待特定信号</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>signal</td><br>      <td>参见signal</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>kill</td><br>      <td>向进程或进程组发信号</td><br>  </tr><br>  <tr><br>      <td><em>sigblock</em></td><br>      <td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>siggetmask</td><br>      <td>取得现有阻塞信号掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td><em>sigsetmask</em></td><br>      <td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>sigmask</td><br>      <td>将给定的信号转化为掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>*sigpause</td><br>      <td>作用同sigsuspend,已被sigsuspend代替</td><br>  </tr><br>  <tr><br>      <td>sigvec</td><br>      <td>为兼容BSD而设的信号处理函数,作用类似sigaction</td><br>  </tr><br>  <tr><br>      <td>ssetmask</td><br>      <td>ANSI C的信号处理函数,作用类似sigaction</td><br>  </tr><br></table>\n\n<h4 id=\"消息相关函数\"><a href=\"#消息相关函数\" class=\"headerlink\" title=\"消息相关函数\"></a>消息相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>msgctl</td><br>      <td>消息控制操作</td><br>  </tr><br>  <tr><br>      <td>msgget</td><br>      <td>获取消息队列</td><br>  </tr><br>  <tr><br>      <td>msgsnd</td><br>      <td>发消息</td><br>  </tr><br>  <tr><br>      <td>msgrcv</td><br>      <td>取消息</td><br>  </tr><br></table>\n\n<h4 id=\"管道相关函数\"><a href=\"#管道相关函数\" class=\"headerlink\" title=\"管道相关函数\"></a>管道相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>pipe</td><br>      <td>创建管道</td><br>  </tr><br></table>\n\n<h4 id=\"信号量相关函数\"><a href=\"#信号量相关函数\" class=\"headerlink\" title=\"信号量相关函数\"></a>信号量相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>semctl</td><br>      <td>信号量控制</td><br>  </tr><br>  <tr><br>      <td>semget</td><br>      <td>获取一组信号量</td><br>  </tr><br>  <tr><br>      <td>semop</td><br>      <td>信号量操作</td><br>  </tr><br></table>\n\n<h4 id=\"共享内存相关函数\"><a href=\"#共享内存相关函数\" class=\"headerlink\" title=\"共享内存相关函数\"></a>共享内存相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>shmctl</td><br>      <td>控制共享内存</td><br>  </tr><br>  <tr><br>      <td>shmget</td><br>      <td>获取共享内存</td><br>  </tr><br>  <tr><br>      <td>shmat</td><br>      <td>连接共享内存</td><br>  </tr><br>  <tr><br>      <td>shmdt</td><br>      <td>拆卸共享内存</td><br>  </tr><br></table>\n\n<h3 id=\"fork函数\"><a href=\"#fork函数\" class=\"headerlink\" title=\"fork函数\"></a>fork函数</h3><p>fork是用来创建子进程的，这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，我们可以通过返回值来判断其返回点：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">pid_t child <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> child <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span>  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>     <span class=\"token comment\" spellcheck=\"true\">//fork error.</span>\n    <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fork process fail.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> child <span class=\"token operator\">==</span><span class=\"token number\">0</span>  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   <span class=\"token comment\" spellcheck=\"true\">// in child process</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" fork succ, this run in child process\\n \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\" spellcheck=\"true\">// in parent process</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" this run in parent process\\n \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h3><ul>\n<li><a href=\"#僵尸进程产生原因\">僵尸进程产生原因</a></li>\n<li><a href=\"#僵尸进程解决办法\">僵尸进程解决办法</a></li>\n<li><a href=\"#ps指令查看僵尸进程\">ps指令查看僵尸进程</a></li>\n</ul>\n<h4 id=\"僵尸进程产生原因\"><a href=\"#僵尸进程产生原因\" class=\"headerlink\" title=\"僵尸进程产生原因\"></a>僵尸进程产生原因</h4><p>  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。</p>\n<h4 id=\"僵尸进程解决办法\"><a href=\"#僵尸进程解决办法\" class=\"headerlink\" title=\"僵尸进程解决办法\"></a>僵尸进程解决办法</h4><ol>\n<li>通过信号机制<br>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</li>\n<li>fork两次<br>父进程创建子进程A，子进程A再创建子进程B，然后子进程A退出，z这样子进程B就交给init进程处理了。init进程可以处理僵尸进程.</li>\n</ol>\n<h4 id=\"ps指令查看僵尸进程\"><a href=\"#ps指令查看僵尸进程\" class=\"headerlink\" title=\"ps指令查看僵尸进程\"></a>ps指令查看僵尸进程</h4><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">ps -A -ostat,pid,cmd |grep -iE '^z'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>-A 显示所有任务<br>  -o 按照指定格式输出<br>  grep -iE 显示z开头的行，不区分大小写</p>\n</blockquote>\n<h3 id=\"常见文件说明\"><a href=\"#常见文件说明\" class=\"headerlink\" title=\"常见文件说明\"></a>常见文件说明</h3><p>/var/log/boot.log 系统引导日志<br>/var/log/dmesg    系统核心启动日志<br>/var/log/messages 核心系统日志<br>/var/log/maillog  邮件系统日志<br>/var/log/xferlog  FTP系统日志<br>/var/log/syslog   系统出问题的日志<br>/var/log/secure   安全信息和系统登录与网络连接的信息<br>/var/log/wtmp     登录记录<br>/var/spool/clientmqueue<br>/proc/interrupts<br>/etc/fstab        Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.</p>\n<h3 id=\"proc目录说明\"><a href=\"#proc目录说明\" class=\"headerlink\" title=\"proc目录说明\"></a>proc目录说明</h3><pre class=\"line-numbers language-sh\"><code class=\"language-sh\">proc文件系统是一个伪文件系统，它只存在内存当中。\n/proc/buddyinfo   每个内存区中的每个order有多少块可用，和内存碎片问题有关\n/proc/cmdline     启动时传递给kernel的参数信息\n/proc/cpuinfo     cpu的信息\n/proc/crypto      内核使用的所有已安装的加密密码及细节\n/proc/devices     已经加载的设备并分类\n/proc/dma         已注册使用的ISA DMA频道列表\n/proc/execdomains Linux内核当前支持的execution domains\n/proc/fb          帧缓冲设备列表，包括数量和控制它的驱动\n/proc/filesystems 内核当前支持的文件系统类型\n/proc/interrupts  x86架构中的每个IRQ中断数\n/proc/iomem       每个物理设备当前在系统内存中的映射\n/proc/ioports     一个设备的输入输出所使用的注册端口范围\n/proc/kcore       代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb\n/proc/kmsg        记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理\n/proc/loadavg     根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关\n/proc/locks       内核锁住的文件列表\n/proc/mdstat      多硬盘，RAID配置信息(md=multiple disks)\n/proc/meminfo     RAM使用的相关信息\n/proc/misc        其他的主要设备(设备号为10)上注册的驱动\n/proc/modules     所有加载到内核的模块列表\n/proc/mounts      系统中使用的所有挂载\n/proc/mtrr        系统使用的Memory Type Range Registers (MTRRs)\n/proc/partitions  分区中的块分配信息\n/proc/pci         系统中的PCI设备列表\n/proc/slabinfo    系统中所有活动的 slab 缓存信息\n/proc/stat        所有的CPU活动信息\n/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的\n/proc/uptime      系统已经运行了多久\n/proc/swaps       交换空间的使用情况\n/proc/version     Linux内核版本和gcc版本\n/proc/bus         系统总线(Bus)信息，例如pci/usb等\n/proc/driver      驱动信息\n/proc/fs          文件系统信息\n/proc/ide         ide设备信息\n/proc/irq         中断请求设备信息\n/proc/net         网卡设备信息\n/proc/scsi        scsi设备信息\n/proc/tty         tty设备信息\n/proc/net/dev     显示网络适配器及统计信息\n/proc/vmstat      虚拟内存统计信息\n/proc/vmcore      内核panic时的内存映像\n/proc/diskstats   取得磁盘信息\n/proc/schedstat   kernel调度器的统计信息\n/proc/zoneinfo    显示内存空间的统计信息，对分析虚拟内存行为很有用\n#### 以下是/proc目录中进程N的信息\n/proc/N           pid为N的进程信息\n/proc/N/cmdline   进程启动命令\n/proc/N/cwd       链接到进程当前工作目录\n/proc/N/environ   进程环境变量列表\n/proc/N/exe       链接到进程的执行命令文件\n/proc/N/fd        包含进程相关的所有的文件描述符\n/proc/N/maps      与进程相关的内存映射信息\n/proc/N/mem       指代进程持有的内存，不可读\n/proc/N/root      链接到进程的根目录\n/proc/N/stat      进程的状态\n/proc/N/statm     进程使用的内存的状态\n/proc/N/status    进程状态信息，比stat/statm更具可读性\n/proc/self        链接到当前正在运行的进程\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"fopen参数说明\"><a href=\"#fopen参数说明\" class=\"headerlink\" title=\"fopen参数说明\"></a>fopen参数说明</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td>以只读方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r+</td>\n<td>以可读写方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb+</td>\n<td>读写打开一个二进制文件，允许读写数据，文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td>打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+</td>\n<td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a+</td>\n<td>以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb</td>\n<td>只写打开或新建一个二进制文件；只允许写数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb+</td>\n<td>读写打开或建立一个二进制文件，允许读和写。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ab+</td>\n<td>读写打开一个二进制文件，允许读或在文件末追加数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wx</td>\n<td>创建文本文件,只允许写入数据.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wbx</td>\n<td>创建一个二进制文件,只允许写入数据.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+x</td>\n<td>创建一个文本文件,允许读写.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb+x</td>\n<td>创建一个二进制文件,允许读写.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+bx</td>\n<td>和”wb+x”相同[C11]</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>以x结尾的模式为独占模式,文件已存在或者无法创建(一般是路径不正确)都会导致fopen失败.文件以操作系统支持的独占模式打开.[C11]</p>\n</blockquote>\n<h2 id=\"linux驱动开发知识点\"><a href=\"#linux驱动开发知识点\" class=\"headerlink\" title=\"linux驱动开发知识点\"></a>linux驱动开发知识点</h2><h3 id=\"insmod-rmmod-加载-卸载模块\"><a href=\"#insmod-rmmod-加载-卸载模块\" class=\"headerlink\" title=\"insmod rmmod 加载 卸载模块\"></a>insmod rmmod 加载 卸载模块</h3><h3 id=\"i-max6UL\"><a href=\"#i-max6UL\" class=\"headerlink\" title=\"i.max6UL\"></a>i.max6UL</h3><h4 id=\"系统框图\"><a href=\"#系统框图\" class=\"headerlink\" title=\"系统框图\"></a>系统框图</h4><p><img src=\"./res/IMX6UL-BD.png\" alt=\"i.max6ul系统框图\"></p>\n<h3 id=\"linux启动过程\"><a href=\"#linux启动过程\" class=\"headerlink\" title=\"linux启动过程\"></a>linux启动过程</h3><p>系统上电—&gt;bootrom—&gt;uboot—&gt;kernel加载—&gt;init—&gt;应用程序</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><h3 id=\"makefile的规则\"><a href=\"#makefile的规则\" class=\"headerlink\" title=\"makefile的规则\"></a>makefile的规则</h3><pre class=\"line-numbers language-makefile\"><code class=\"language-makefile\"><span class=\"token symbol\">target xxx </span><span class=\"token punctuation\">:</span> prerequisites aaa\n    [command]\n    ...\n    ...\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p>\n</blockquote>\n<h3 id=\"gcc工具链\"><a href=\"#gcc工具链\" class=\"headerlink\" title=\"gcc工具链\"></a>gcc工具链</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Binutils</td>\n<td>由汇编器（as）产生的目标代码（*.o）是不能直接在computer上运行的，它必须经过链接器（ld）的处理才能生成可执行代码。</td>\n</tr>\n<tr>\n<td>add2line</td>\n<td>将地址转换成文件名或行号对，以便调试程序</td>\n</tr>\n<tr>\n<td>ar</td>\n<td>从文件中创建、修改、扩展文件</td>\n</tr>\n<tr>\n<td>gasp</td>\n<td>汇编宏处理器</td>\n</tr>\n<tr>\n<td>nm</td>\n<td>从目标文件列举所有变量</td>\n</tr>\n<tr>\n<td>objcopy</td>\n<td>使用GNU BSD库把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。</td>\n</tr>\n<tr>\n<td>objdump</td>\n<td>显示目标文件信息可发编译二进制文件，也可以对对象文件进行反汇编，并查看机器代码。</td>\n</tr>\n<tr>\n<td>readelf</td>\n<td>显示elf文件信息</td>\n</tr>\n<tr>\n<td>ranlib</td>\n<td>生成索引以加快对归档文件的访问，并将其保存到这个归档文件中。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>列出目标模块或文件的代码尺寸。</td>\n</tr>\n<tr>\n<td>strings</td>\n<td>打印可打印的目标代码符号（至少4个字符）</td>\n</tr>\n<tr>\n<td>strip</td>\n<td>放弃所有符号连接，一般应用程序最终都要strip处理</td>\n</tr>\n<tr>\n<td>C++filt</td>\n<td>链接器ld通过该命令可过滤C++符号和JAVA符号，防止重载函数冲突。</td>\n</tr>\n<tr>\n<td>gprof</td>\n<td>显示程序调用段的各种数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nm命令\"><a href=\"#nm命令\" class=\"headerlink\" title=\"nm命令\"></a>nm命令</h3><p>显示二进制目标文件的符号表</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">-A：每个符号前显示文件名；\n-D：显示动态符号；\n-g：仅显示外部符号；\n-r：反序显示符号表。\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"ldd命令\"><a href=\"#ldd命令\" class=\"headerlink\" title=\"ldd命令\"></a>ldd命令</h3><p>用于打印程序或者库文件所依赖的共享库列表。</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">-v：详细信息模式，打印所有相关信息；\n-u：打印未使用的直接依赖；\n-d：执行重定位和报告任何丢失的对象；\n-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"交叉编译工具链说明\"><a href=\"#交叉编译工具链说明\" class=\"headerlink\" title=\"交叉编译工具链说明\"></a>交叉编译工具链说明</h3><h4 id=\"gcc-交叉编译器\"><a href=\"#gcc-交叉编译器\" class=\"headerlink\" title=\"gcc 交叉编译器\"></a>gcc 交叉编译器</h4><blockquote>\n<p>将写好的C程序代码编译为ARM架构下的可执行文件.</p>\n</blockquote>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">gcc hello.c -o hello\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"ld-交叉链接器\"><a href=\"#ld-交叉链接器\" class=\"headerlink\" title=\"ld 交叉链接器\"></a>ld 交叉链接器</h4><blockquote>\n<p>将多个编译后产生的过程文件连接为一个最终的可执行文件。</p>\n</blockquote>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">ld [options] 链接器脚本 -o 文件名.elf\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"readelf-交叉ELF文件查看器\"><a href=\"#readelf-交叉ELF文件查看器\" class=\"headerlink\" title=\"readelf 交叉ELF文件查看器\"></a>readelf 交叉ELF文件查看器</h4><blockquote>\n<p>用来查看一个可执行文件的相关信息</p>\n</blockquote>\n<p>可以查看elf文件的运行架构，大小端等信息:</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">readelf -a 文件名.elf\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>显示程序需要的动态链接库:</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">readelf -d 文件名.elf\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"objdump-交叉反汇编器\"><a href=\"#objdump-交叉反汇编器\" class=\"headerlink\" title=\"objdump 交叉反汇编器\"></a>objdump 交叉反汇编器</h4><blockquote>\n<p>将一个可执行文件转换为汇编下的程序</p>\n</blockquote>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">-objdump -D -S elf文件名 >目标文件\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"objcopy-交叉转换器\"><a href=\"#objcopy-交叉转换器\" class=\"headerlink\" title=\"objcopy 交叉转换器\"></a>objcopy 交叉转换器</h4><blockquote>\n<p>将elf格式文件转换成其他的格式</p>\n</blockquote>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">objcopy -O 目标文件格式 原ELF文件 目标文件\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>例子:</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">objcopy -O binary a.elf a.bin\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：linux软件开发</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#关键命令说明\">关键命令说明</a><ul>\n<li><a href=\"#系统关机命令\">系统关机命令</a></li>\n<li><a href=\"#linux查看文本的指令\">linux查看文本的指令</a></li>\n<li><a href=\"#mount指令\">mount</a></li>\n<li><a href=\"#dmesg\">dmesg</a></li>\n<li><a href=\"#grep\">grep</a></li>\n<li><a href=\"#find\">find</a></li>\n<li><a href=\"#lsusb\">lsusb</a></li>\n<li><a href=\"#lsof\">lsof</a></li>\n</ul>\n</li>\n<li><a href=\"#linux软件开发知识点\">linux软件开发知识点</a><ul>\n<li><a href=\"#linux进程间通讯方式\">linux进程间通讯方式</a></li>\n<li><a href=\"#内存申请函数\">内存申请函数</a></li>\n<li><a href=\"#gcc编译过程\">gcc编译过程</a></li>\n<li><a href=\"#文件系统\">文件系统</a></li>\n<li><a href=\"#硬链接和软连接\">硬链接和软连接</a></li>\n<li><a href=\"#linux内核子系统\">linux内核子系统</a></li>\n<li><a href=\"#进程几种状态\">进程几种状态</a></li>\n<li><a href=\"#文件系统组成\">文件系统组成</a></li>\n<li><a href=\"#linux文件类型\">linux文件类型</a></li>\n<li><a href=\"#linux常用的系统调用函数\">linux常用的系统调用函数</a></li>\n<li><a href=\"#fork函数\">fork函数</a></li>\n<li><a href=\"#僵尸进程\">僵尸进程</a></li>\n<li><a href=\"#常见文件说明\">常见文件说明</a></li>\n<li><a href=\"#/proc目录说明\">/proc目录说明</a></li>\n<li><a href=\"#fopen参数说明\">fopen参数说明</a></li>\n</ul>\n</li>\n<li><a href=\"#linux驱动开发知识点\">linux驱动开发知识点</a></li>\n<li><a href=\"#makefile\">makefile</a></li>\n<li><a href=\"#shell\">shell</a></li>\n</ul>\n<h2 id=\"关键命令说明\"><a href=\"#关键命令说明\" class=\"headerlink\" title=\"关键命令说明\"></a>关键命令说明</h2><ul>\n<li><a href=\"#系统关机命令\">系统关机命令</a></li>\n<li><a href=\"#linux查看文本的指令\">linux查看文本的指令</a></li>\n<li><a href=\"#mount指令\">mount</a></li>\n<li><a href=\"#dmesg\">dmesg</a></li>\n<li><a href=\"#grep\">grep</a></li>\n<li><a href=\"#find\">find</a></li>\n<li><a href=\"#lsusb\">lsusb</a></li>\n<li><a href=\"#lsof\">lsof</a></li>\n</ul>\n<h3 id=\"系统关机命令\"><a href=\"#系统关机命令\" class=\"headerlink\" title=\"系统关机命令\"></a>系统关机命令</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">指令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">shutdown</td>\n<td>命令安全地将系统关机。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">halt</td>\n<td>就是调用shutdown -h。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">reboot</td>\n<td>工作过程差不多跟halt一样﹐不过它是引发主机重启</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">poweroff</td>\n<td>就是halt的软链接而已</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">init</td>\n<td>所有进程的祖先﹐它的进程号始终为1﹐init 0为关机﹐init1为重启。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"linux查看文本的指令\"><a href=\"#linux查看文本的指令\" class=\"headerlink\" title=\"linux查看文本的指令\"></a>linux查看文本的指令</h3><table style=\"text-align:center\"><br>   <tr><br>      <td>cat</td><br>      <td>tac</td><br>      <td>sed</td><br>      <td>head</td><br>      <td>tail</td><br>      <td>more</td><br>      <td>less</td><br>      <td>nl</td><br>   </tr><br></table>\n\n<blockquote>\n<p><strong>tac</strong>： cat的反向指令，从最后一行倒序显示全部内容<br><strong>head</strong>： 只显示头几行<br><strong>tail</strong>： 只显示最后几行 tail -f 可以实时显示log文件的更新<br><strong>nl</strong>： 类似于cat -n，显示时输出行号</p>\n</blockquote>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p>命令格式：</p>\n<pre><code class=\"sh\">mount [-t vfstype] [-o options] device dir\n</code></pre>\n<p>挂载nfs</p>\n<pre><code class=\"sh\">mount -t nfs 192.168.0.1:/tmp /mnt/nfs \n</code></pre>\n<h3 id=\"dmesg\"><a href=\"#dmesg\" class=\"headerlink\" title=\"dmesg\"></a>dmesg</h3><pre><code class=\"sh\">cat /var/log/messages\n</code></pre>\n<h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>选项</p>\n<pre><code class=\"sh\">-c：只输出匹配行的计数。\n-C：匹配的上下文分别显示[number]行。\n-I：不区分大小写(只适用于单字符)。\n-i：不区分大小写。\n-h：查询多文件时不显示文件名。\n-l：查询多文件时只输出包含匹配字符的文件名。\n-L：列出不匹配的文件名。\n-n：显示匹配行及 行号。\n-s：不显示不存在或无匹配文本的错误信息。\n-v：显示不包含匹配文本的所有行。\n-w：只匹配整个单词。\n-E：扩展的正则表达式\n-R：递归搜寻\n--exclude=FILE：跳过FILE\n</code></pre>\n<p>正则表达式主要参数：<br>    \\：忽略正则表达式中特殊字符的原有含义。<br>    ^：匹配正则表达式的开始行。<br>    $：匹配正则表达式的结束行。<br>    \\&lt;：从匹配正则表达式的行开始。<br>    >：到匹配正则表达式的行结束。<br>    []：单个字符，如[A]即A符合要求 。<br>    [-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>    .：所有的单个字符。<br>    *：有字符，长度可以为0。</p>\n<p>经典使用方法</p>\n<pre><code class=\"sh\">#所有以d开头的文件，包含test的匹配行\ngrep &quot;test&quot; d*\n#包含test或者zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -inE &quot;test|zephyr&quot; d*\n#包含test和zephyr 不区分大小写 显示行号 扩展正则表达式\ngrep -in &quot;test&quot; d* | grep &#39;zephyr&#39;\n</code></pre>\n<p>主要参数：<br>    －c：只输出匹配行的计数。<br>    －I：不区分大小写(只适用于单字符)。<br>    －h：查询多文件时不显示文件名。<br>    －l：查询多文件时只输出包含匹配字符的文件名。<br>    －L：列出不匹配的文件名<br>    －n：显示匹配行及行号。<br>    －s：不显示不存在或无匹配文本的错误信息。<br>    －v：显示不包含匹配文本的所有行。<br>    －R：递归搜寻<br>    －d skip：不递归搜寻<br>    －w：匹配整个单词<br>正则表达式主要参数：<br>    \\：忽略正则表达式中特殊字符的原有含义。<br>    ^：匹配正则表达式的开始行。<br>    $：匹配正则表达式的结束行。<br>    \\&lt;：从匹配正则表达式的行开始。<br>    >：到匹配正则表达式的行结束。<br>    []：单个字符，如[A]即A符合要求 。<br>    [-]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>    .：所有的单个字符。<br>    *：有字符，长度可以为0。</p>\n<p>grep ‘test’ d*        显示以d开头的文件中包含的test行<br>grep ‘test’ aa bb cc     查找文件aa bb cc 中匹配的test行<br>grep ‘test’|’hello’ files 匹配test或者hello<br>grep ‘\\&lt;man’ files    匹配manic 和man 不匹配batman<br>grep ‘\\&lt;man>‘        只匹配man 不匹配batman和manic<br>grep ‘^man’ files    匹配的字符行首<br>grep ‘$man’ files    匹配的字符串仔行尾</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>用法</p>\n<pre><code class=\"sh\">find [-path ..] [expression]\n</code></pre>\n<p>选项</p>\n<pre><code class=\"sh\">-name     按照文件名\n-iname     按照文件名 忽略大小写\n-perm     按照文件权限\n-user     按照文件拥有者\n-group    按照文件所属的组\n-mtime -n +n 按照文件的更改时间来查找文件， -n：n天以内，+n：n天以前\n-type     查找某一类型：文件类型有：普通文件(f)，目录(d)，字符设备文件(c)，块设备文件(b)，符号链接文件(l)，套接字文件(s)，管道文件(p)\n-size n   查找文件长度为n块（一块等于512字节）的文件，带有c时表示文件长度以字节计。 \n-mount    不跨越文件系统\n-follow   遇到符号链接文件，就跟踪至链接所指向的文件\n-path     匹配文件路径或者文件\n-exec     执行后续命令操作\n-a        and 与操作\n-o        or  或操作\n-not      not 非操作\n</code></pre>\n<p>经典使用方法</p>\n<pre><code class=\"sh\">#查找/run中所有的socket文件\nfind /run -type s\n#搜索/dev中所有包含tty的文件\nfind /dev -name &quot;*tty*&quot;\n#搜索/dev中大小大于10字节，名称包含bus的文件\nfind /dev -size +10c -name &quot;*bus*&quot;\n#或操作，搜索debug开头的文件或者.rst的文件\nfind -name &#39;debug*&#39; -o -name &#39;*.rst&#39;\n#与操作，搜索debug开头的文件同时是.rst的文件\nfind -name &#39;debug*&#39; -a -name &#39;*.rst&#39;\n#找出文件大小大于10000块的文件，并复制到当前目录\nfind -size +100000 -exec cp {} . \\;\n</code></pre>\n<h3 id=\"lsusb\"><a href=\"#lsusb\" class=\"headerlink\" title=\"lsusb\"></a>lsusb</h3><p>显示系统中以及连接到系统的USB总线信息的工具。</p>\n<pre><code class=\"sh\">$ lsusb\n\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 007 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 008 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\nBus 002 Device 003: ID 17ef:4811 Lenovo Integrated Webcam [R5U877]\nBus 008 Device 002: ID 0a5c:217f Broadcom Corp. Bluetooth Controller\n</code></pre>\n<blockquote>\n<p>Bus 008 : 指明设备连接到哪（哪条总线）<br>Device 002 : 表明这是连接到总线上的第二台设备<br>ID : 设备的ID<br>Broadcom Corp. Bluetooth Controller :生产商名字和设备名</p>\n</blockquote>\n<p>列出USB详细信息</p>\n<pre><code class=\"sh\">$ lsusb -v\n</code></pre>\n<p>列出有多少USB设备</p>\n<pre><code class=\"sh\">$ find /dev/bus\n</code></pre>\n<p>打印特定设备的详细信息</p>\n<pre><code class=\"sh\">$ lsusb -D /dev/bus/usb/008/002\n</code></pre>\n<h3 id=\"lsof\"><a href=\"#lsof\" class=\"headerlink\" title=\"lsof\"></a>lsof</h3><p>列出当前系统打开文件的工具</p>\n<pre><code class=\"sh\">$ sudo lsof\nCOMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAME\ninit       1         root  cwd      DIR       3,3       1024       2         /\ninit       1         root  rtd      DIR       3,3       1024       2         /\ninit       1         root  txt      REG       3,3       38432      1763452  /sbin/init\ninit       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.so\ninit       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.so\ninit       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1\ninit       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1\ninit       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.so\ninit       1         root  10u      FIFO      0,15                  1309     /dev/initctl\n</code></pre>\n<table style=\"text-align:center\"><br>   <tr><br>      <td>COMMAND</td><br>      <td>进程的名称</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>PID</td><br>      <td>进程标识符</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>USER</td><br>      <td>进程所有者</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>FD</td><br>      <td>文件描述符</td><br>      <td>应用程序通过文件描述符识别该文件。如cwd、txt、mem等</td><br>   </tr><br>   <tr><br>      <td>TYPE</td><br>      <td>文件类型</td><br>      <td>REG(文件) DIR(目录) CHR(字符) BLK(块设备) FIFO(管道) UNIX(UNIX 域套接字) IPv4(IP套接字)</td><br>   </tr><br>   <tr><br>      <td>DEVICE</td><br>      <td>指定磁盘的名称</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>SIZE</td><br>      <td>文件大小</td><br>      <td></td><br>   </tr><br>   <tr><br>      <td>NODE</td><br>      <td>文件inode</td><br>      <td>每个文件都有一个唯一的inode</td><br>   </tr><br>   <tr><br>      <td>NAME</td><br>      <td>文件名称</td><br>      <td></td><br>   </tr><br></table>\n\n<p>参数列表</p>\n<pre><code class=\"sh\">lsof  filename      显示打开指定文件的所有进程\nlsof -a             表示两个参数都必须满足时才显示结果\nlsof -c string      显示COMMAND列中包含指定字符的进程所有打开的文件\nlsof -u username    显示所属user进程打开的文件\nlsof -g gid         显示归属gid的进程情况\nlsof +d /DIR/       显示目录下被进程打开的文件\nlsof +D /DIR/       同上，但是会搜索目录下的所有目录，时间相对较长\nlsof -d FD          显示指定文件描述符的进程\nlsof -n             不将IP转换为hostname，缺省是不加上-n参数\nlsof -i             用以显示符合条件的进程情况\nlsof -i[46] [protocol][@hostname|hostaddr][:service|port]\n                    46 --&gt; IPv4 or IPv6\n                    protocol --&gt; TCP or UDP\n                    hostname --&gt; Internet host name\n                    hostaddr --&gt; IPv4地址\n                    service --&gt; /etc/service中的 service name (可以不只一个)\n                    port --&gt; 端口号 (可以不只一个)\n</code></pre>\n<p>查找应用程序打开的文件的名称和数目</p>\n<pre><code class=\"sh\">#显示打开指定文件的所有进程\n$ lsof  filename\n#例如:打开所有使用/dev/urandom的进程\n$ lsof /dev/urandom\n#查看22端口现在运行的情况 \n$ lsof -i :22\n#查看所属xiaxiaowen用户进程所打开的文件类型为txt的文件\n$ lsof -a -u xiaxiaowen -d txt\n#查找谁在使用文件系统\n$ lsof /media/xiaxiaowen/机械硬盘\nCOMMAND  PID       USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nzsh     8465 xiaxiaowen  cwd    DIR   8,17     8192    5 /media/xiaxiaowen/机械硬盘\n</code></pre>\n<h2 id=\"linux软件开发知识点\"><a href=\"#linux软件开发知识点\" class=\"headerlink\" title=\"linux软件开发知识点\"></a>linux软件开发知识点</h2><ul>\n<li><a href=\"#linux进程间通讯方式\">linux进程间通讯方式</a></li>\n<li><a href=\"#内存申请函数\">内存申请函数</a></li>\n<li><a href=\"#linux内存分配说明\">linux内存分配说明</a></li>\n<li><a href=\"#gcc编译过程\">gcc编译过程</a></li>\n<li><a href=\"#文件系统\">文件系统</a></li>\n<li><a href=\"#硬链接和软连接\">硬链接和软连接</a></li>\n<li><a href=\"#linux内核子系统\">linux内核子系统</a></li>\n<li><a href=\"#进程几种状态\">进程几种状态</a></li>\n<li><a href=\"#文件系统组成\">文件系统组成</a></li>\n<li><a href=\"#linux文件类型\">linux文件类型</a></li>\n<li><a href=\"#linux常用的系统调用函数\">linux常用的系统调用函数</a></li>\n<li><a href=\"#fork函数\">fork函数</a></li>\n<li><a href=\"#僵尸进程\">僵尸进程</a></li>\n<li><a href=\"#常见文件说明\">常见文件说明</a></li>\n<li><a href=\"#proc目录说明\">proc目录说明</a></li>\n<li><a href=\"#fopen参数说明\">fopen参数说明</a></li>\n</ul>\n<h3 id=\"linux进程间通讯方式\"><a href=\"#linux进程间通讯方式\" class=\"headerlink\" title=\"linux进程间通讯方式\"></a>linux进程间通讯方式</h3><ol>\n<li>管道（Pipe）及有名管道（named pipe）</li>\n<li>信号（Signal）</li>\n<li>报文（Message）队列（消息队列）：</li>\n<li>共享内存</li>\n<li>信号量（semaphore）</li>\n<li>套接口（Socket）</li>\n</ol>\n<h3 id=\"内存申请函数\"><a href=\"#内存申请函数\" class=\"headerlink\" title=\"内存申请函数\"></a>内存申请函数</h3><ol>\n<li>calloc</li>\n<li>malloc</li>\n<li>realloc<h3 id=\"linux内存分配说明\"><a href=\"#linux内存分配说明\" class=\"headerlink\" title=\"linux内存分配说明\"></a>linux内存分配说明</h3>|内存|存放数据|说明<br>|:—:|—|—|<br>|静态存储区|静态数据、全局数据、常量|在程序编译的时候就已经分配好|<br>|栈区     |局部变量、函数参数|栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限|<br>|堆区     |malloc申请的内存|动态内存分配,需要手动释放|<br>|代码区    |代码|存放函数体的二进制代码|<br>|文字常量区|常量字符串|程序结束后由系统释放|<h3 id=\"gcc编译过程\"><a href=\"#gcc编译过程\" class=\"headerlink\" title=\"gcc编译过程\"></a>gcc编译过程</h3></li>\n</ol>\n<table style=\"text-align:center\"><br>   <tr><br>      <td><strong>过程</strong></td><br>      <td><strong>生成文件</strong></td><br>   </tr><br>   <tr><br>      <td>预编译</td><br>      <td><em>.i</em></td><br>   </tr><br>   <tr><br>      <td>编译</td><br>      <td>.s</td><br>   </tr><br>   <tr><br>      <td>汇编</td><br>      <td>*.o</td><br>   </tr><br>   <tr><br>      <td>链接</td><br>      <td>可执行文件</td><br>   </tr><br></table>\n\n<h3 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h3><table style=\"text-align:center\"><br>   <tr><br>      <td>fat</td><br>      <td>fat32</td><br>      <td>ntfs</td><br>      <td>ext2</td><br>      <td>ext3</td><br>      <td>ext4</td><br>      <td>nfs</td><br>   </tr><br></table>\n\n<h3 id=\"硬链接和软连接\"><a href=\"#硬链接和软连接\" class=\"headerlink\" title=\"硬链接和软连接\"></a>硬链接和软连接</h3><h4 id=\"硬链接\"><a href=\"#硬链接\" class=\"headerlink\" title=\"硬链接\"></a>硬链接</h4><ul>\n<li>硬链接直接指向文件的i节点</li>\n<li>硬链接和原文件的i节点是一样的</li>\n<li>硬链接文件显示的大小是跟原文件是一样的</li>\n<li>硬链接不能链接目录文件。<pre><code class=\"sh\">ln file2 /home/xiaxiaowen/file2hard\n</code></pre>\n<h4 id=\"软链接-符号链接\"><a href=\"#软链接-符号链接\" class=\"headerlink\" title=\"软链接(符号链接)\"></a>软链接(符号链接)</h4></li>\n<li>软链接则是建立了一个新文件</li>\n<li>这个文件指向链接的文件，i节点不一样</li>\n<li>可以链接目录<pre><code class=\"sh\">ln -s file2 /home/xiaxiaowen/file2soft\n</code></pre>\n</li>\n</ul>\n<h3 id=\"linux内核子系统\"><a href=\"#linux内核子系统\" class=\"headerlink\" title=\"linux内核子系统\"></a>linux内核子系统</h3><ol>\n<li>进程管理</li>\n<li>内存管理</li>\n<li>I/O管理</li>\n<li>文件系统管理</li>\n</ol>\n<h3 id=\"进程几种状态\"><a href=\"#进程几种状态\" class=\"headerlink\" title=\"进程几种状态\"></a>进程几种状态</h3><ol>\n<li>运行态</li>\n<li>就绪态</li>\n<li>阻塞态</li>\n</ol>\n<h3 id=\"文件系统组成\"><a href=\"#文件系统组成\" class=\"headerlink\" title=\"文件系统组成\"></a>文件系统组成</h3><ol>\n<li><strong>超级块</strong>：存放文件系统本身的信息，比如记录了每个区域的大小，或未被使用的磁盘块的信息。（不同版本稍有差别）</li>\n<li><strong>i-节点表</strong>：每个文件都有其属性，大小，最近修改时间等等，这些被存储在ino_t 的结构体中，所有的i-节点都有一样的大小，i-节点表就是这样一些节点的列表。（表中的每个i-节点都通过位置来标志，例如标志为2的i-节点位于文件系统i-节点表中的第3个位置 ）</li>\n<li><strong>数据块</strong>：存放文件内容，因为块的大小一定，所以有时一个文件会分布在多个磁盘上。<h3 id=\"i-节点\"><a href=\"#i-节点\" class=\"headerlink\" title=\"i 节点\"></a>i 节点</h3>i 节点是一个64字节长的表,表中包含了文件的相关信息,其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息.</li>\n</ol>\n<h3 id=\"linux文件类型\"><a href=\"#linux文件类型\" class=\"headerlink\" title=\"linux文件类型\"></a>linux文件类型</h3><table style=\"text-align:center\"><br>   <tr><br>      <td><strong>文件类型</strong></td><br>      <td>普通文件</td><br>      <td>目录</td><br>      <td>字符设备文件</td><br>      <td>块设备文件</td><br>      <td>符号链接文件</td><br>      <td>套接字文件</td><br>      <td>管道文件</td><br>   </tr><br>   <tr><br>      <td><strong>属性</strong></td><br>      <td>-</td><br>      <td>d</td><br>      <td>c</td><br>      <td>b</td><br>      <td>l</td><br>      <td>s</td><br>      <td>p</td><br>   </tr><br></table>\n\n<h3 id=\"linux常用的系统调用函数\"><a href=\"#linux常用的系统调用函数\" class=\"headerlink\" title=\"linux常用的系统调用函数\"></a>linux常用的系统调用函数</h3><ul>\n<li><a href=\"#进程控制函数\">进程控制函数</a></li>\n<li><a href=\"#文件操作函数\">文件操作函数</a></li>\n<li><a href=\"#文件系统操作函数\">文件系统操作函数</a></li>\n<li><a href=\"#系统控制函数\">系统控制函数</a></li>\n<li><a href=\"#内存管理函数\">内存管理函数</a></li>\n<li><a href=\"#网络管理函数\">网络管理函数</a></li>\n<li><a href=\"#socket函数\">socket函数</a></li>\n<li><a href=\"#用户管理函数\">用户管理函数</a></li>\n<li><a href=\"#进程间通信函数\">进程间通信函数</a></li>\n<li><a href=\"#信号相关函数\">信号相关函数</a></li>\n<li><a href=\"#消息相关函数\">消息相关函数</a></li>\n<li><a href=\"#管道相关函数\">管道相关函数</a></li>\n<li><a href=\"#信号量相关函数\">信号量相关函数</a></li>\n<li><a href=\"#共享内存相关函数\">共享内存相关函数</a></li>\n</ul>\n<h4 id=\"进程控制函数\"><a href=\"#进程控制函数\" class=\"headerlink\" title=\"进程控制函数\"></a>进程控制函数</h4><table><br>   <tr style=\"color:red\"><br>      <td>fork</td><br>      <td>创建一个新进程</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>clone</td><br>      <td>按指定条件创建子进程</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>execve</td><br>      <td>运行可执行文件</td><br>   </tr><br>   <tr style=\"color:red\"><br>      <td>exit</td><br>      <td>中止进程</td><br>   </tr><br>   <tr><br>      <td>_exit</td><br>      <td>立即中止当前进程</td><br>   </tr><br>   <tr><br>      <td>getdtablesize</td><br>      <td>进程所能打开的最大文件数</td><br>   </tr><br>   <tr><br>      <td>getpgid</td><br>      <td>获取指定进程组标识号</td><br>   </tr><br>   <tr><br>      <td>setpgid</td><br>      <td>设置指定进程组标志号</td><br>   </tr><br>   <tr><br>      <td>getpgrp</td><br>      <td>获取当前进程组标识号</td><br>   </tr><br>   <tr><br>      <td>setpgrp</td><br>      <td>设置当前进程组标志号</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>getpid</td><br>          <td>获取进程标识号</td><br>    </tr><br>      <tr><br>          <td>getppid</td><br>          <td>获取父进程标识号</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>getpriority</td><br>          <td>获取调度优先级</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>setpriority</td><br>          <td>设置调度优先级</td><br>    </tr><br>      <tr><br>          <td>modify_ldt</td><br>          <td>读写进程的本地描述表</td><br>    </tr><br>      <tr><br>          <td>nanosleep</td><br>          <td>使进程睡眠指定的时间</td><br>    </tr><br>      <tr><br>          <td>nice</td><br>          <td>改变分时进程的优先级</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>pause</td><br>          <td>挂起进程，等待信号</td><br>    </tr><br>      <tr><br>          <td>personality</td><br>          <td>设置进程运行域</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>prctl</td><br>          <td>对进程进行特定操作</td><br>    </tr><br>      <tr><br>          <td>ptrace</td><br>          <td>进程跟踪</td><br>    </tr><br>      <tr><br>          <td>sched_get_priority_max</td><br>          <td>取得静态优先级的上限</td><br>    </tr><br>      <tr><br>          <td>sched_get_priority_min</td><br>          <td>取得静态优先级的下限</td><br>    </tr><br>      <tr><br>          <td>sched_getparam</td><br>          <td>取得进程的调度参数</td><br>    </tr><br>      <tr><br>          <td>sched_getscheduler</td><br>          <td>取得指定进程的调度策略</td><br>    </tr><br>      <tr><br>          <td>sched_rr_get_interval</td><br>          <td>取得按RR算法调度的实时进程的时间片长度</td><br>    </tr><br>      <tr><br>          <td>sched_setparam</td><br>          <td>设置进程的调度参数</td><br>    </tr><br>      <tr><br>          <td>sched_setscheduler</td><br>          <td>设置指定进程的调度策略和参数</td><br>    </tr><br>      <tr><br>          <td>sched_yield</td><br>          <td>进程主动让出处理器,并将自己等候调度队列队尾</td><br>    </tr><br>      <tr><br>          <td>vfork</td><br>          <td>创建一个子进程，以供执行新程序，常与execve等同时使用</td><br>    </tr><br>      <tr style=\"color:red\"><br>          <td>wait</td><br>          <td>等待子进程终止</td><br>    </tr><br>      <tr><br>          <td>wait3</td><br>          <td>参见wait</td><br>    </tr><br>      <tr><br>          <td>waitpid</td><br>          <td>等待指定子进程终止</td><br>    </tr><br>      <tr><br>          <td>wait4</td><br>          <td>参见waitpid</td><br>    </tr><br>      <tr><br>          <td>capget</td><br>          <td>获取进程权限</td><br>    </tr><br>      <tr><br>          <td>capset</td><br>          <td>设置进程权限</td><br>    </tr><br>      <tr><br>          <td>getsid</td><br>          <td>获取会晤标识号</td><br>    </tr><br>      <tr><br>          <td>setsid</td><br>          <td>设置会晤标识号</td><br>      </tr><br></table>\n\n<h4 id=\"文件操作函数\"><a href=\"#文件操作函数\" class=\"headerlink\" title=\"文件操作函数\"></a>文件操作函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>fcntl</td><br>      <td>文件控制</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>open</td><br>      <td>打开文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>creat</td><br>      <td>创建新文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>close</td><br>      <td>关闭文件描述字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>read</td><br>      <td>读文件</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>write</td><br>      <td>写文件</td><br>  </tr><br>  <tr><br>      <td>readv</td><br>      <td>从文件读入数据到缓冲数组中</td><br>  </tr><br>  <tr><br>      <td>writev</td><br>      <td>将缓冲数组里的数据写入文件</td><br>  </tr><br>  <tr><br>      <td>pread</td><br>      <td>对文件随机读</td><br>  </tr><br>  <tr><br>      <td>pwrite</td><br>      <td>对文件随机写</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>lseek</td><br>      <td>移动文件指针</td><br>  </tr><br>  <tr><br>      <td>_llseek</td><br>      <td>在64位地址空间里移动文件指针</td><br>  </tr><br>  <tr><br>      <td>dup</td><br>      <td>复制已打开的文件描述字</td><br>  </tr><br>  <tr><br>      <td>dup2</td><br>      <td>按指定条件复制文件描述字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>flock</td><br>      <td>文件加/解锁</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>poll</td><br>      <td>I/O多路转换</td><br>  </tr><br>  <tr><br>      <td>truncate</td><br>      <td>截断文件</td><br>  </tr><br>  <tr><br>      <td>ftruncate</td><br>      <td>参见truncate</td><br>  </tr><br>  <tr><br>      <td>umask</td><br>      <td>设置文件权限掩码</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>fsync</td><br>      <td>把文件在内存中的部分写回磁盘</td><br>  </tr><br></table>\n\n<h4 id=\"文件系统操作函数\"><a href=\"#文件系统操作函数\" class=\"headerlink\" title=\"文件系统操作函数\"></a>文件系统操作函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>access</td><br>      <td>确定文件的可存取性</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chdir</td><br>      <td>改变当前工作目录</td><br>  </tr><br>  <tr><br>      <td>fchdir</td><br>      <td>参见chdir</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chmod</td><br>      <td>改变文件方式</td><br>  </tr><br>  <tr><br>      <td>fchmod</td><br>      <td>参见chmod</td><br>  </tr><br>  <tr><br>      <td>chown</td><br>      <td>改变文件的属主或用户组</td><br>  </tr><br>  <tr><br>      <td>fchown</td><br>      <td>参见chown</td><br>  </tr><br>  <tr><br>      <td>lchown</td><br>      <td>参见chown</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>chroot</td><br>      <td>改变根目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>stat</td><br>      <td>取文件状态信息</td><br>  </tr><br>  <tr><br>      <td>lstat</td><br>      <td>参见stat</td><br>  </tr><br>  <tr><br>      <td>fstat</td><br>      <td>参见stat</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>statfs</td><br>      <td>取文件系统信息</td><br>  </tr><br>  <tr><br>      <td>fstatfs</td><br>      <td>参见statfs</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>readdir</td><br>      <td>读取目录项</td><br>  </tr><br>  <tr><br>      <td>getdents</td><br>      <td>读取目录项</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>mkdir</td><br>      <td>创建目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>mknod</td><br>      <td>创建索引节点</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>rmdir</td><br>      <td>删除目录</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>rename</td><br>      <td>文件改名</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>link</td><br>      <td>创建链接</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>symlink</td><br>      <td>创建符号链接</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>unlink</td><br>      <td>删除链接</td><br>  </tr><br>  <tr><br>      <td>readlink</td><br>      <td>读符号链接的值</td><br>  </tr><br>  <tr><br>      <td>mount</td><br>      <td>安装文件系统</td><br>  </tr><br>  <tr><br>      <td>umount</td><br>      <td>卸下文件系统</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>ustat</td><br>      <td>取文件系统信息</td><br>  </tr><br>  <tr><br>      <td>utime</td><br>      <td>改变文件的访问修改时间</td><br>  </tr><br>  <tr><br>      <td>utimes</td><br>      <td>参见utime</td><br>  </tr><br>  <tr><br>      <td>quotactl</td><br>      <td>控制磁盘配额</td><br>  </tr><br></table>\n\n<h4 id=\"系统控制函数\"><a href=\"#系统控制函数\" class=\"headerlink\" title=\"系统控制函数\"></a>系统控制函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>ioctl</td><br>      <td>I/O总控制函数</td><br>  </tr><br>  <tr><br>      <td>_sysctl</td><br>      <td>读/写系统参数</td><br>  </tr><br>  <tr><br>      <td>acct</td><br>      <td>启用或禁止进程记账</td><br>  </tr><br>  <tr><br>      <td>getrlimit</td><br>      <td>获取系统资源上限</td><br>  </tr><br>  <tr><br>      <td>setrlimit</td><br>      <td>设置系统资源上限</td><br>  </tr><br>  <tr><br>      <td>getrusage</td><br>      <td>获取系统资源使用情况</td><br>  </tr><br>  <tr><br>      <td>uselib</td><br>      <td>选择要使用的二进制函数库</td><br>  </tr><br>  <tr><br>      <td>ioperm</td><br>      <td>设置端口I/O权限</td><br>  </tr><br>  <tr><br>      <td>iopl</td><br>      <td>改变进程I/O权限级别</td><br>  </tr><br>  <tr><br>      <td>outb</td><br>      <td>低级端口操作</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>reboot</td><br>      <td>重新启动</td><br>  </tr><br>  <tr><br>      <td>swapon</td><br>      <td>打开交换文件和设备</td><br>  </tr><br>  <tr><br>      <td>swapoff</td><br>      <td>关闭交换文件和设备</td><br>  </tr><br>  <tr><br>      <td>bdflush</td><br>      <td>控制bdflush守护进程</td><br>  </tr><br>  <tr><br>      <td>sysfs</td><br>      <td>取核心支持的文件系统类型</td><br>  </tr><br>  <tr><br>      <td>sysinfo</td><br>      <td>取得系统信息</td><br>  </tr><br>  <tr><br>      <td>adjtimex</td><br>      <td>调整系统时钟</td><br>  </tr><br>  <tr><br>      <td>alarm</td><br>      <td>设置进程的闹钟</td><br>  </tr><br>  <tr><br>      <td>getitimer</td><br>      <td>获取计时器值</td><br>  </tr><br>  <tr><br>      <td>setitimer</td><br>      <td>设置计时器值</td><br>  </tr><br>  <tr><br>      <td>gettimeofday</td><br>      <td>取时间和时区</td><br>  </tr><br>  <tr><br>      <td>settimeofday</td><br>      <td>设置时间和时区</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>stime</td><br>      <td>设置系统日期和时间</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>time</td><br>      <td>取得系统时间</td><br>  </tr><br>  <tr><br>      <td>times</td><br>      <td>取进程运行时间</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>uname</td><br>      <td>获取当前UNIX系统的名称、版本和主机等信息</td><br>  </tr><br>  <tr><br>      <td>vhangup</td><br>      <td>挂起当前终端</td><br>  </tr><br>  <tr><br>      <td>nfsservctl</td><br>      <td>对NFS守护进程进行控制</td><br>  </tr><br>  <tr><br>      <td>vm86</td><br>      <td>进入模拟8086模式</td><br>  </tr><br>  <tr><br>      <td>create_module</td><br>      <td>创建可装载的模块项</td><br>  </tr><br>  <tr><br>      <td>delete_module</td><br>      <td>删除可装载的模块项</td><br>  </tr><br>  <tr><br>      <td>init_module</td><br>      <td>初始化模块</td><br>  </tr><br>  <tr><br>      <td>query_module</td><br>      <td>查询模块信息</td><br>  </tr><br>  <tr><br>      <td>*get_kernel_syms</td><br>      <td>取得核心符号,已被query_module代替</td><br>  </tr><br></table>\n\n<h4 id=\"内存管理函数\"><a href=\"#内存管理函数\" class=\"headerlink\" title=\"内存管理函数\"></a>内存管理函数</h4><table><br>  <tr><br>      <td>brk</td><br>      <td>改变数据段空间的分配</td><br>  </tr><br>  <tr><br>      <td>sbrk</td><br>      <td>参见brk</td><br>  </tr><br>  <tr><br>      <td>mlock</td><br>      <td>内存页面加锁</td><br>  </tr><br>  <tr><br>      <td>munlock</td><br>      <td>内存页面解锁</td><br>  </tr><br>  <tr><br>      <td>mlockall</td><br>      <td>调用进程所有内存页面加锁</td><br>  </tr><br>    <tr><br>      <td>munlockall</td><br>      <td>调用进程所有内存页面解锁</td><br>  </tr><br>  <tr><br>      <td>mmap</td><br>      <td>映射虚拟内存页</td><br>  </tr><br>  <tr><br>      <td>munmap</td><br>      <td>去除内存页映射</td><br>  </tr><br>  <tr><br>      <td>mremap</td><br>      <td>重新映射虚拟内存地址</td><br>  </tr><br>  <tr><br>      <td>msync</td><br>      <td>将映射内存中的数据写回磁盘</td><br>  </tr><br>  <tr><br>      <td>mprotect</td><br>      <td>设置内存映像保护</td><br>  </tr><br>  <tr><br>      <td>getpagesize</td><br>      <td>获取页面大小</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sync</td><br>      <td>将内存缓冲区数据写回硬盘</td><br>  </tr><br>  <tr><br>      <td>cacheflush</td><br>      <td>dddd将指定缓冲区中的内容写回磁盘dd</td><br>  </tr><br></table>\n\n<h4 id=\"网络管理函数\"><a href=\"#网络管理函数\" class=\"headerlink\" title=\"网络管理函数\"></a>网络管理函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>getdomainname</td><br>      <td>取域名</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>setdomainname</td><br>      <td>设置域名</td><br>  </tr><br>  <tr><br>      <td>gethostid</td><br>      <td>获取主机标识号</td><br>  </tr><br>  <tr><br>      <td>sethostid</td><br>      <td>设置主机标识号</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>gethostname</td><br>      <td>获取本主机名称</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sethostname</td><br>      <td>设置主机名称</td><br>  </tr><br></table>\n\n<h4 id=\"socket函数\"><a href=\"#socket函数\" class=\"headerlink\" title=\"socket函数\"></a>socket函数</h4><table><br>  <tr><br>      <td>socketcall</td><br>      <td>socket系统调用</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>socket</td><br>      <td>建立socket</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>bind</td><br>      <td>绑定socket到端口</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>connect</td><br>      <td>连接远程主机</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>accept</td><br>      <td>响应socket连接请求</td><br>  </tr><br>    <tr><br>      <td>send</td><br>      <td>通过socket发送信息</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>sendto</td><br>      <td>发送UDP信息</td><br>  </tr><br>  <tr><br>      <td>sendmsg</td><br>      <td>参见send</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>recv</td><br>      <td>通过socket接收信息</td><br>  </tr><br>    <tr style=\"color:red\"><br>      <td>recvfrom</td><br>      <td>接收UDP信息</td><br>  </tr><br>  <tr><br>      <td>recvmsg</td><br>      <td>参见recv</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>listen</td><br>      <td>监听socket端口</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>select</td><br>      <td>对多路同步I/O进行轮询</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>close</td><br>      <td>关闭socket上的连接</td><br>  </tr><br>  <tr><br>      <td>getsockname</td><br>      <td>取得本地socket名字</td><br>  </tr><br>  <tr><br>      <td>getpeername</td><br>      <td>获取通信对方的socket名字</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>getsockopt</td><br>      <td>取端口设置</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>setsockopt</td><br>      <td>设置端口参数</td><br>  </tr><br>  <tr><br>      <td>sendfile</td><br>      <td>在文件或端口间传输数据</td><br>  </tr><br>  <tr><br>      <td>socketpair</td><br>      <td>创建一对已联接的无名socket</td><br>  </tr><br></table>\n\n<h4 id=\"用户管理函数\"><a href=\"#用户管理函数\" class=\"headerlink\" title=\"用户管理函数\"></a>用户管理函数</h4><table><br>  <tr><br>      <td>getuid</td><br>      <td>获取用户标识号</td><br>  </tr><br>  <tr><br>      <td>setuid</td><br>      <td>设置用户标志号</td><br>  </tr><br>  <tr><br>      <td>getgid</td><br>      <td>获取组标识号</td><br>  </tr><br>  <tr><br>      <td>setgid</td><br>      <td>设置组标志号</td><br>  </tr><br>  <tr><br>      <td>getegid</td><br>      <td>获取有效组标识号</td><br>  </tr><br>  <tr><br>      <td>setegid</td><br>      <td>设置有效组标识号</td><br>  </tr><br>  <tr><br>      <td>geteuid</td><br>      <td>获取有效用户标识号</td><br>  </tr><br>  <tr><br>      <td>seteuid</td><br>      <td>设置有效用户标识号</td><br>  </tr><br>  <tr><br>      <td>setregid</td><br>      <td>分别设置真实和有效的的组标识号</td><br>  </tr><br>  <tr><br>      <td>setreuid</td><br>      <td>分别设置真实和有效的用户标识号</td><br>  </tr><br>  <tr><br>      <td>getresgid</td><br>      <td>分别获取真实的,有效的和保存过的组标识号</td><br>  </tr><br>  <tr><br>      <td>setresgid</td><br>      <td>分别设置真实的,有效的和保存过的组标识号</td><br>  </tr><br>  <tr><br>      <td>getresuid</td><br>      <td>分别获取真实的,有效的和保存过的用户标识号</td><br>  </tr><br>  <tr><br>      <td>setresuid</td><br>      <td>分别设置真实的,有效的和保存过的用户标识号</td><br>  </tr><br>  <tr><br>      <td>setfsgid</td><br>      <td>设置文件系统检查时使用的组标识号</td><br>  </tr><br>  <tr><br>      <td>setfsuid</td><br>      <td>设置文件系统检查时使用的用户标识号</td><br>  </tr><br>  <tr><br>      <td>getgroups</td><br>      <td>获取后补组标志清单</td><br>  </tr><br>  <tr><br>      <td>setgroups</td><br>      <td>设置后补组标志清单</td><br>  </tr><br></table>\n\n<h4 id=\"进程间通信函数\"><a href=\"#进程间通信函数\" class=\"headerlink\" title=\"进程间通信函数\"></a>进程间通信函数</h4><table><br>  <tr style=\"color:red\"><br>      <td>ipc</td><br>      <td>进程间通信总控制调用</td><br>  </tr><br></table>\n\n<h4 id=\"信号相关函数\"><a href=\"#信号相关函数\" class=\"headerlink\" title=\"信号相关函数\"></a>信号相关函数</h4><table><br>  <tr><br>      <td>sigaction</td><br>      <td>设置对指定信号的处理方法</td><br>  </tr><br>  <tr><br>      <td>sigprocmask</td><br>      <td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td><br>  </tr><br>  <tr><br>      <td>sigpending</td><br>      <td>为指定的被阻塞信号设置队列</td><br>  </tr><br>  <tr><br>      <td>sigsuspend</td><br>      <td>挂起进程等待特定信号</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>signal</td><br>      <td>参见signal</td><br>  </tr><br>  <tr style=\"color:red\"><br>      <td>kill</td><br>      <td>向进程或进程组发信号</td><br>  </tr><br>  <tr><br>      <td><em>sigblock</em></td><br>      <td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>siggetmask</td><br>      <td>取得现有阻塞信号掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td><em>sigsetmask</em></td><br>      <td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>sigmask</td><br>      <td>将给定的信号转化为掩码,已被sigprocmask代替</td><br>  </tr><br>  <tr><br>      <td>*sigpause</td><br>      <td>作用同sigsuspend,已被sigsuspend代替</td><br>  </tr><br>  <tr><br>      <td>sigvec</td><br>      <td>为兼容BSD而设的信号处理函数,作用类似sigaction</td><br>  </tr><br>  <tr><br>      <td>ssetmask</td><br>      <td>ANSI C的信号处理函数,作用类似sigaction</td><br>  </tr><br></table>\n\n<h4 id=\"消息相关函数\"><a href=\"#消息相关函数\" class=\"headerlink\" title=\"消息相关函数\"></a>消息相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>msgctl</td><br>      <td>消息控制操作</td><br>  </tr><br>  <tr><br>      <td>msgget</td><br>      <td>获取消息队列</td><br>  </tr><br>  <tr><br>      <td>msgsnd</td><br>      <td>发消息</td><br>  </tr><br>  <tr><br>      <td>msgrcv</td><br>      <td>取消息</td><br>  </tr><br></table>\n\n<h4 id=\"管道相关函数\"><a href=\"#管道相关函数\" class=\"headerlink\" title=\"管道相关函数\"></a>管道相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>pipe</td><br>      <td>创建管道</td><br>  </tr><br></table>\n\n<h4 id=\"信号量相关函数\"><a href=\"#信号量相关函数\" class=\"headerlink\" title=\"信号量相关函数\"></a>信号量相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>semctl</td><br>      <td>信号量控制</td><br>  </tr><br>  <tr><br>      <td>semget</td><br>      <td>获取一组信号量</td><br>  </tr><br>  <tr><br>      <td>semop</td><br>      <td>信号量操作</td><br>  </tr><br></table>\n\n<h4 id=\"共享内存相关函数\"><a href=\"#共享内存相关函数\" class=\"headerlink\" title=\"共享内存相关函数\"></a>共享内存相关函数</h4><table style=\"color:red\"><br>  <tr><br>      <td>shmctl</td><br>      <td>控制共享内存</td><br>  </tr><br>  <tr><br>      <td>shmget</td><br>      <td>获取共享内存</td><br>  </tr><br>  <tr><br>      <td>shmat</td><br>      <td>连接共享内存</td><br>  </tr><br>  <tr><br>      <td>shmdt</td><br>      <td>拆卸共享内存</td><br>  </tr><br></table>\n\n<h3 id=\"fork函数\"><a href=\"#fork函数\" class=\"headerlink\" title=\"fork函数\"></a>fork函数</h3><p>fork是用来创建子进程的，这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，我们可以通过返回值来判断其返回点：</p>\n<pre><code class=\"c\">pid_t child = fork();\nif( child &lt; 0  ) {     //fork error.\n    perror(&quot;fork process fail.\\n&quot;);\n} else if( child ==0  ) {   // in child process\n    printf(&quot; fork succ, this run in child process\\n &quot;);\n} else {                        // in parent process\n    printf(&quot; this run in parent process\\n &quot;);\n}\n</code></pre>\n<h3 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h3><ul>\n<li><a href=\"#僵尸进程产生原因\">僵尸进程产生原因</a></li>\n<li><a href=\"#僵尸进程解决办法\">僵尸进程解决办法</a></li>\n<li><a href=\"#ps指令查看僵尸进程\">ps指令查看僵尸进程</a></li>\n</ul>\n<h4 id=\"僵尸进程产生原因\"><a href=\"#僵尸进程产生原因\" class=\"headerlink\" title=\"僵尸进程产生原因\"></a>僵尸进程产生原因</h4><p>  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。</p>\n<h4 id=\"僵尸进程解决办法\"><a href=\"#僵尸进程解决办法\" class=\"headerlink\" title=\"僵尸进程解决办法\"></a>僵尸进程解决办法</h4><ol>\n<li>通过信号机制<br>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</li>\n<li>fork两次<br>父进程创建子进程A，子进程A再创建子进程B，然后子进程A退出，z这样子进程B就交给init进程处理了。init进程可以处理僵尸进程.</li>\n</ol>\n<h4 id=\"ps指令查看僵尸进程\"><a href=\"#ps指令查看僵尸进程\" class=\"headerlink\" title=\"ps指令查看僵尸进程\"></a>ps指令查看僵尸进程</h4><pre><code class=\"sh\">ps -A -ostat,pid,cmd |grep -iE &#39;^z&#39;\n</code></pre>\n<blockquote>\n<p>-A 显示所有任务<br>  -o 按照指定格式输出<br>  grep -iE 显示z开头的行，不区分大小写</p>\n</blockquote>\n<h3 id=\"常见文件说明\"><a href=\"#常见文件说明\" class=\"headerlink\" title=\"常见文件说明\"></a>常见文件说明</h3><p>/var/log/boot.log 系统引导日志<br>/var/log/dmesg    系统核心启动日志<br>/var/log/messages 核心系统日志<br>/var/log/maillog  邮件系统日志<br>/var/log/xferlog  FTP系统日志<br>/var/log/syslog   系统出问题的日志<br>/var/log/secure   安全信息和系统登录与网络连接的信息<br>/var/log/wtmp     登录记录<br>/var/spool/clientmqueue<br>/proc/interrupts<br>/etc/fstab        Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.</p>\n<h3 id=\"proc目录说明\"><a href=\"#proc目录说明\" class=\"headerlink\" title=\"proc目录说明\"></a>proc目录说明</h3><pre><code class=\"sh\">proc文件系统是一个伪文件系统，它只存在内存当中。\n/proc/buddyinfo   每个内存区中的每个order有多少块可用，和内存碎片问题有关\n/proc/cmdline     启动时传递给kernel的参数信息\n/proc/cpuinfo     cpu的信息\n/proc/crypto      内核使用的所有已安装的加密密码及细节\n/proc/devices     已经加载的设备并分类\n/proc/dma         已注册使用的ISA DMA频道列表\n/proc/execdomains Linux内核当前支持的execution domains\n/proc/fb          帧缓冲设备列表，包括数量和控制它的驱动\n/proc/filesystems 内核当前支持的文件系统类型\n/proc/interrupts  x86架构中的每个IRQ中断数\n/proc/iomem       每个物理设备当前在系统内存中的映射\n/proc/ioports     一个设备的输入输出所使用的注册端口范围\n/proc/kcore       代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb\n/proc/kmsg        记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理\n/proc/loadavg     根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关\n/proc/locks       内核锁住的文件列表\n/proc/mdstat      多硬盘，RAID配置信息(md=multiple disks)\n/proc/meminfo     RAM使用的相关信息\n/proc/misc        其他的主要设备(设备号为10)上注册的驱动\n/proc/modules     所有加载到内核的模块列表\n/proc/mounts      系统中使用的所有挂载\n/proc/mtrr        系统使用的Memory Type Range Registers (MTRRs)\n/proc/partitions  分区中的块分配信息\n/proc/pci         系统中的PCI设备列表\n/proc/slabinfo    系统中所有活动的 slab 缓存信息\n/proc/stat        所有的CPU活动信息\n/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的\n/proc/uptime      系统已经运行了多久\n/proc/swaps       交换空间的使用情况\n/proc/version     Linux内核版本和gcc版本\n/proc/bus         系统总线(Bus)信息，例如pci/usb等\n/proc/driver      驱动信息\n/proc/fs          文件系统信息\n/proc/ide         ide设备信息\n/proc/irq         中断请求设备信息\n/proc/net         网卡设备信息\n/proc/scsi        scsi设备信息\n/proc/tty         tty设备信息\n/proc/net/dev     显示网络适配器及统计信息\n/proc/vmstat      虚拟内存统计信息\n/proc/vmcore      内核panic时的内存映像\n/proc/diskstats   取得磁盘信息\n/proc/schedstat   kernel调度器的统计信息\n/proc/zoneinfo    显示内存空间的统计信息，对分析虚拟内存行为很有用\n#### 以下是/proc目录中进程N的信息\n/proc/N           pid为N的进程信息\n/proc/N/cmdline   进程启动命令\n/proc/N/cwd       链接到进程当前工作目录\n/proc/N/environ   进程环境变量列表\n/proc/N/exe       链接到进程的执行命令文件\n/proc/N/fd        包含进程相关的所有的文件描述符\n/proc/N/maps      与进程相关的内存映射信息\n/proc/N/mem       指代进程持有的内存，不可读\n/proc/N/root      链接到进程的根目录\n/proc/N/stat      进程的状态\n/proc/N/statm     进程使用的内存的状态\n/proc/N/status    进程状态信息，比stat/statm更具可读性\n/proc/self        链接到当前正在运行的进程\n</code></pre>\n<h3 id=\"fopen参数说明\"><a href=\"#fopen参数说明\" class=\"headerlink\" title=\"fopen参数说明\"></a>fopen参数说明</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td>以只读方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">r+</td>\n<td>以可读写方式打开文件，该文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rb+</td>\n<td>读写打开一个二进制文件，允许读写数据，文件必须存在。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td>打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+</td>\n<td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a+</td>\n<td>以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb</td>\n<td>只写打开或新建一个二进制文件；只允许写数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb+</td>\n<td>读写打开或建立一个二进制文件，允许读和写。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ab+</td>\n<td>读写打开一个二进制文件，允许读或在文件末追加数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wx</td>\n<td>创建文本文件,只允许写入数据.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wbx</td>\n<td>创建一个二进制文件,只允许写入数据.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+x</td>\n<td>创建一个文本文件,允许读写.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">wb+x</td>\n<td>创建一个二进制文件,允许读写.[C11]</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w+bx</td>\n<td>和”wb+x”相同[C11]</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>以x结尾的模式为独占模式,文件已存在或者无法创建(一般是路径不正确)都会导致fopen失败.文件以操作系统支持的独占模式打开.[C11]</p>\n</blockquote>\n<h2 id=\"linux驱动开发知识点\"><a href=\"#linux驱动开发知识点\" class=\"headerlink\" title=\"linux驱动开发知识点\"></a>linux驱动开发知识点</h2><h3 id=\"insmod-rmmod-加载-卸载模块\"><a href=\"#insmod-rmmod-加载-卸载模块\" class=\"headerlink\" title=\"insmod rmmod 加载 卸载模块\"></a>insmod rmmod 加载 卸载模块</h3><h3 id=\"i-max6UL\"><a href=\"#i-max6UL\" class=\"headerlink\" title=\"i.max6UL\"></a>i.max6UL</h3><h4 id=\"系统框图\"><a href=\"#系统框图\" class=\"headerlink\" title=\"系统框图\"></a>系统框图</h4><p><img src=\"./res/IMX6UL-BD.png\" alt=\"i.max6ul系统框图\"></p>\n<h3 id=\"linux启动过程\"><a href=\"#linux启动过程\" class=\"headerlink\" title=\"linux启动过程\"></a>linux启动过程</h3><p>系统上电—&gt;bootrom—&gt;uboot—&gt;kernel加载—&gt;init—&gt;应用程序</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><h3 id=\"makefile的规则\"><a href=\"#makefile的规则\" class=\"headerlink\" title=\"makefile的规则\"></a>makefile的规则</h3><pre><code class=\"makefile\">target xxx : prerequisites aaa\n    [command]\n    ...\n    ...\n</code></pre>\n<blockquote>\n<p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行</p>\n</blockquote>\n<h3 id=\"gcc工具链\"><a href=\"#gcc工具链\" class=\"headerlink\" title=\"gcc工具链\"></a>gcc工具链</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Binutils</td>\n<td>由汇编器（as）产生的目标代码（*.o）是不能直接在computer上运行的，它必须经过链接器（ld）的处理才能生成可执行代码。</td>\n</tr>\n<tr>\n<td>add2line</td>\n<td>将地址转换成文件名或行号对，以便调试程序</td>\n</tr>\n<tr>\n<td>ar</td>\n<td>从文件中创建、修改、扩展文件</td>\n</tr>\n<tr>\n<td>gasp</td>\n<td>汇编宏处理器</td>\n</tr>\n<tr>\n<td>nm</td>\n<td>从目标文件列举所有变量</td>\n</tr>\n<tr>\n<td>objcopy</td>\n<td>使用GNU BSD库把目标文件的内容从一种文件格式复制到另一种格式的目标文件中。</td>\n</tr>\n<tr>\n<td>objdump</td>\n<td>显示目标文件信息可发编译二进制文件，也可以对对象文件进行反汇编，并查看机器代码。</td>\n</tr>\n<tr>\n<td>readelf</td>\n<td>显示elf文件信息</td>\n</tr>\n<tr>\n<td>ranlib</td>\n<td>生成索引以加快对归档文件的访问，并将其保存到这个归档文件中。</td>\n</tr>\n<tr>\n<td>size</td>\n<td>列出目标模块或文件的代码尺寸。</td>\n</tr>\n<tr>\n<td>strings</td>\n<td>打印可打印的目标代码符号（至少4个字符）</td>\n</tr>\n<tr>\n<td>strip</td>\n<td>放弃所有符号连接，一般应用程序最终都要strip处理</td>\n</tr>\n<tr>\n<td>C++filt</td>\n<td>链接器ld通过该命令可过滤C++符号和JAVA符号，防止重载函数冲突。</td>\n</tr>\n<tr>\n<td>gprof</td>\n<td>显示程序调用段的各种数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nm命令\"><a href=\"#nm命令\" class=\"headerlink\" title=\"nm命令\"></a>nm命令</h3><p>显示二进制目标文件的符号表</p>\n<pre><code class=\"sh\">-A：每个符号前显示文件名；\n-D：显示动态符号；\n-g：仅显示外部符号；\n-r：反序显示符号表。\n</code></pre>\n<h3 id=\"ldd命令\"><a href=\"#ldd命令\" class=\"headerlink\" title=\"ldd命令\"></a>ldd命令</h3><p>用于打印程序或者库文件所依赖的共享库列表。</p>\n<pre><code class=\"sh\">-v：详细信息模式，打印所有相关信息；\n-u：打印未使用的直接依赖；\n-d：执行重定位和报告任何丢失的对象；\n-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；\n</code></pre>\n<h3 id=\"交叉编译工具链说明\"><a href=\"#交叉编译工具链说明\" class=\"headerlink\" title=\"交叉编译工具链说明\"></a>交叉编译工具链说明</h3><h4 id=\"gcc-交叉编译器\"><a href=\"#gcc-交叉编译器\" class=\"headerlink\" title=\"gcc 交叉编译器\"></a>gcc 交叉编译器</h4><blockquote>\n<p>将写好的C程序代码编译为ARM架构下的可执行文件.</p>\n</blockquote>\n<pre><code class=\"sh\">gcc hello.c -o hello\n</code></pre>\n<h4 id=\"ld-交叉链接器\"><a href=\"#ld-交叉链接器\" class=\"headerlink\" title=\"ld 交叉链接器\"></a>ld 交叉链接器</h4><blockquote>\n<p>将多个编译后产生的过程文件连接为一个最终的可执行文件。</p>\n</blockquote>\n<pre><code class=\"sh\">ld [options] 链接器脚本 -o 文件名.elf\n</code></pre>\n<h4 id=\"readelf-交叉ELF文件查看器\"><a href=\"#readelf-交叉ELF文件查看器\" class=\"headerlink\" title=\"readelf 交叉ELF文件查看器\"></a>readelf 交叉ELF文件查看器</h4><blockquote>\n<p>用来查看一个可执行文件的相关信息</p>\n</blockquote>\n<p>可以查看elf文件的运行架构，大小端等信息:</p>\n<pre><code class=\"sh\">readelf -a 文件名.elf\n</code></pre>\n<p>显示程序需要的动态链接库:</p>\n<pre><code class=\"sh\">readelf -d 文件名.elf\n</code></pre>\n<h4 id=\"objdump-交叉反汇编器\"><a href=\"#objdump-交叉反汇编器\" class=\"headerlink\" title=\"objdump 交叉反汇编器\"></a>objdump 交叉反汇编器</h4><blockquote>\n<p>将一个可执行文件转换为汇编下的程序</p>\n</blockquote>\n<pre><code class=\"sh\">-objdump -D -S elf文件名 &gt;目标文件\n</code></pre>\n<h4 id=\"objcopy-交叉转换器\"><a href=\"#objcopy-交叉转换器\" class=\"headerlink\" title=\"objcopy 交叉转换器\"></a>objcopy 交叉转换器</h4><blockquote>\n<p>将elf格式文件转换成其他的格式</p>\n</blockquote>\n<pre><code class=\"sh\">objcopy -O 目标文件格式 原ELF文件 目标文件\n</code></pre>\n<p>例子:</p>\n<pre><code class=\"sh\">objcopy -O binary a.elf a.bin\n</code></pre>\n"},{"title":"嵌入式笔记：uboot学习","_content":"嵌入式笔记：uboot学习\n\n## 源码目录：\n\tapi：\t存放uboot提供的接口函数\n\tarch：\t存放跟芯片相关的文件\n\tboard：\t开发板配置文件\n\tcommon:\tuboot命令行下支持的命令\n\tdisk：\t磁盘支持\n\tdoc：\t文件目录\n\tdrivers:设备驱动程序\n\texamples例程\n\tfs:\t支持的文件系统，cramfs fat fdos jffs2 registerfs\n\tinclude:uboot使用到的头文件\n\tlib_xxx:与体系结构相关的库文件\n\tnet:\t网络协议栈相关的文件 BOOTP TFTP RARP NFS\n\ttools:\t工具 mkimage crc\n\n## 启动流程：\n\tstage1：cpu 硬件初始化，汇编实现，加载U-Boot到RAM空间 设置堆栈 跳转到stage2\n\tstage2：一般主函数是lib_arm/board.c中的start_armboot。\n\t\t调用一系列的初始化函数\n\t\t将内核从flash复制到ram中\n\t\t进入uboot命令行\n\t\t调用内核\n\n","source":"_posts/uboot.md","raw":"---\ntitle: 嵌入式笔记：uboot学习\n---\n嵌入式笔记：uboot学习\n\n## 源码目录：\n\tapi：\t存放uboot提供的接口函数\n\tarch：\t存放跟芯片相关的文件\n\tboard：\t开发板配置文件\n\tcommon:\tuboot命令行下支持的命令\n\tdisk：\t磁盘支持\n\tdoc：\t文件目录\n\tdrivers:设备驱动程序\n\texamples例程\n\tfs:\t支持的文件系统，cramfs fat fdos jffs2 registerfs\n\tinclude:uboot使用到的头文件\n\tlib_xxx:与体系结构相关的库文件\n\tnet:\t网络协议栈相关的文件 BOOTP TFTP RARP NFS\n\ttools:\t工具 mkimage crc\n\n## 启动流程：\n\tstage1：cpu 硬件初始化，汇编实现，加载U-Boot到RAM空间 设置堆栈 跳转到stage2\n\tstage2：一般主函数是lib_arm/board.c中的start_armboot。\n\t\t调用一系列的初始化函数\n\t\t将内核从flash复制到ram中\n\t\t进入uboot命令行\n\t\t调用内核\n\n","slug":"uboot","published":1,"date":"2018-02-28T01:20:58.916Z","updated":"2018-02-28T01:14:42.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbf00099vf7u8ti8jq1","content":"<p>嵌入式笔记：uboot学习</p>\n<h2 id=\"源码目录：\"><a href=\"#源码目录：\" class=\"headerlink\" title=\"源码目录：\"></a>源码目录：</h2><pre><code>api：    存放uboot提供的接口函数\narch：    存放跟芯片相关的文件\nboard：    开发板配置文件\ncommon:    uboot命令行下支持的命令\ndisk：    磁盘支持\ndoc：    文件目录\ndrivers:设备驱动程序\nexamples例程\nfs:    支持的文件系统，cramfs fat fdos jffs2 registerfs\ninclude:uboot使用到的头文件\nlib_xxx:与体系结构相关的库文件\nnet:    网络协议栈相关的文件 BOOTP TFTP RARP NFS\ntools:    工具 mkimage crc\n</code></pre><h2 id=\"启动流程：\"><a href=\"#启动流程：\" class=\"headerlink\" title=\"启动流程：\"></a>启动流程：</h2><pre><code>stage1：cpu 硬件初始化，汇编实现，加载U-Boot到RAM空间 设置堆栈 跳转到stage2\nstage2：一般主函数是lib_arm/board.c中的start_armboot。\n    调用一系列的初始化函数\n    将内核从flash复制到ram中\n    进入uboot命令行\n    调用内核\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：uboot学习</p>\n<h2 id=\"源码目录：\"><a href=\"#源码目录：\" class=\"headerlink\" title=\"源码目录：\"></a>源码目录：</h2><pre><code>api：    存放uboot提供的接口函数\narch：    存放跟芯片相关的文件\nboard：    开发板配置文件\ncommon:    uboot命令行下支持的命令\ndisk：    磁盘支持\ndoc：    文件目录\ndrivers:设备驱动程序\nexamples例程\nfs:    支持的文件系统，cramfs fat fdos jffs2 registerfs\ninclude:uboot使用到的头文件\nlib_xxx:与体系结构相关的库文件\nnet:    网络协议栈相关的文件 BOOTP TFTP RARP NFS\ntools:    工具 mkimage crc\n</code></pre><h2 id=\"启动流程：\"><a href=\"#启动流程：\" class=\"headerlink\" title=\"启动流程：\"></a>启动流程：</h2><pre><code>stage1：cpu 硬件初始化，汇编实现，加载U-Boot到RAM空间 设置堆栈 跳转到stage2\nstage2：一般主函数是lib_arm/board.c中的start_armboot。\n    调用一系列的初始化函数\n    将内核从flash复制到ram中\n    进入uboot命令行\n    调用内核\n</code></pre>"},{"title":"阿里hr Q&A","date":"2018-03-03T14:15:21.000Z","_content":"### 你上一家为什么离职\n主要是公司的行业方向总是在变，从我入职以来，刚开始是研发智能手表，2,3年前智能手表非常火，公司虽然已经做出来手表了，\n但是因为需求不高，没多少人买，所以项目就进行不下去了。之后公司又开始研发电力猫，物联网的方向，持续了1年，\n现在区块链，虚拟货币火起来了，公司又开始研发区块链，虚拟货币，挖矿机之类的了。\n我觉得公司行业变来变去，不符合我的职业发展，我想一直专攻物联网的方向，成为一个这个领域的专家大神，做出像android系统一样让全世界都在用的技术，或者产品。\n### 你什么时候离职\n我已经离职了，正在全身心的找工作，所以要是需要的话我可以在几天内到岗\n### 你为什么来阿里\n阿里现在算是中国最好最有影响力的企业了吧，而且阿里一直在改变世界，从淘宝，到现在的无现金支付，达摩院，和以后的无人售货，物联网城市，这些都是在改变世界，我觉得能成为阿里的员工很骄傲。\n### 你觉得能够胜任这份工作吗\n我觉得我非常非常的适合这份工作\n我之前从事过linux软件开发 驱动开发，单片机开发，而且我也很精通操作系统的原理，我也会js，前端开发，物联网的很多协议，这些alios-things里面都有涉及到，所以我看alios-things的源码我感觉非常的熟悉，亲切。\n而且我觉得我抗压能力很强，可以加班按时完成任务。\n\n### 你的优点和缺点\n1. 优点\n    * 我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。\n    * 在学校我得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。\n    * 我懂得东西很全面，做过的项目也很多。\n    * 吃苦耐劳，肯干活，学习能力很强，我觉得我还年轻，现在是我的黄金年龄，我要去拼一拼。\n2. 缺点\n    * 性格偏内向。\n    * 比较沉闷，业余的时候也只是喜欢写写代码，平常的运动也只是跑跑步。\n### 个人爱好\n1. 写代码。\n2. 跑步\n3. 游泳\n4. 稍微会一点滑板。\n### 为什么我们应该录取你？\n1. 我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。\n2. 参加了很多编程类的竞赛，也得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。\n3. 而且我也吃苦耐劳，肯干活，学习能力也很强。\n### 未来规划是怎么样的\n1. 我想成为物联网领域的大神专家，做出像android系统一样让全世界都在用的技术或者产品。\n2. 其他方面呢，我已经在杭州买房了，但是我并不满足我现在的房子，可以的话，我想在公司附近再买一套房子，这样可以更专注于工作上。\n### 提问HR\n1. 这个岗位会在哪里办公啊，上海还是杭州，具体在哪个区。\n2. 接下来的面试流程是怎么样子的。\n    问题其实我没有什么想问的了，要了解的我都找同学问清楚了，百度知乎上面也搜到过。","source":"_posts/阿里Q.md","raw":"title: 阿里hr Q&A\ndate: 2018-03-03 22:15:21\n---\n### 你上一家为什么离职\n主要是公司的行业方向总是在变，从我入职以来，刚开始是研发智能手表，2,3年前智能手表非常火，公司虽然已经做出来手表了，\n但是因为需求不高，没多少人买，所以项目就进行不下去了。之后公司又开始研发电力猫，物联网的方向，持续了1年，\n现在区块链，虚拟货币火起来了，公司又开始研发区块链，虚拟货币，挖矿机之类的了。\n我觉得公司行业变来变去，不符合我的职业发展，我想一直专攻物联网的方向，成为一个这个领域的专家大神，做出像android系统一样让全世界都在用的技术，或者产品。\n### 你什么时候离职\n我已经离职了，正在全身心的找工作，所以要是需要的话我可以在几天内到岗\n### 你为什么来阿里\n阿里现在算是中国最好最有影响力的企业了吧，而且阿里一直在改变世界，从淘宝，到现在的无现金支付，达摩院，和以后的无人售货，物联网城市，这些都是在改变世界，我觉得能成为阿里的员工很骄傲。\n### 你觉得能够胜任这份工作吗\n我觉得我非常非常的适合这份工作\n我之前从事过linux软件开发 驱动开发，单片机开发，而且我也很精通操作系统的原理，我也会js，前端开发，物联网的很多协议，这些alios-things里面都有涉及到，所以我看alios-things的源码我感觉非常的熟悉，亲切。\n而且我觉得我抗压能力很强，可以加班按时完成任务。\n\n### 你的优点和缺点\n1. 优点\n    * 我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。\n    * 在学校我得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。\n    * 我懂得东西很全面，做过的项目也很多。\n    * 吃苦耐劳，肯干活，学习能力很强，我觉得我还年轻，现在是我的黄金年龄，我要去拼一拼。\n2. 缺点\n    * 性格偏内向。\n    * 比较沉闷，业余的时候也只是喜欢写写代码，平常的运动也只是跑跑步。\n### 个人爱好\n1. 写代码。\n2. 跑步\n3. 游泳\n4. 稍微会一点滑板。\n### 为什么我们应该录取你？\n1. 我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。\n2. 参加了很多编程类的竞赛，也得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。\n3. 而且我也吃苦耐劳，肯干活，学习能力也很强。\n### 未来规划是怎么样的\n1. 我想成为物联网领域的大神专家，做出像android系统一样让全世界都在用的技术或者产品。\n2. 其他方面呢，我已经在杭州买房了，但是我并不满足我现在的房子，可以的话，我想在公司附近再买一套房子，这样可以更专注于工作上。\n### 提问HR\n1. 这个岗位会在哪里办公啊，上海还是杭州，具体在哪个区。\n2. 接下来的面试流程是怎么样子的。\n    问题其实我没有什么想问的了，要了解的我都找同学问清楚了，百度知乎上面也搜到过。","slug":"阿里Q","published":1,"updated":"2018-03-04T13:37:21.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbg000a9vf7krky60oj","content":"<h3 id=\"你上一家为什么离职\"><a href=\"#你上一家为什么离职\" class=\"headerlink\" title=\"你上一家为什么离职\"></a>你上一家为什么离职</h3><p>主要是公司的行业方向总是在变，从我入职以来，刚开始是研发智能手表，2,3年前智能手表非常火，公司虽然已经做出来手表了，<br>但是因为需求不高，没多少人买，所以项目就进行不下去了。之后公司又开始研发电力猫，物联网的方向，持续了1年，<br>现在区块链，虚拟货币火起来了，公司又开始研发区块链，虚拟货币，挖矿机之类的了。<br>我觉得公司行业变来变去，不符合我的职业发展，我想一直专攻物联网的方向，成为一个这个领域的专家大神，做出像android系统一样让全世界都在用的技术，或者产品。</p>\n<h3 id=\"你什么时候离职\"><a href=\"#你什么时候离职\" class=\"headerlink\" title=\"你什么时候离职\"></a>你什么时候离职</h3><p>我已经离职了，正在全身心的找工作，所以要是需要的话我可以在几天内到岗</p>\n<h3 id=\"你为什么来阿里\"><a href=\"#你为什么来阿里\" class=\"headerlink\" title=\"你为什么来阿里\"></a>你为什么来阿里</h3><p>阿里现在算是中国最好最有影响力的企业了吧，而且阿里一直在改变世界，从淘宝，到现在的无现金支付，达摩院，和以后的无人售货，物联网城市，这些都是在改变世界，我觉得能成为阿里的员工很骄傲。</p>\n<h3 id=\"你觉得能够胜任这份工作吗\"><a href=\"#你觉得能够胜任这份工作吗\" class=\"headerlink\" title=\"你觉得能够胜任这份工作吗\"></a>你觉得能够胜任这份工作吗</h3><p>我觉得我非常非常的适合这份工作<br>我之前从事过linux软件开发 驱动开发，单片机开发，而且我也很精通操作系统的原理，我也会js，前端开发，物联网的很多协议，这些alios-things里面都有涉及到，所以我看alios-things的源码我感觉非常的熟悉，亲切。<br>而且我觉得我抗压能力很强，可以加班按时完成任务。</p>\n<h3 id=\"你的优点和缺点\"><a href=\"#你的优点和缺点\" class=\"headerlink\" title=\"你的优点和缺点\"></a>你的优点和缺点</h3><ol>\n<li>优点<ul>\n<li>我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。</li>\n<li>在学校我得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。</li>\n<li>我懂得东西很全面，做过的项目也很多。</li>\n<li>吃苦耐劳，肯干活，学习能力很强，我觉得我还年轻，现在是我的黄金年龄，我要去拼一拼。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>性格偏内向。</li>\n<li>比较沉闷，业余的时候也只是喜欢写写代码，平常的运动也只是跑跑步。<h3 id=\"个人爱好\"><a href=\"#个人爱好\" class=\"headerlink\" title=\"个人爱好\"></a>个人爱好</h3></li>\n</ul>\n</li>\n<li>写代码。</li>\n<li>跑步</li>\n<li>游泳</li>\n<li>稍微会一点滑板。<h3 id=\"为什么我们应该录取你？\"><a href=\"#为什么我们应该录取你？\" class=\"headerlink\" title=\"为什么我们应该录取你？\"></a>为什么我们应该录取你？</h3></li>\n<li>我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。</li>\n<li>参加了很多编程类的竞赛，也得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。</li>\n<li>而且我也吃苦耐劳，肯干活，学习能力也很强。<h3 id=\"未来规划是怎么样的\"><a href=\"#未来规划是怎么样的\" class=\"headerlink\" title=\"未来规划是怎么样的\"></a>未来规划是怎么样的</h3></li>\n<li>我想成为物联网领域的大神专家，做出像android系统一样让全世界都在用的技术或者产品。</li>\n<li>其他方面呢，我已经在杭州买房了，但是我并不满足我现在的房子，可以的话，我想在公司附近再买一套房子，这样可以更专注于工作上。<h3 id=\"提问HR\"><a href=\"#提问HR\" class=\"headerlink\" title=\"提问HR\"></a>提问HR</h3></li>\n<li>这个岗位会在哪里办公啊，上海还是杭州，具体在哪个区。</li>\n<li>接下来的面试流程是怎么样子的。<br> 问题其实我没有什么想问的了，要了解的我都找同学问清楚了，百度知乎上面也搜到过。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"你上一家为什么离职\"><a href=\"#你上一家为什么离职\" class=\"headerlink\" title=\"你上一家为什么离职\"></a>你上一家为什么离职</h3><p>主要是公司的行业方向总是在变，从我入职以来，刚开始是研发智能手表，2,3年前智能手表非常火，公司虽然已经做出来手表了，<br>但是因为需求不高，没多少人买，所以项目就进行不下去了。之后公司又开始研发电力猫，物联网的方向，持续了1年，<br>现在区块链，虚拟货币火起来了，公司又开始研发区块链，虚拟货币，挖矿机之类的了。<br>我觉得公司行业变来变去，不符合我的职业发展，我想一直专攻物联网的方向，成为一个这个领域的专家大神，做出像android系统一样让全世界都在用的技术，或者产品。</p>\n<h3 id=\"你什么时候离职\"><a href=\"#你什么时候离职\" class=\"headerlink\" title=\"你什么时候离职\"></a>你什么时候离职</h3><p>我已经离职了，正在全身心的找工作，所以要是需要的话我可以在几天内到岗</p>\n<h3 id=\"你为什么来阿里\"><a href=\"#你为什么来阿里\" class=\"headerlink\" title=\"你为什么来阿里\"></a>你为什么来阿里</h3><p>阿里现在算是中国最好最有影响力的企业了吧，而且阿里一直在改变世界，从淘宝，到现在的无现金支付，达摩院，和以后的无人售货，物联网城市，这些都是在改变世界，我觉得能成为阿里的员工很骄傲。</p>\n<h3 id=\"你觉得能够胜任这份工作吗\"><a href=\"#你觉得能够胜任这份工作吗\" class=\"headerlink\" title=\"你觉得能够胜任这份工作吗\"></a>你觉得能够胜任这份工作吗</h3><p>我觉得我非常非常的适合这份工作<br>我之前从事过linux软件开发 驱动开发，单片机开发，而且我也很精通操作系统的原理，我也会js，前端开发，物联网的很多协议，这些alios-things里面都有涉及到，所以我看alios-things的源码我感觉非常的熟悉，亲切。<br>而且我觉得我抗压能力很强，可以加班按时完成任务。</p>\n<h3 id=\"你的优点和缺点\"><a href=\"#你的优点和缺点\" class=\"headerlink\" title=\"你的优点和缺点\"></a>你的优点和缺点</h3><ol>\n<li>优点<ul>\n<li>我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。</li>\n<li>在学校我得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。</li>\n<li>我懂得东西很全面，做过的项目也很多。</li>\n<li>吃苦耐劳，肯干活，学习能力很强，我觉得我还年轻，现在是我的黄金年龄，我要去拼一拼。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>性格偏内向。</li>\n<li>比较沉闷，业余的时候也只是喜欢写写代码，平常的运动也只是跑跑步。<h3 id=\"个人爱好\"><a href=\"#个人爱好\" class=\"headerlink\" title=\"个人爱好\"></a>个人爱好</h3></li>\n</ul>\n</li>\n<li>写代码。</li>\n<li>跑步</li>\n<li>游泳</li>\n<li>稍微会一点滑板。<h3 id=\"为什么我们应该录取你？\"><a href=\"#为什么我们应该录取你？\" class=\"headerlink\" title=\"为什么我们应该录取你？\"></a>为什么我们应该录取你？</h3></li>\n<li>我从大二的时候就已经开始编程，写代码了，现在差不多从事这一行大概有7年了吧。</li>\n<li>参加了很多编程类的竞赛，也得过几个国奖省奖，在公司的时候，也是团队里面最优秀的一个。</li>\n<li>而且我也吃苦耐劳，肯干活，学习能力也很强。<h3 id=\"未来规划是怎么样的\"><a href=\"#未来规划是怎么样的\" class=\"headerlink\" title=\"未来规划是怎么样的\"></a>未来规划是怎么样的</h3></li>\n<li>我想成为物联网领域的大神专家，做出像android系统一样让全世界都在用的技术或者产品。</li>\n<li>其他方面呢，我已经在杭州买房了，但是我并不满足我现在的房子，可以的话，我想在公司附近再买一套房子，这样可以更专注于工作上。<h3 id=\"提问HR\"><a href=\"#提问HR\" class=\"headerlink\" title=\"提问HR\"></a>提问HR</h3></li>\n<li>这个岗位会在哪里办公啊，上海还是杭州，具体在哪个区。</li>\n<li>接下来的面试流程是怎么样子的。<br> 问题其实我没有什么想问的了，要了解的我都找同学问清楚了，百度知乎上面也搜到过。</li>\n</ol>\n"},{"title":"嵌入式笔记：tcpip协议栈","_content":"嵌入式笔记：tcpip协议栈\n\n# 目录\n* [tcpip模型](#tcpip模型)\n* [以太网协议](#以太网协议)\n* [ARP地址解析协议](#ARP地址解析协议)\n* [TCP协议](#TCP协议)\n\n## tcpip模型\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>OSI模型</td>\n      <td>linux tcpip模型</td>\n      <td>常用协议</td>\n      <td>网络设备</td>\n   </tr>\n   <tr>\n      <td>网络层</td>\n      <td rowspan=\"3\">网络层</td>\n      <td rowspan=\"3\">telnet/DHCP/TFTP/FTP/MQTT/NFS/DNS/FTP/SNMP</td>\n      <td rowspan=\"3\"></td>\n   </tr>\n   <tr>\n      <td>表示层</td>\n   </tr>\n   <tr>\n      <td>会话层</td>\n   </tr>\n   <tr>\n      <td>传输层</td>\n      <td>传输层</td>\n      <td>TCP/UDP</td>\n      <td>四层交换机</td>\n   </tr>\n   <tr>\n      <td>网络层</td>\n      <td>网络层</td>\n      <td>IP/ICMP/IGMP/ARP</td>\n      <td>路由器，三层交换机</td>\n   </tr>\n   <tr>\n      <td>数据链路层</td>\n      <td rowspan=\"2\">网络接口层</td>\n      <td rowspan=\"2\">Ethernet/PPP/PPPoE</td>\n      <td>交换机（二层交换机），网桥，网卡（一半物理层，一半链路层）</td>\n   </tr>\n   <tr>\n      <td>物理层</td>\n      <td>中继器、集线器</td>\n   </tr>\n</table>\n\n## 以太网协议\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>前导码</td>\n      <td>SFD</td>\n      <td>目标地址</td>\n      <td>源地址</td>\n      <td>长度/类型</td>\n      <td>数据</td>\n      <td>CRC校验</td>\n   </tr>\n   <tr>\n      <td>7字节</td>\n      <td>1字节</td>\n      <td>6字节</td>\n      <td>6字节</td>\n      <td>2字节</td>\n      <td>46~1500字节</td>\n      <td>4字节</td>\n   </tr>\n</table>\n\n> 1. <strong>前导码和SFD：</strong> 不能算是以太网数据帧，是以太网在物理层上发送以太网数据时添加上去的。\n> 2. <strong>长度/类型：</strong> 大于1518，表示该以太网帧中的数据属于哪个上层协议（0x0800:IP数据包；0x0806:ARP数据包）\n> 3. <strong>单播地址、组播地址：</strong> 第一个字节的bit0为0代表单播地址，为1代表组播地址。\n\n## ARP地址解析协议\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>以太网首部</td>\n      <td>硬件类型</td>\n      <td>协议类型</td>\n      <td>MAC地址长度</td>\n      <td>协议地址长度</td>\n      <td>OP</td>\n      <td>源MAC地址</td>\n      <td>源IP地址</td>\n      <td>目标MAC地址</td>\n      <td>目标IP地址</td>\n   </tr>\n   <tr>\n      <td>14字节</td>\n      <td>2字节</td>\n      <td>2字节</td>\n      <td>1字节</td>\n      <td>1字节</td>\n      <td>2字节</td>\n      <td>6字节</td>\n      <td>4字节</td>\n      <td>6字节</td>\n      <td>4字节</td>\n   </tr>\n</table>\n\n> 1. <strong>MAC地址长度和IP地址长度：</strong> 分别为6和4.\n> 2. <strong>OP：</strong>ARP请求（值为1）、ARP应答（值为2）。\n\n## IP地址分类\nIP地址=网络地址＋主机地址\n\n|分类|开头|第一个字节范围|总体范围|掩码地址|说明|\n|---|:---:|:----:|--------------|:---:|--|\n|A类|0    |1~126  |1.0.0.0 - 126.255.255.255|255.0.0.0|给规模特别大的网络使用|\n|B类|10   |128~191|128.0.0.0 - 191.255.255.255|255.255.0.0|给一般的中型网络|\n|C类|110  |192~223|192.0.0.0 - 223.255.255.255|255.255.255.0|给小型网络|\n|D类|1110 |224~239|224.0.0.0 - 239.255.255.255| - |用于多点广播（组播）|\n|E类|11110|240~255|240.0.0.0 - 255.255.255.255| - |用于广播地址|\n\n其他：\n> 1. 主机号全为0表示本网络本身 主机号全为1表示本网络广播地址\n> 2. 127.0.0.0 环路自检地址，表示任意主机本身\n> 3. 0.0.0.0 表示本网络的本主机\n> 4. 专用地址： A类：10.0.0.0—10.255.255.255，B类：172.16.0.0—172.31.255.255，C类：192.168.0.0—192.168.255.255。\n> 5. IP地址与子网掩码相与得到网络号\n## TCP与UDP的区别\n|TCP|UDP|\n|---|---|\n|面向连接,需要三次握手，4次挥手|不需要建立连接 |\n|无差错，不丢失，不重复，且按序到达|不保证数据可靠、按序到达|\n|面向字节流|面向报文|\n|有拥塞控制,不会使源主机的发送速率降低|没有拥塞控制|\n|连接只能是点到点|支持一对一，一对多，多对一和多对多的交互通信|\n|首部开销20字节|首部开销小，只有8个字节|\n|ftp telnet http https SMTP POP3|DNS DHCP tftp IGMP RTP|\n\n## ICMP协议\n> 1. ICMP允许主机或路由报告差错情况和提供有关异常情况\n> 2. ICMP是因特网的标准协议，属于IP层的协议。\n\n### ping包\n\n同一个局域网中： \n1. Pc1在应用层发起个目标IP位IP2的Ping请求。\n2. 传输层接到上层请求的数据，将数据分段并加上UDP报头。下传到Internet层。\n3. 网际层接收来处上层的数据后，根据ICMP协议进行封装，添加PC1的IP为源IP为和PC2IP为目标IP后封装成数据包。下传到网络接口层。\n4. 网络接口层接收数据包后，进行封装，源MAC地址为PC1的MAC地址，目标MAC地址则查询自己的ARP缓存表获取。如果PC1 arp缓存表中没有目标IP对应的MAC地址，则PC1发出一个ARP广播报文。ARP报文中源MAC地址为Pc1mac地址，源IP地址为pc1 IP，所要请求的是PC2的IP对应的mac地址。\n5. PC2收到ARP广播后，进行解封装，发现所请求的MAC地址是自己的。则PC2将PC1的mac地址写入arp缓存表中。然后向PC1发送一个 ARP应答单播。该单播消息包括目标IP为PC1ip，目标Mac为pc1mac地址，源IP为PC2的IP，源Mac为pc2的Mac。\n6. Pc1接收到PC2的arp应答报文后，将Pc2的MAC地址存入arp缓存中，并将Pc2的Mac地址作为目标地址封装到数据帧中。发给下层进行网络传输。\n7. PC2接收这个帧后，在网络接口层查看目标mac地址是否指向自己。是，PC2则将帧头去掉，向上层传输。\n8. Pc2网际层接收到这个信息包，查看包头，发现目标IP和自己匹配，则解封装，将数据向上层传输。\n9. 传输层接收来自下层的Ping请求的UDP报文，则去掉UDP报头，向应用层传送。\n10. 应用层收到ping请求后，发送一个PIng回应报文给PC1\n\n## TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\n### 三次握手\n* 第一次握手：客户机首先向服务器的TCP发送一个连接请求报文段，这个特殊的报文段不含应用层数据，其首部中同步位SYN被设置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号).\n* 第二次握手：服务器的TCP收到连接请求报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y. 确认包同样不包含应用层数据。\n* 第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的确认为ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。因为TCP提供全双工通信，因此双方任何时候都可以发送数据。\n### 四次挥手 \n* 第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文，并停止再发送数据，主动关闭TCP连接。该报文段的FIN标志位被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。\n* 第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1\n* 第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack= u+1,序号seq =w,已经发送过的数据最后一个字节加1。确认为ACK=1. (FIN = 1, ACK=1,seq = w, ack =u+1) 第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过实践等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。 (ACK=1,seq=u+1,ack=w+1)\n如下图所示：\n\n### tcp协议图解\n\n![tcp协议图解](res/tcp协议图解.jpg)\n\n## 为什么会采用三次握手，若采用二次握手可以吗？\n采用三次握手是为了防止失效的连接请求报文段再次传到服务器，因而产生错误。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。 如果只采用一次的话，客户端不知道服务端是否已经收到自己发送的数据，则会不断地发送数据。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手\n\n## 为什么四次挥手，主动方要等待２MSL后才关闭连接．\n一、保证TCP协议的全双工连接能够可靠关闭． 主要为了确保对方能受到ACK信息. 如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。所以，Client不是直接进入CLOSED，而是要保持2MSL,如果在这个时间内又收到了server的关闭请求时可以进行重传，否则说明server已经受到确认包则可以关闭.\n\n## TCP拥塞控制\n\n为了更好对TCP进行拥塞控制，因特网建议标准定义了以下四种算法：慢开始，拥塞避免，快重传，快恢复。 首先在TCP要求发送端维护两个窗口： 1） 接收窗口rwnd，接收方根据当前缓存大小锁许诺的最新窗口值。 2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。 发送窗口的上限是取这两者的最小值。 慢开始： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加1. Cwnd的大小呈指数增长。 拥塞避免算法： 当cwnd大于等于慢开始门限ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到超时事件的发生时，就将慢开始门限设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快恢复：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，cwnd设置为慢开始门限减半后的数值（与慢开始不同）。\n\n## TCP滑动窗口与回退N针协议\n\n滑动窗口： 发送方都维持一组连续的允许发送的帧的序号称为发送窗口。同时接收方也维持一组连续的允许接收的帧序号，称为接收窗口。发送窗口是用来对发送方进行流量控制，接收窗口是用来控制接收那些数据帧不可以接收那些帧。 在发送端，收到一个确认帧，发送窗口就向前滑动一个帧位置，当发送窗口没有可以发送的帧时，发送方就停止发送。直到接收方发送的确认帧使发送窗口向前移动。 在接收端，只有收到数据帧的序号落在接收窗口内才将该帧收下，否则一律丢弃。每收到一个帧后就发送回确认帧。\n后退N帧协议 发送窗口大于1，接收窗口等于1.在后退N帧中，发送方不需要收到上一帧的ACK后才能发送下一帧，而是可以连续发送帧。当接收方检测出失序信息帧后，要求发送方重发最后一个正确接收的帧之后的所有未被确认的帧。源站每发完一帧就要为该帧设置超时计时器，如果在超时时间内没有收到确认帧则进行重发。服务端会采用累积确认的方式，不是每个帧都发确认，可以连续收到好几个正确帧后发回一个确认信息。接收方因为窗口为1，所以必须按序接收数据帧，如果某个序大于当前所期望的序号时就会连续发送3个ACK确认帧，要求客户端重传失序帧。\n\n## TCP的可靠性如何保证\n\n在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。\n\n## 各种协议对应的传输层协议\n\n|Ethernet应用|IP   |ICMP |UDP  |TCP  |SCIP|\n|-----------|:---:|:---:|:---:|:---:|:---:|\n|ping       |      |     |  ●  |     |     |\n|traceroute |      |     |  ●  |  ●  |     |\n|OSPF(路由协议)|  ● |     |     |     |     |\n|RIP(路由协议) |    |     |  ●  |     |     |\n|BGP(路由协议) |    |     |     |  ●  |     |\n|BOOTP(引导协议)|   |     |  ●  |     |     |\n|DHCP       |      |  ●  |     |     |     |\n|NTP(时间协议)|     |  ●  |    |     |     |\n|TFTP(低级FTP)|    |  ●  |     |     |     |\n|SNMP(网络管理)|    |  ●  |     |     |     |\n|IGMP(组播管理)|    |  ●  |     |     |     |\n|SMTP(电子邮件)|    |     |     |  ●  |     |\n|telnet(远程登录)|  |     |     |  ●  |     |\n|SSH(安全远程登录)|  |     |     |  ●  |     |\n|FTP(文件传输)|     |     |     |  ●  |     |\n|HTTP(web)|        |     |     |  ●  |     |\n|NNTP(网络新闻)|    |     |     |  ●  |     |\n|LPR(远程打印)|     |     |     |  ●  |     |\n|DNS(域名系统)|     |     |  ●  |  ●  |     |\n|NFS(网络文件系统)|  |     |  ●  |  ●  |     |\n|Sun RPC(远程过程调用)||   |  ●  |  ●  |     |\n|DCE RPC(远程过程调用)||   |  ●  |  ●  |     |\n|IUA(ISDN)|        |     |     |     |  ●  |\n|M2UA/M3UA(SS7电话信令)|| |     |     |  ●  |\n|H.248(媒体网关控制)||     |  ●  |  ●  |  ●  |\n|H.323(IP电话)|     |     |  ●  |  ●  |  ●  |\n|H.248(IP电话)|     |     |  ●  |  ●  |  ●  |\n## MQTT协议\nhttps://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html\n### MQTT有3种网络连接方式\ntcp（1883端口） TLS（8883端口） websocket\n### 主题过滤器 Topic Filter\n订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。\n### 控制报文 MQTT Control Packet\n通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文\n名字\t值\t报文流动方向\t描述\nReserved\t0\t禁止\t保留\nCONNECT\t1\t客户端到服务端\t客户端请求连接服务端\nCONNACK\t2\t服务端到客户端\t连接报文确认\nPUBLISH\t3\t两个方向都允许\t发布消息\nPUBACK\t4\t两个方向都允许\tQoS 1消息发布收到确认\nPUBREC\t5\t两个方向都允许\t发布收到（保证交付第一步）\nPUBREL\t6\t两个方向都允许\t发布释放（保证交付第二步）\nPUBCOMP\t7\t两个方向都允许\tQoS 2消息发布完成（保证交互第三步）\nSUBSCRIBE\t8\t客户端到服务端\t客户端订阅请求\nSUBACK\t9\t服务端到客户端\t订阅请求报文确认\nUNSUBSCRIBE\t10\t客户端到服务端\t客户端取消订阅请求\nUNSUBACK\t11\t服务端到客户端\t取消订阅报文确认\nPINGREQ\t12\t客户端到服务端\t心跳请求\nPINGRESP\t13\t服务端到客户端\t心跳响应\nDISCONNECT\t14\t客户端到服务端\t客户端断开连接\nReserved\t15\t禁止\t保留\n### 大端模式\n> MQTT数据格式使用大端模式存放\n### MQTT控制报文结构\n<table>\n    <tr>\n    <td>固定报头</td>\n    <td>可变报头</td>\n    <td>payload</td>\n    </tr>\n</table>\n\n#### 固定报头\n> 总共是2-5个字节\n* 第1个字节\n\n<table style=\"text-align:center\">\n    <tr>\n    <td>7</td>\n    <td>6</td>\n    <td>5</td>\n    <td>4</td>\n    <td>3</td>\n    <td>2</td>\n    <td>1</td>\n    <td>0</td>\n    </tr>\n    <tr>\n    <td colspan=\"4\">表示控制报文类型</td>\n    <td colspan=\"4\">表示控制报文类型的标志位</td>\n    </tr>\n</table>\n\n* 第2-5字节\n    剩余长度 表示当前报文剩余部分的字节数，包括可变报头和payload的数据。\n\n#### 剩余长度\n> 剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个延续位（continuation bit）\n\n    剩余长度字段最大4个字节。\n\n|字节数|最小值|最大值|\n|:--:|--|--|\n|1|0 (0x00)|127 (0x7F)|\n|2|128 (0x80, 0x01)|16383 (0xFF, 0x7F)|\n|3|16 384 (0x80, 0x80, 0x01)|2097151 (0xFF, 0xFF, 0x7F)|\n|4|2 097 152 (0x80, 0x80, 0x80, 0x01)|268435455 (0xFF, 0xFF, 0xFF, 0x7F)|\n\n变长编码方案代码：\n```c\ndo\n    encodedByte = X MOD 128\n    X = X DIV 128\n    // if there are more data to encode, set the top bit of this byte\n    if ( X > 0 )\n        encodedByte = encodedByte OR 128\n    endif\n    'output' encodedByte\nwhile ( X > 0 )\n```\n\n变长解码方案代码：\n```c\nmultiplier = 1\nvalue = 0\ndo\n    encodedByte = 'next byte from stream'\n    value += (encodedByte AND 127) * multiplier\n    multiplier *= 128\n    if (multiplier > 128*128*128)\n        throw Error(Malformed Remaining Length)\nwhile ((encodedByte AND 128) != 0)\n```\n### 可变报头 Variable header\n> 某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。\n### 报文标识符 Packet Identifier\n很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是`PUBLISH（QoS > 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）`\n控制报文必须包含一个非零的16位报文标识符（Packet Identifier）。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。\nQoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。\n> QoS等于0的PUBLISH报文不能包含报文标识符。\n\nPUBACK, PUBREC, PUBREL报文必须包含与最初发送的PUBLISH报文相同的报文标识符。类似地，SUBACK和UNSUBACK必须包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符。\n### payload\n> 某些MQTT控制报文在报文的最后部分包含一个有效载荷\n> 对于PUBLISH来说有效载荷就是应用消息。\n\n|控制报文|有效载荷|\n|-------|-------|\n|CONNECT    |需要|\n|CONNACK    |不需要|\n|PUBLISH    |可选|\n|PUBACK     |不需要|\n|PUBREC     |不需要|\n|PUBREL     |不需要|\n|PUBCOMP    |不需要|\n|SUBSCRIBE  |需要|\n|SUBACK     |需要|\n|UNSUBSCRIBE|需要|\n|UNSUBACK   |不需要|\n|PINGREQ    |不需要|\n|PINGRESP   |不需要|\n|DISCONNECT |不需要|\n## HTTP协议\nRSP\n### HTTP请求方法\n> HTTP协议永远都是客户端发起请求，服务器回送响应。\n\n1. GET\n    返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。\n2. PUT\n    向指定资源位置上传其最新内容。\n3. POST\n    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。\n4. HEAD\n    向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。\n5. DELETE\n    请求服务器删除Request-URI所标识的资源。\n6. TRACE\n    回显服务器收到的请求，主要用于测试或诊断。\n7. CONNECT\n    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器\n8. OPTIONS\n    返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。\n\n### HTTP 状态码\n#### 1** 请求收到，继续处理\n100——客户必须继续发出请求\n101——客户要求服务器根据请求转换HTTP协议版本\n#### 2** 操作成功收到，分析、接受\n200——交易成功\n201——提示知道新文件的URL\n202——接受和处理、但处理未完成\n203——返回信息不确定或不完整\n204——请求收到，但返回信息为空\n205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n206——服务器已经完成了部分用户的GET请求\n#### 3** 完成此请求必须进一步处理\n300——请求的资源可在多处得到\n301——删除请求数据\n302——在其他地址发现了请求数据\n303——建议客户访问其他URL或访问方式\n304——客户端已经执行了GET，但文件未变化\n305——请求的资源必须从服务器指定的地址得到\n306——前一版本HTTP中使用的代码，现行版本中不再使用\n307——申明请求的资源临时性删除\n#### 4** 请求包含一个错误语法或不能完成\n400——错误请求，如语法错误\n401——未授权\n　　HTTP 401.1 - 未授权：登录失败\n　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n　　HTTP 401.3 - ACL 禁止访问资源\n　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n402——保留有效ChargeTo头响应\n403——禁止访问\n　　HTTP 403.1 禁止访问：禁止可执行访问\n　　HTTP 403.2 - 禁止访问：禁止读访问\n　　HTTP 403.3 - 禁止访问：禁止写访问\n　　HTTP 403.4 - 禁止访问：要求 SSL\n　　HTTP 403.5 - 禁止访问：要求 SSL 128\n　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n　　HTTP 403.7 - 禁止访问：要求客户证书\n　　HTTP 403.8 - 禁止访问：禁止站点访问\n　　HTTP 403.9 - 禁止访问：连接的用户过多\n　　HTTP 403.10 - 禁止访问：配置无效\n　　HTTP 403.11 - 禁止访问：密码更改\n　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n　　HTTP 403.15 - 禁止访问：客户访问许可过多\n　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n404——没有发现文件、查询或URl\n405——用户在Request-Line字段定义的方法不允许\n406——根据用户发送的Accept拖，请求资源不可访问\n407——类似401，用户必须首先在代理服务器上得到授权\n408——客户端没有在用户指定的饿时间内完成请求\n409——对当前资源状态，请求不能完成\n410——服务器上不再有此资源且无进一步的参考地址\n411——服务器拒绝用户定义的Content-Length属性请求\n412——一个或多个请求头字段在当前请求中错误\n413——请求的资源大于服务器允许的大小\n414——请求的资源URL长于服务器允许的长度\n415——请求资源不支持请求项目格式\n416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n#### 5** 服务器执行一个完全有效请求失败\n　　HTTP 500 - 内部服务器错误\n　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n　　HTTP 500-11 服务器关闭\n　　HTTP 500-12 应用程序重新启动\n　　HTTP 500-13 - 服务器太忙\n　　HTTP 500-14 - 应用程序无效\n　　HTTP 500-15 - 不允许请求 global.asa\nError 501 - 未实现\n　　HTTP 502 - 网关错误\n\n### 长连接 短连接\nHTTP 1.0 使用短连接\nHTTP 1.1版本默认使用长连接\n\n### HTTP 请求消息格式\n请求行\n通用信息头|请求头|实体头\nCRLF(回车换行)\n\n比如：\n\n```c\nGET /hello.htm HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nIf-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT\nIf-None-Match: W/\"158-1192587355000\"\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nHost: 192.168.2.162:8080\nConnection: Keep-Alive\n```\n### HTTP 响应消息格式\n状态行\n\n通用信息头|响应头|实体头\n\nCRLF\n\n```c\nHTTP/1.1 200 OK\nETag: W/\"158-1192590101000\"\nLast-Modified: Wed, 17 Oct 2007 03:01:41 GMT\nContent-Type: text/html\nContent-Length: 158\nDate: Wed, 17 Oct 2007 03:01:59 GMT\nServer: Apache-Coyote/1.1\n```\n\n### HTTP post发送文件\n使用post方法发送文件内容\n\n### HTTP用户名密码机制\n使用cookie的方式：\n登录成功后用javascript调用cookie的相关接口，创建一个浏览器上的全局变量，变量名和值由你自己约定，然后每个页面载入时检查cookie是否存在，其值是否为你默认的那个值，如果不是的话就跳转到登录页面。\n### HTTPS的通信过程\n![https通讯过程](res/https通讯过程.png)\n\n### HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法\n* 非对称加密：\n    DES 秘钥长度为56bit\n    AES 秘钥长度支持128 196 256\n* 非对称加密：\n    DSA 用于数字签名和认证中。和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多，DSA只能与SHA-1一起使用，而RSA可以与任何摘要算法一起使用。DSA主要依赖于整数有限域离散对数难题。\n* HASH算法：\n    MD5 SHA1 SHA256\n> DSA 用于签名，而 RSA 可用于签名和加密。\n\n### 数字签名和数字证书\n\n#### 数字签名\n> 服务器把发送内容用hash算法生成摘要（就是校验码），然后用私钥加密这个摘要，就是数字签名。\n#### 数字证书\n> 证书中心把服务器的公钥和一些其他的必要信息通过证书中心的私钥加密生成一个证书，服务器每次把数字签名，内容，数字证书一起发送给客户端，客户端用证书中心的公钥验证数字证书是不是可信任的就可以了。\n\n### websocket\nWebSocket协议支持客户端与远程主机之间进行全双工通信。\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,比如：\n```sh\nws://example.com:80/some/path`\n```\n#### websocket握手协议\n* 浏览器请求\n```\nGET /webfin/websocket/ HTTP/1.1\nHost: localhost\n　　Upgrade: websocket\nConnection: Upgrade\n　　Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==\n　　Origin: http://服务器地址\n　　Sec-WebSocket-Version: 13\n```\n\n> WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中，\n`Upgrade: websocket`\n`Connection: Upgrade`\n表示希望将http协议升级到Websocket协议。\n`Sec-WebSocket-Key`是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。\n\n* 服务器回应\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=\n```\n> 服务器返回\n`Upgrade: websocket`\n`Connection: Upgrade`\n告诉浏览器即将升级的是Websocket协议\n#### HTML5 Web Socket API\n\n* 创建对象\n```js\nvar ws = new WebSocket(url,name);\n// url为WebSocket服务器的地址，name为发起握手的协议名称，为可选择项。\n```\n* 发送文本消息\n```js\nws.send(msg);\n// msg为文本消息，对于其他类型的可以通过二进制形式发送。\n```\n* 接收消息\n```js\nws.onmessage = (function(){...})();\n```\n* 错误处理\n```js\nws.onerror = (function(){...})();\n```\n* 关闭连接\n```js\nws.close();\n```\n### coap\n\nHTTP 与 COAP协议都是通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。 \n两者之间明显的区别在于HTTP是通过文本描述方式描述协议包内容，协议包里面会包含一些空格符，换行符等,协议包可读性很强。\n而COAP是通过定义二进制各位段功能来描述协议包内容。 因此COAP协议包大小更小，更紧凑。COAP协议最小的协议包只有4B。 协议包需要经过解析后才能知道里面具体内容\n\n#### coap 特点\n* 二进制通讯\n* 对云端设备资源操作都是通过请求与响应机制来完成，类似HTTP，设备端可通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。\n* 协议包轻量级，最小长度仅为4B。\n* 支持可靠传输，数据重传，块传输。 确保数据可靠到达。\n* 支持IP多播, 即可以同时向多个设备发送请求\n* 非长连接通信，适用于低功耗物联网场景\n\n#### 协议结构\n> coap基于UDP之上\n\nUDP--->Messages--->request/response--->payload\n\n### nb-iot\n\n### freertos\n\n### alios-things\n\n### meos\n","source":"_posts/tcpip协议栈.md","raw":"---\ntitle: 嵌入式笔记：tcpip协议栈\n---\n嵌入式笔记：tcpip协议栈\n\n# 目录\n* [tcpip模型](#tcpip模型)\n* [以太网协议](#以太网协议)\n* [ARP地址解析协议](#ARP地址解析协议)\n* [TCP协议](#TCP协议)\n\n## tcpip模型\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>OSI模型</td>\n      <td>linux tcpip模型</td>\n      <td>常用协议</td>\n      <td>网络设备</td>\n   </tr>\n   <tr>\n      <td>网络层</td>\n      <td rowspan=\"3\">网络层</td>\n      <td rowspan=\"3\">telnet/DHCP/TFTP/FTP/MQTT/NFS/DNS/FTP/SNMP</td>\n      <td rowspan=\"3\"></td>\n   </tr>\n   <tr>\n      <td>表示层</td>\n   </tr>\n   <tr>\n      <td>会话层</td>\n   </tr>\n   <tr>\n      <td>传输层</td>\n      <td>传输层</td>\n      <td>TCP/UDP</td>\n      <td>四层交换机</td>\n   </tr>\n   <tr>\n      <td>网络层</td>\n      <td>网络层</td>\n      <td>IP/ICMP/IGMP/ARP</td>\n      <td>路由器，三层交换机</td>\n   </tr>\n   <tr>\n      <td>数据链路层</td>\n      <td rowspan=\"2\">网络接口层</td>\n      <td rowspan=\"2\">Ethernet/PPP/PPPoE</td>\n      <td>交换机（二层交换机），网桥，网卡（一半物理层，一半链路层）</td>\n   </tr>\n   <tr>\n      <td>物理层</td>\n      <td>中继器、集线器</td>\n   </tr>\n</table>\n\n## 以太网协议\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>前导码</td>\n      <td>SFD</td>\n      <td>目标地址</td>\n      <td>源地址</td>\n      <td>长度/类型</td>\n      <td>数据</td>\n      <td>CRC校验</td>\n   </tr>\n   <tr>\n      <td>7字节</td>\n      <td>1字节</td>\n      <td>6字节</td>\n      <td>6字节</td>\n      <td>2字节</td>\n      <td>46~1500字节</td>\n      <td>4字节</td>\n   </tr>\n</table>\n\n> 1. <strong>前导码和SFD：</strong> 不能算是以太网数据帧，是以太网在物理层上发送以太网数据时添加上去的。\n> 2. <strong>长度/类型：</strong> 大于1518，表示该以太网帧中的数据属于哪个上层协议（0x0800:IP数据包；0x0806:ARP数据包）\n> 3. <strong>单播地址、组播地址：</strong> 第一个字节的bit0为0代表单播地址，为1代表组播地址。\n\n## ARP地址解析协议\n\n<table style=\"text-align:center\">\n   <tr>\n      <td>以太网首部</td>\n      <td>硬件类型</td>\n      <td>协议类型</td>\n      <td>MAC地址长度</td>\n      <td>协议地址长度</td>\n      <td>OP</td>\n      <td>源MAC地址</td>\n      <td>源IP地址</td>\n      <td>目标MAC地址</td>\n      <td>目标IP地址</td>\n   </tr>\n   <tr>\n      <td>14字节</td>\n      <td>2字节</td>\n      <td>2字节</td>\n      <td>1字节</td>\n      <td>1字节</td>\n      <td>2字节</td>\n      <td>6字节</td>\n      <td>4字节</td>\n      <td>6字节</td>\n      <td>4字节</td>\n   </tr>\n</table>\n\n> 1. <strong>MAC地址长度和IP地址长度：</strong> 分别为6和4.\n> 2. <strong>OP：</strong>ARP请求（值为1）、ARP应答（值为2）。\n\n## IP地址分类\nIP地址=网络地址＋主机地址\n\n|分类|开头|第一个字节范围|总体范围|掩码地址|说明|\n|---|:---:|:----:|--------------|:---:|--|\n|A类|0    |1~126  |1.0.0.0 - 126.255.255.255|255.0.0.0|给规模特别大的网络使用|\n|B类|10   |128~191|128.0.0.0 - 191.255.255.255|255.255.0.0|给一般的中型网络|\n|C类|110  |192~223|192.0.0.0 - 223.255.255.255|255.255.255.0|给小型网络|\n|D类|1110 |224~239|224.0.0.0 - 239.255.255.255| - |用于多点广播（组播）|\n|E类|11110|240~255|240.0.0.0 - 255.255.255.255| - |用于广播地址|\n\n其他：\n> 1. 主机号全为0表示本网络本身 主机号全为1表示本网络广播地址\n> 2. 127.0.0.0 环路自检地址，表示任意主机本身\n> 3. 0.0.0.0 表示本网络的本主机\n> 4. 专用地址： A类：10.0.0.0—10.255.255.255，B类：172.16.0.0—172.31.255.255，C类：192.168.0.0—192.168.255.255。\n> 5. IP地址与子网掩码相与得到网络号\n## TCP与UDP的区别\n|TCP|UDP|\n|---|---|\n|面向连接,需要三次握手，4次挥手|不需要建立连接 |\n|无差错，不丢失，不重复，且按序到达|不保证数据可靠、按序到达|\n|面向字节流|面向报文|\n|有拥塞控制,不会使源主机的发送速率降低|没有拥塞控制|\n|连接只能是点到点|支持一对一，一对多，多对一和多对多的交互通信|\n|首部开销20字节|首部开销小，只有8个字节|\n|ftp telnet http https SMTP POP3|DNS DHCP tftp IGMP RTP|\n\n## ICMP协议\n> 1. ICMP允许主机或路由报告差错情况和提供有关异常情况\n> 2. ICMP是因特网的标准协议，属于IP层的协议。\n\n### ping包\n\n同一个局域网中： \n1. Pc1在应用层发起个目标IP位IP2的Ping请求。\n2. 传输层接到上层请求的数据，将数据分段并加上UDP报头。下传到Internet层。\n3. 网际层接收来处上层的数据后，根据ICMP协议进行封装，添加PC1的IP为源IP为和PC2IP为目标IP后封装成数据包。下传到网络接口层。\n4. 网络接口层接收数据包后，进行封装，源MAC地址为PC1的MAC地址，目标MAC地址则查询自己的ARP缓存表获取。如果PC1 arp缓存表中没有目标IP对应的MAC地址，则PC1发出一个ARP广播报文。ARP报文中源MAC地址为Pc1mac地址，源IP地址为pc1 IP，所要请求的是PC2的IP对应的mac地址。\n5. PC2收到ARP广播后，进行解封装，发现所请求的MAC地址是自己的。则PC2将PC1的mac地址写入arp缓存表中。然后向PC1发送一个 ARP应答单播。该单播消息包括目标IP为PC1ip，目标Mac为pc1mac地址，源IP为PC2的IP，源Mac为pc2的Mac。\n6. Pc1接收到PC2的arp应答报文后，将Pc2的MAC地址存入arp缓存中，并将Pc2的Mac地址作为目标地址封装到数据帧中。发给下层进行网络传输。\n7. PC2接收这个帧后，在网络接口层查看目标mac地址是否指向自己。是，PC2则将帧头去掉，向上层传输。\n8. Pc2网际层接收到这个信息包，查看包头，发现目标IP和自己匹配，则解封装，将数据向上层传输。\n9. 传输层接收来自下层的Ping请求的UDP报文，则去掉UDP报头，向应用层传送。\n10. 应用层收到ping请求后，发送一个PIng回应报文给PC1\n\n## TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\n### 三次握手\n* 第一次握手：客户机首先向服务器的TCP发送一个连接请求报文段，这个特殊的报文段不含应用层数据，其首部中同步位SYN被设置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号).\n* 第二次握手：服务器的TCP收到连接请求报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y. 确认包同样不包含应用层数据。\n* 第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的确认为ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。因为TCP提供全双工通信，因此双方任何时候都可以发送数据。\n### 四次挥手 \n* 第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文，并停止再发送数据，主动关闭TCP连接。该报文段的FIN标志位被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。\n* 第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1\n* 第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack= u+1,序号seq =w,已经发送过的数据最后一个字节加1。确认为ACK=1. (FIN = 1, ACK=1,seq = w, ack =u+1) 第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过实践等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。 (ACK=1,seq=u+1,ack=w+1)\n如下图所示：\n\n### tcp协议图解\n\n![tcp协议图解](res/tcp协议图解.jpg)\n\n## 为什么会采用三次握手，若采用二次握手可以吗？\n采用三次握手是为了防止失效的连接请求报文段再次传到服务器，因而产生错误。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。 如果只采用一次的话，客户端不知道服务端是否已经收到自己发送的数据，则会不断地发送数据。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手\n\n## 为什么四次挥手，主动方要等待２MSL后才关闭连接．\n一、保证TCP协议的全双工连接能够可靠关闭． 主要为了确保对方能受到ACK信息. 如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。所以，Client不是直接进入CLOSED，而是要保持2MSL,如果在这个时间内又收到了server的关闭请求时可以进行重传，否则说明server已经受到确认包则可以关闭.\n\n## TCP拥塞控制\n\n为了更好对TCP进行拥塞控制，因特网建议标准定义了以下四种算法：慢开始，拥塞避免，快重传，快恢复。 首先在TCP要求发送端维护两个窗口： 1） 接收窗口rwnd，接收方根据当前缓存大小锁许诺的最新窗口值。 2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。 发送窗口的上限是取这两者的最小值。 慢开始： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加1. Cwnd的大小呈指数增长。 拥塞避免算法： 当cwnd大于等于慢开始门限ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到超时事件的发生时，就将慢开始门限设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快恢复：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，cwnd设置为慢开始门限减半后的数值（与慢开始不同）。\n\n## TCP滑动窗口与回退N针协议\n\n滑动窗口： 发送方都维持一组连续的允许发送的帧的序号称为发送窗口。同时接收方也维持一组连续的允许接收的帧序号，称为接收窗口。发送窗口是用来对发送方进行流量控制，接收窗口是用来控制接收那些数据帧不可以接收那些帧。 在发送端，收到一个确认帧，发送窗口就向前滑动一个帧位置，当发送窗口没有可以发送的帧时，发送方就停止发送。直到接收方发送的确认帧使发送窗口向前移动。 在接收端，只有收到数据帧的序号落在接收窗口内才将该帧收下，否则一律丢弃。每收到一个帧后就发送回确认帧。\n后退N帧协议 发送窗口大于1，接收窗口等于1.在后退N帧中，发送方不需要收到上一帧的ACK后才能发送下一帧，而是可以连续发送帧。当接收方检测出失序信息帧后，要求发送方重发最后一个正确接收的帧之后的所有未被确认的帧。源站每发完一帧就要为该帧设置超时计时器，如果在超时时间内没有收到确认帧则进行重发。服务端会采用累积确认的方式，不是每个帧都发确认，可以连续收到好几个正确帧后发回一个确认信息。接收方因为窗口为1，所以必须按序接收数据帧，如果某个序大于当前所期望的序号时就会连续发送3个ACK确认帧，要求客户端重传失序帧。\n\n## TCP的可靠性如何保证\n\n在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。\n\n## 各种协议对应的传输层协议\n\n|Ethernet应用|IP   |ICMP |UDP  |TCP  |SCIP|\n|-----------|:---:|:---:|:---:|:---:|:---:|\n|ping       |      |     |  ●  |     |     |\n|traceroute |      |     |  ●  |  ●  |     |\n|OSPF(路由协议)|  ● |     |     |     |     |\n|RIP(路由协议) |    |     |  ●  |     |     |\n|BGP(路由协议) |    |     |     |  ●  |     |\n|BOOTP(引导协议)|   |     |  ●  |     |     |\n|DHCP       |      |  ●  |     |     |     |\n|NTP(时间协议)|     |  ●  |    |     |     |\n|TFTP(低级FTP)|    |  ●  |     |     |     |\n|SNMP(网络管理)|    |  ●  |     |     |     |\n|IGMP(组播管理)|    |  ●  |     |     |     |\n|SMTP(电子邮件)|    |     |     |  ●  |     |\n|telnet(远程登录)|  |     |     |  ●  |     |\n|SSH(安全远程登录)|  |     |     |  ●  |     |\n|FTP(文件传输)|     |     |     |  ●  |     |\n|HTTP(web)|        |     |     |  ●  |     |\n|NNTP(网络新闻)|    |     |     |  ●  |     |\n|LPR(远程打印)|     |     |     |  ●  |     |\n|DNS(域名系统)|     |     |  ●  |  ●  |     |\n|NFS(网络文件系统)|  |     |  ●  |  ●  |     |\n|Sun RPC(远程过程调用)||   |  ●  |  ●  |     |\n|DCE RPC(远程过程调用)||   |  ●  |  ●  |     |\n|IUA(ISDN)|        |     |     |     |  ●  |\n|M2UA/M3UA(SS7电话信令)|| |     |     |  ●  |\n|H.248(媒体网关控制)||     |  ●  |  ●  |  ●  |\n|H.323(IP电话)|     |     |  ●  |  ●  |  ●  |\n|H.248(IP电话)|     |     |  ●  |  ●  |  ●  |\n## MQTT协议\nhttps://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html\n### MQTT有3种网络连接方式\ntcp（1883端口） TLS（8883端口） websocket\n### 主题过滤器 Topic Filter\n订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。\n### 控制报文 MQTT Control Packet\n通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文\n名字\t值\t报文流动方向\t描述\nReserved\t0\t禁止\t保留\nCONNECT\t1\t客户端到服务端\t客户端请求连接服务端\nCONNACK\t2\t服务端到客户端\t连接报文确认\nPUBLISH\t3\t两个方向都允许\t发布消息\nPUBACK\t4\t两个方向都允许\tQoS 1消息发布收到确认\nPUBREC\t5\t两个方向都允许\t发布收到（保证交付第一步）\nPUBREL\t6\t两个方向都允许\t发布释放（保证交付第二步）\nPUBCOMP\t7\t两个方向都允许\tQoS 2消息发布完成（保证交互第三步）\nSUBSCRIBE\t8\t客户端到服务端\t客户端订阅请求\nSUBACK\t9\t服务端到客户端\t订阅请求报文确认\nUNSUBSCRIBE\t10\t客户端到服务端\t客户端取消订阅请求\nUNSUBACK\t11\t服务端到客户端\t取消订阅报文确认\nPINGREQ\t12\t客户端到服务端\t心跳请求\nPINGRESP\t13\t服务端到客户端\t心跳响应\nDISCONNECT\t14\t客户端到服务端\t客户端断开连接\nReserved\t15\t禁止\t保留\n### 大端模式\n> MQTT数据格式使用大端模式存放\n### MQTT控制报文结构\n<table>\n    <tr>\n    <td>固定报头</td>\n    <td>可变报头</td>\n    <td>payload</td>\n    </tr>\n</table>\n\n#### 固定报头\n> 总共是2-5个字节\n* 第1个字节\n\n<table style=\"text-align:center\">\n    <tr>\n    <td>7</td>\n    <td>6</td>\n    <td>5</td>\n    <td>4</td>\n    <td>3</td>\n    <td>2</td>\n    <td>1</td>\n    <td>0</td>\n    </tr>\n    <tr>\n    <td colspan=\"4\">表示控制报文类型</td>\n    <td colspan=\"4\">表示控制报文类型的标志位</td>\n    </tr>\n</table>\n\n* 第2-5字节\n    剩余长度 表示当前报文剩余部分的字节数，包括可变报头和payload的数据。\n\n#### 剩余长度\n> 剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个延续位（continuation bit）\n\n    剩余长度字段最大4个字节。\n\n|字节数|最小值|最大值|\n|:--:|--|--|\n|1|0 (0x00)|127 (0x7F)|\n|2|128 (0x80, 0x01)|16383 (0xFF, 0x7F)|\n|3|16 384 (0x80, 0x80, 0x01)|2097151 (0xFF, 0xFF, 0x7F)|\n|4|2 097 152 (0x80, 0x80, 0x80, 0x01)|268435455 (0xFF, 0xFF, 0xFF, 0x7F)|\n\n变长编码方案代码：\n```c\ndo\n    encodedByte = X MOD 128\n    X = X DIV 128\n    // if there are more data to encode, set the top bit of this byte\n    if ( X > 0 )\n        encodedByte = encodedByte OR 128\n    endif\n    'output' encodedByte\nwhile ( X > 0 )\n```\n\n变长解码方案代码：\n```c\nmultiplier = 1\nvalue = 0\ndo\n    encodedByte = 'next byte from stream'\n    value += (encodedByte AND 127) * multiplier\n    multiplier *= 128\n    if (multiplier > 128*128*128)\n        throw Error(Malformed Remaining Length)\nwhile ((encodedByte AND 128) != 0)\n```\n### 可变报头 Variable header\n> 某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。\n### 报文标识符 Packet Identifier\n很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是`PUBLISH（QoS > 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）`\n控制报文必须包含一个非零的16位报文标识符（Packet Identifier）。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。\nQoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。\n> QoS等于0的PUBLISH报文不能包含报文标识符。\n\nPUBACK, PUBREC, PUBREL报文必须包含与最初发送的PUBLISH报文相同的报文标识符。类似地，SUBACK和UNSUBACK必须包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符。\n### payload\n> 某些MQTT控制报文在报文的最后部分包含一个有效载荷\n> 对于PUBLISH来说有效载荷就是应用消息。\n\n|控制报文|有效载荷|\n|-------|-------|\n|CONNECT    |需要|\n|CONNACK    |不需要|\n|PUBLISH    |可选|\n|PUBACK     |不需要|\n|PUBREC     |不需要|\n|PUBREL     |不需要|\n|PUBCOMP    |不需要|\n|SUBSCRIBE  |需要|\n|SUBACK     |需要|\n|UNSUBSCRIBE|需要|\n|UNSUBACK   |不需要|\n|PINGREQ    |不需要|\n|PINGRESP   |不需要|\n|DISCONNECT |不需要|\n## HTTP协议\nRSP\n### HTTP请求方法\n> HTTP协议永远都是客户端发起请求，服务器回送响应。\n\n1. GET\n    返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。\n2. PUT\n    向指定资源位置上传其最新内容。\n3. POST\n    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。\n4. HEAD\n    向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。\n5. DELETE\n    请求服务器删除Request-URI所标识的资源。\n6. TRACE\n    回显服务器收到的请求，主要用于测试或诊断。\n7. CONNECT\n    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器\n8. OPTIONS\n    返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。\n\n### HTTP 状态码\n#### 1** 请求收到，继续处理\n100——客户必须继续发出请求\n101——客户要求服务器根据请求转换HTTP协议版本\n#### 2** 操作成功收到，分析、接受\n200——交易成功\n201——提示知道新文件的URL\n202——接受和处理、但处理未完成\n203——返回信息不确定或不完整\n204——请求收到，但返回信息为空\n205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n206——服务器已经完成了部分用户的GET请求\n#### 3** 完成此请求必须进一步处理\n300——请求的资源可在多处得到\n301——删除请求数据\n302——在其他地址发现了请求数据\n303——建议客户访问其他URL或访问方式\n304——客户端已经执行了GET，但文件未变化\n305——请求的资源必须从服务器指定的地址得到\n306——前一版本HTTP中使用的代码，现行版本中不再使用\n307——申明请求的资源临时性删除\n#### 4** 请求包含一个错误语法或不能完成\n400——错误请求，如语法错误\n401——未授权\n　　HTTP 401.1 - 未授权：登录失败\n　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n　　HTTP 401.3 - ACL 禁止访问资源\n　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n402——保留有效ChargeTo头响应\n403——禁止访问\n　　HTTP 403.1 禁止访问：禁止可执行访问\n　　HTTP 403.2 - 禁止访问：禁止读访问\n　　HTTP 403.3 - 禁止访问：禁止写访问\n　　HTTP 403.4 - 禁止访问：要求 SSL\n　　HTTP 403.5 - 禁止访问：要求 SSL 128\n　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n　　HTTP 403.7 - 禁止访问：要求客户证书\n　　HTTP 403.8 - 禁止访问：禁止站点访问\n　　HTTP 403.9 - 禁止访问：连接的用户过多\n　　HTTP 403.10 - 禁止访问：配置无效\n　　HTTP 403.11 - 禁止访问：密码更改\n　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n　　HTTP 403.15 - 禁止访问：客户访问许可过多\n　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n404——没有发现文件、查询或URl\n405——用户在Request-Line字段定义的方法不允许\n406——根据用户发送的Accept拖，请求资源不可访问\n407——类似401，用户必须首先在代理服务器上得到授权\n408——客户端没有在用户指定的饿时间内完成请求\n409——对当前资源状态，请求不能完成\n410——服务器上不再有此资源且无进一步的参考地址\n411——服务器拒绝用户定义的Content-Length属性请求\n412——一个或多个请求头字段在当前请求中错误\n413——请求的资源大于服务器允许的大小\n414——请求的资源URL长于服务器允许的长度\n415——请求资源不支持请求项目格式\n416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n#### 5** 服务器执行一个完全有效请求失败\n　　HTTP 500 - 内部服务器错误\n　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n　　HTTP 500-11 服务器关闭\n　　HTTP 500-12 应用程序重新启动\n　　HTTP 500-13 - 服务器太忙\n　　HTTP 500-14 - 应用程序无效\n　　HTTP 500-15 - 不允许请求 global.asa\nError 501 - 未实现\n　　HTTP 502 - 网关错误\n\n### 长连接 短连接\nHTTP 1.0 使用短连接\nHTTP 1.1版本默认使用长连接\n\n### HTTP 请求消息格式\n请求行\n通用信息头|请求头|实体头\nCRLF(回车换行)\n\n比如：\n\n```c\nGET /hello.htm HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nIf-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT\nIf-None-Match: W/\"158-1192587355000\"\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nHost: 192.168.2.162:8080\nConnection: Keep-Alive\n```\n### HTTP 响应消息格式\n状态行\n\n通用信息头|响应头|实体头\n\nCRLF\n\n```c\nHTTP/1.1 200 OK\nETag: W/\"158-1192590101000\"\nLast-Modified: Wed, 17 Oct 2007 03:01:41 GMT\nContent-Type: text/html\nContent-Length: 158\nDate: Wed, 17 Oct 2007 03:01:59 GMT\nServer: Apache-Coyote/1.1\n```\n\n### HTTP post发送文件\n使用post方法发送文件内容\n\n### HTTP用户名密码机制\n使用cookie的方式：\n登录成功后用javascript调用cookie的相关接口，创建一个浏览器上的全局变量，变量名和值由你自己约定，然后每个页面载入时检查cookie是否存在，其值是否为你默认的那个值，如果不是的话就跳转到登录页面。\n### HTTPS的通信过程\n![https通讯过程](res/https通讯过程.png)\n\n### HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法\n* 非对称加密：\n    DES 秘钥长度为56bit\n    AES 秘钥长度支持128 196 256\n* 非对称加密：\n    DSA 用于数字签名和认证中。和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多，DSA只能与SHA-1一起使用，而RSA可以与任何摘要算法一起使用。DSA主要依赖于整数有限域离散对数难题。\n* HASH算法：\n    MD5 SHA1 SHA256\n> DSA 用于签名，而 RSA 可用于签名和加密。\n\n### 数字签名和数字证书\n\n#### 数字签名\n> 服务器把发送内容用hash算法生成摘要（就是校验码），然后用私钥加密这个摘要，就是数字签名。\n#### 数字证书\n> 证书中心把服务器的公钥和一些其他的必要信息通过证书中心的私钥加密生成一个证书，服务器每次把数字签名，内容，数字证书一起发送给客户端，客户端用证书中心的公钥验证数字证书是不是可信任的就可以了。\n\n### websocket\nWebSocket协议支持客户端与远程主机之间进行全双工通信。\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,比如：\n```sh\nws://example.com:80/some/path`\n```\n#### websocket握手协议\n* 浏览器请求\n```\nGET /webfin/websocket/ HTTP/1.1\nHost: localhost\n　　Upgrade: websocket\nConnection: Upgrade\n　　Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==\n　　Origin: http://服务器地址\n　　Sec-WebSocket-Version: 13\n```\n\n> WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中，\n`Upgrade: websocket`\n`Connection: Upgrade`\n表示希望将http协议升级到Websocket协议。\n`Sec-WebSocket-Key`是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。\n\n* 服务器回应\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=\n```\n> 服务器返回\n`Upgrade: websocket`\n`Connection: Upgrade`\n告诉浏览器即将升级的是Websocket协议\n#### HTML5 Web Socket API\n\n* 创建对象\n```js\nvar ws = new WebSocket(url,name);\n// url为WebSocket服务器的地址，name为发起握手的协议名称，为可选择项。\n```\n* 发送文本消息\n```js\nws.send(msg);\n// msg为文本消息，对于其他类型的可以通过二进制形式发送。\n```\n* 接收消息\n```js\nws.onmessage = (function(){...})();\n```\n* 错误处理\n```js\nws.onerror = (function(){...})();\n```\n* 关闭连接\n```js\nws.close();\n```\n### coap\n\nHTTP 与 COAP协议都是通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。 \n两者之间明显的区别在于HTTP是通过文本描述方式描述协议包内容，协议包里面会包含一些空格符，换行符等,协议包可读性很强。\n而COAP是通过定义二进制各位段功能来描述协议包内容。 因此COAP协议包大小更小，更紧凑。COAP协议最小的协议包只有4B。 协议包需要经过解析后才能知道里面具体内容\n\n#### coap 特点\n* 二进制通讯\n* 对云端设备资源操作都是通过请求与响应机制来完成，类似HTTP，设备端可通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。\n* 协议包轻量级，最小长度仅为4B。\n* 支持可靠传输，数据重传，块传输。 确保数据可靠到达。\n* 支持IP多播, 即可以同时向多个设备发送请求\n* 非长连接通信，适用于低功耗物联网场景\n\n#### 协议结构\n> coap基于UDP之上\n\nUDP--->Messages--->request/response--->payload\n\n### nb-iot\n\n### freertos\n\n### alios-things\n\n### meos\n","slug":"tcpip协议栈","published":1,"date":"2018-02-28T01:20:58.912Z","updated":"2018-02-28T01:14:22.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjedivhbi000b9vf7k4cm2b9n","content":"<p>嵌入式笔记：tcpip协议栈</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#tcpip模型\">tcpip模型</a></li>\n<li><a href=\"#以太网协议\">以太网协议</a></li>\n<li><a href=\"#ARP地址解析协议\">ARP地址解析协议</a></li>\n<li><a href=\"#TCP协议\">TCP协议</a></li>\n</ul>\n<h2 id=\"tcpip模型\"><a href=\"#tcpip模型\" class=\"headerlink\" title=\"tcpip模型\"></a>tcpip模型</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>OSI模型</td><br>      <td>linux tcpip模型</td><br>      <td>常用协议</td><br>      <td>网络设备</td><br>   </tr><br>   <tr><br>      <td>网络层</td><br>      <td rowspan=\"3\">网络层</td><br>      <td rowspan=\"3\">telnet/DHCP/TFTP/FTP/MQTT/NFS/DNS/FTP/SNMP</td><br>      <td rowspan=\"3\"></td><br>   </tr><br>   <tr><br>      <td>表示层</td><br>   </tr><br>   <tr><br>      <td>会话层</td><br>   </tr><br>   <tr><br>      <td>传输层</td><br>      <td>传输层</td><br>      <td>TCP/UDP</td><br>      <td>四层交换机</td><br>   </tr><br>   <tr><br>      <td>网络层</td><br>      <td>网络层</td><br>      <td>IP/ICMP/IGMP/ARP</td><br>      <td>路由器，三层交换机</td><br>   </tr><br>   <tr><br>      <td>数据链路层</td><br>      <td rowspan=\"2\">网络接口层</td><br>      <td rowspan=\"2\">Ethernet/PPP/PPPoE</td><br>      <td>交换机（二层交换机），网桥，网卡（一半物理层，一半链路层）</td><br>   </tr><br>   <tr><br>      <td>物理层</td><br>      <td>中继器、集线器</td><br>   </tr><br></table>\n\n<h2 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>前导码</td><br>      <td>SFD</td><br>      <td>目标地址</td><br>      <td>源地址</td><br>      <td>长度/类型</td><br>      <td>数据</td><br>      <td>CRC校验</td><br>   </tr><br>   <tr><br>      <td>7字节</td><br>      <td>1字节</td><br>      <td>6字节</td><br>      <td>6字节</td><br>      <td>2字节</td><br>      <td>46~1500字节</td><br>      <td>4字节</td><br>   </tr><br></table>\n\n<blockquote>\n<ol>\n<li><strong>前导码和SFD：</strong> 不能算是以太网数据帧，是以太网在物理层上发送以太网数据时添加上去的。</li>\n<li><strong>长度/类型：</strong> 大于1518，表示该以太网帧中的数据属于哪个上层协议（0x0800:IP数据包；0x0806:ARP数据包）</li>\n<li><strong>单播地址、组播地址：</strong> 第一个字节的bit0为0代表单播地址，为1代表组播地址。</li>\n</ol>\n</blockquote>\n<h2 id=\"ARP地址解析协议\"><a href=\"#ARP地址解析协议\" class=\"headerlink\" title=\"ARP地址解析协议\"></a>ARP地址解析协议</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>以太网首部</td><br>      <td>硬件类型</td><br>      <td>协议类型</td><br>      <td>MAC地址长度</td><br>      <td>协议地址长度</td><br>      <td>OP</td><br>      <td>源MAC地址</td><br>      <td>源IP地址</td><br>      <td>目标MAC地址</td><br>      <td>目标IP地址</td><br>   </tr><br>   <tr><br>      <td>14字节</td><br>      <td>2字节</td><br>      <td>2字节</td><br>      <td>1字节</td><br>      <td>1字节</td><br>      <td>2字节</td><br>      <td>6字节</td><br>      <td>4字节</td><br>      <td>6字节</td><br>      <td>4字节</td><br>   </tr><br></table>\n\n<blockquote>\n<ol>\n<li><strong>MAC地址长度和IP地址长度：</strong> 分别为6和4.</li>\n<li><strong>OP：</strong>ARP请求（值为1）、ARP应答（值为2）。</li>\n</ol>\n</blockquote>\n<h2 id=\"IP地址分类\"><a href=\"#IP地址分类\" class=\"headerlink\" title=\"IP地址分类\"></a>IP地址分类</h2><p>IP地址=网络地址＋主机地址</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th style=\"text-align:center\">开头</th>\n<th style=\"text-align:center\">第一个字节范围</th>\n<th>总体范围</th>\n<th style=\"text-align:center\">掩码地址</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A类</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1~126</td>\n<td>1.0.0.0 - 126.255.255.255</td>\n<td style=\"text-align:center\">255.0.0.0</td>\n<td>给规模特别大的网络使用</td>\n</tr>\n<tr>\n<td>B类</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">128~191</td>\n<td>128.0.0.0 - 191.255.255.255</td>\n<td style=\"text-align:center\">255.255.0.0</td>\n<td>给一般的中型网络</td>\n</tr>\n<tr>\n<td>C类</td>\n<td style=\"text-align:center\">110</td>\n<td style=\"text-align:center\">192~223</td>\n<td>192.0.0.0 - 223.255.255.255</td>\n<td style=\"text-align:center\">255.255.255.0</td>\n<td>给小型网络</td>\n</tr>\n<tr>\n<td>D类</td>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">224~239</td>\n<td>224.0.0.0 - 239.255.255.255</td>\n<td style=\"text-align:center\">-</td>\n<td>用于多点广播（组播）</td>\n</tr>\n<tr>\n<td>E类</td>\n<td style=\"text-align:center\">11110</td>\n<td style=\"text-align:center\">240~255</td>\n<td>240.0.0.0 - 255.255.255.255</td>\n<td style=\"text-align:center\">-</td>\n<td>用于广播地址</td>\n</tr>\n</tbody>\n</table>\n<p>其他：</p>\n<blockquote>\n<ol>\n<li>主机号全为0表示本网络本身 主机号全为1表示本网络广播地址</li>\n<li>127.0.0.0 环路自检地址，表示任意主机本身</li>\n<li>0.0.0.0 表示本网络的本主机</li>\n<li>专用地址： A类：10.0.0.0—10.255.255.255，B类：172.16.0.0—172.31.255.255，C类：192.168.0.0—192.168.255.255。</li>\n<li>IP地址与子网掩码相与得到网络号</li>\n</ol>\n</blockquote>\n<h2 id=\"TCP与UDP的区别\"><a href=\"#TCP与UDP的区别\" class=\"headerlink\" title=\"TCP与UDP的区别\"></a>TCP与UDP的区别</h2><table>\n<thead>\n<tr>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向连接,需要三次握手，4次挥手</td>\n<td>不需要建立连接</td>\n</tr>\n<tr>\n<td>无差错，不丢失，不重复，且按序到达</td>\n<td>不保证数据可靠、按序到达</td>\n</tr>\n<tr>\n<td>面向字节流</td>\n<td>面向报文</td>\n</tr>\n<tr>\n<td>有拥塞控制,不会使源主机的发送速率降低</td>\n<td>没有拥塞控制</td>\n</tr>\n<tr>\n<td>连接只能是点到点</td>\n<td>支持一对一，一对多，多对一和多对多的交互通信</td>\n</tr>\n<tr>\n<td>首部开销20字节</td>\n<td>首部开销小，只有8个字节</td>\n</tr>\n<tr>\n<td>ftp telnet http https SMTP POP3</td>\n<td>DNS DHCP tftp IGMP RTP</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ICMP协议\"><a href=\"#ICMP协议\" class=\"headerlink\" title=\"ICMP协议\"></a>ICMP协议</h2><blockquote>\n<ol>\n<li>ICMP允许主机或路由报告差错情况和提供有关异常情况</li>\n<li>ICMP是因特网的标准协议，属于IP层的协议。</li>\n</ol>\n</blockquote>\n<h3 id=\"ping包\"><a href=\"#ping包\" class=\"headerlink\" title=\"ping包\"></a>ping包</h3><p>同一个局域网中： </p>\n<ol>\n<li>Pc1在应用层发起个目标IP位IP2的Ping请求。</li>\n<li>传输层接到上层请求的数据，将数据分段并加上UDP报头。下传到Internet层。</li>\n<li>网际层接收来处上层的数据后，根据ICMP协议进行封装，添加PC1的IP为源IP为和PC2IP为目标IP后封装成数据包。下传到网络接口层。</li>\n<li>网络接口层接收数据包后，进行封装，源MAC地址为PC1的MAC地址，目标MAC地址则查询自己的ARP缓存表获取。如果PC1 arp缓存表中没有目标IP对应的MAC地址，则PC1发出一个ARP广播报文。ARP报文中源MAC地址为Pc1mac地址，源IP地址为pc1 IP，所要请求的是PC2的IP对应的mac地址。</li>\n<li>PC2收到ARP广播后，进行解封装，发现所请求的MAC地址是自己的。则PC2将PC1的mac地址写入arp缓存表中。然后向PC1发送一个 ARP应答单播。该单播消息包括目标IP为PC1ip，目标Mac为pc1mac地址，源IP为PC2的IP，源Mac为pc2的Mac。</li>\n<li>Pc1接收到PC2的arp应答报文后，将Pc2的MAC地址存入arp缓存中，并将Pc2的Mac地址作为目标地址封装到数据帧中。发给下层进行网络传输。</li>\n<li>PC2接收这个帧后，在网络接口层查看目标mac地址是否指向自己。是，PC2则将帧头去掉，向上层传输。</li>\n<li>Pc2网际层接收到这个信息包，查看包头，发现目标IP和自己匹配，则解封装，将数据向上层传输。</li>\n<li>传输层接收来自下层的Ping请求的UDP报文，则去掉UDP报头，向应用层传送。</li>\n<li>应用层收到ping请求后，发送一个PIng回应报文给PC1</li>\n</ol>\n<h2 id=\"TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\"><a href=\"#TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\" class=\"headerlink\" title=\"TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\"></a>TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><ul>\n<li>第一次握手：客户机首先向服务器的TCP发送一个连接请求报文段，这个特殊的报文段不含应用层数据，其首部中同步位SYN被设置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号).</li>\n<li>第二次握手：服务器的TCP收到连接请求报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y. 确认包同样不包含应用层数据。</li>\n<li>第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的确认为ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。因为TCP提供全双工通信，因此双方任何时候都可以发送数据。<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3></li>\n<li>第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文，并停止再发送数据，主动关闭TCP连接。该报文段的FIN标志位被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。</li>\n<li>第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1</li>\n<li>第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack= u+1,序号seq =w,已经发送过的数据最后一个字节加1。确认为ACK=1. (FIN = 1, ACK=1,seq = w, ack =u+1) 第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过实践等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。 (ACK=1,seq=u+1,ack=w+1)<br>如下图所示：</li>\n</ul>\n<h3 id=\"tcp协议图解\"><a href=\"#tcp协议图解\" class=\"headerlink\" title=\"tcp协议图解\"></a>tcp协议图解</h3><p><img src=\"res/tcp协议图解.jpg\" alt=\"tcp协议图解\"></p>\n<h2 id=\"为什么会采用三次握手，若采用二次握手可以吗？\"><a href=\"#为什么会采用三次握手，若采用二次握手可以吗？\" class=\"headerlink\" title=\"为什么会采用三次握手，若采用二次握手可以吗？\"></a>为什么会采用三次握手，若采用二次握手可以吗？</h2><p>采用三次握手是为了防止失效的连接请求报文段再次传到服务器，因而产生错误。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。 如果只采用一次的话，客户端不知道服务端是否已经收到自己发送的数据，则会不断地发送数据。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手</p>\n<h2 id=\"为什么四次挥手，主动方要等待２MSL后才关闭连接．\"><a href=\"#为什么四次挥手，主动方要等待２MSL后才关闭连接．\" class=\"headerlink\" title=\"为什么四次挥手，主动方要等待２MSL后才关闭连接．\"></a>为什么四次挥手，主动方要等待２MSL后才关闭连接．</h2><p>一、保证TCP协议的全双工连接能够可靠关闭． 主要为了确保对方能受到ACK信息. 如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。所以，Client不是直接进入CLOSED，而是要保持2MSL,如果在这个时间内又收到了server的关闭请求时可以进行重传，否则说明server已经受到确认包则可以关闭.</p>\n<h2 id=\"TCP拥塞控制\"><a href=\"#TCP拥塞控制\" class=\"headerlink\" title=\"TCP拥塞控制\"></a>TCP拥塞控制</h2><p>为了更好对TCP进行拥塞控制，因特网建议标准定义了以下四种算法：慢开始，拥塞避免，快重传，快恢复。 首先在TCP要求发送端维护两个窗口： 1） 接收窗口rwnd，接收方根据当前缓存大小锁许诺的最新窗口值。 2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。 发送窗口的上限是取这两者的最小值。 慢开始： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加1. Cwnd的大小呈指数增长。 拥塞避免算法： 当cwnd大于等于慢开始门限ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到超时事件的发生时，就将慢开始门限设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快恢复：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，cwnd设置为慢开始门限减半后的数值（与慢开始不同）。</p>\n<h2 id=\"TCP滑动窗口与回退N针协议\"><a href=\"#TCP滑动窗口与回退N针协议\" class=\"headerlink\" title=\"TCP滑动窗口与回退N针协议\"></a>TCP滑动窗口与回退N针协议</h2><p>滑动窗口： 发送方都维持一组连续的允许发送的帧的序号称为发送窗口。同时接收方也维持一组连续的允许接收的帧序号，称为接收窗口。发送窗口是用来对发送方进行流量控制，接收窗口是用来控制接收那些数据帧不可以接收那些帧。 在发送端，收到一个确认帧，发送窗口就向前滑动一个帧位置，当发送窗口没有可以发送的帧时，发送方就停止发送。直到接收方发送的确认帧使发送窗口向前移动。 在接收端，只有收到数据帧的序号落在接收窗口内才将该帧收下，否则一律丢弃。每收到一个帧后就发送回确认帧。<br>后退N帧协议 发送窗口大于1，接收窗口等于1.在后退N帧中，发送方不需要收到上一帧的ACK后才能发送下一帧，而是可以连续发送帧。当接收方检测出失序信息帧后，要求发送方重发最后一个正确接收的帧之后的所有未被确认的帧。源站每发完一帧就要为该帧设置超时计时器，如果在超时时间内没有收到确认帧则进行重发。服务端会采用累积确认的方式，不是每个帧都发确认，可以连续收到好几个正确帧后发回一个确认信息。接收方因为窗口为1，所以必须按序接收数据帧，如果某个序大于当前所期望的序号时就会连续发送3个ACK确认帧，要求客户端重传失序帧。</p>\n<h2 id=\"TCP的可靠性如何保证\"><a href=\"#TCP的可靠性如何保证\" class=\"headerlink\" title=\"TCP的可靠性如何保证\"></a>TCP的可靠性如何保证</h2><p>在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。</p>\n<h2 id=\"各种协议对应的传输层协议\"><a href=\"#各种协议对应的传输层协议\" class=\"headerlink\" title=\"各种协议对应的传输层协议\"></a>各种协议对应的传输层协议</h2><table>\n<thead>\n<tr>\n<th>Ethernet应用</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">ICMP</th>\n<th style=\"text-align:center\">UDP</th>\n<th style=\"text-align:center\">TCP</th>\n<th style=\"text-align:center\">SCIP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ping</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>traceroute</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>OSPF(路由协议)</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>RIP(路由协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>BGP(路由协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>BOOTP(引导协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DHCP</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NTP(时间协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>TFTP(低级FTP)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SNMP(网络管理)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>IGMP(组播管理)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SMTP(电子邮件)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>telnet(远程登录)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SSH(安全远程登录)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>FTP(文件传输)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>HTTP(web)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NNTP(网络新闻)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>LPR(远程打印)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DNS(域名系统)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NFS(网络文件系统)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>Sun RPC(远程过程调用)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DCE RPC(远程过程调用)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>IUA(ISDN)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>M2UA/M3UA(SS7电话信令)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.248(媒体网关控制)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.323(IP电话)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.248(IP电话)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h2><p><a href=\"https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html\" target=\"_blank\" rel=\"noopener\">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html</a></p>\n<h3 id=\"MQTT有3种网络连接方式\"><a href=\"#MQTT有3种网络连接方式\" class=\"headerlink\" title=\"MQTT有3种网络连接方式\"></a>MQTT有3种网络连接方式</h3><p>tcp（1883端口） TLS（8883端口） websocket</p>\n<h3 id=\"主题过滤器-Topic-Filter\"><a href=\"#主题过滤器-Topic-Filter\" class=\"headerlink\" title=\"主题过滤器 Topic Filter\"></a>主题过滤器 Topic Filter</h3><p>订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。</p>\n<h3 id=\"控制报文-MQTT-Control-Packet\"><a href=\"#控制报文-MQTT-Control-Packet\" class=\"headerlink\" title=\"控制报文 MQTT Control Packet\"></a>控制报文 MQTT Control Packet</h3><p>通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文<br>名字    值    报文流动方向    描述<br>Reserved    0    禁止    保留<br>CONNECT    1    客户端到服务端    客户端请求连接服务端<br>CONNACK    2    服务端到客户端    连接报文确认<br>PUBLISH    3    两个方向都允许    发布消息<br>PUBACK    4    两个方向都允许    QoS 1消息发布收到确认<br>PUBREC    5    两个方向都允许    发布收到（保证交付第一步）<br>PUBREL    6    两个方向都允许    发布释放（保证交付第二步）<br>PUBCOMP    7    两个方向都允许    QoS 2消息发布完成（保证交互第三步）<br>SUBSCRIBE    8    客户端到服务端    客户端订阅请求<br>SUBACK    9    服务端到客户端    订阅请求报文确认<br>UNSUBSCRIBE    10    客户端到服务端    客户端取消订阅请求<br>UNSUBACK    11    服务端到客户端    取消订阅报文确认<br>PINGREQ    12    客户端到服务端    心跳请求<br>PINGRESP    13    服务端到客户端    心跳响应<br>DISCONNECT    14    客户端到服务端    客户端断开连接<br>Reserved    15    禁止    保留</p>\n<h3 id=\"大端模式\"><a href=\"#大端模式\" class=\"headerlink\" title=\"大端模式\"></a>大端模式</h3><blockquote>\n<p>MQTT数据格式使用大端模式存放</p>\n</blockquote>\n<h3 id=\"MQTT控制报文结构\"><a href=\"#MQTT控制报文结构\" class=\"headerlink\" title=\"MQTT控制报文结构\"></a>MQTT控制报文结构</h3><table><br>    <tr><br>    <td>固定报头</td><br>    <td>可变报头</td><br>    <td>payload</td><br>    </tr><br></table>\n\n<h4 id=\"固定报头\"><a href=\"#固定报头\" class=\"headerlink\" title=\"固定报头\"></a>固定报头</h4><blockquote>\n<p>总共是2-5个字节</p>\n<ul>\n<li>第1个字节</li>\n</ul>\n</blockquote>\n<table style=\"text-align:center\"><br>    <tr><br>    <td>7</td><br>    <td>6</td><br>    <td>5</td><br>    <td>4</td><br>    <td>3</td><br>    <td>2</td><br>    <td>1</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td colspan=\"4\">表示控制报文类型</td><br>    <td colspan=\"4\">表示控制报文类型的标志位</td><br>    </tr><br></table>\n\n<ul>\n<li>第2-5字节<br>  剩余长度 表示当前报文剩余部分的字节数，包括可变报头和payload的数据。</li>\n</ul>\n<h4 id=\"剩余长度\"><a href=\"#剩余长度\" class=\"headerlink\" title=\"剩余长度\"></a>剩余长度</h4><blockquote>\n<p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个延续位（continuation bit）</p>\n</blockquote>\n<pre><code>剩余长度字段最大4个字节。\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字节数</th>\n<th>最小值</th>\n<th>最大值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td>0 (0x00)</td>\n<td>127 (0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td>128 (0x80, 0x01)</td>\n<td>16383 (0xFF, 0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td>16 384 (0x80, 0x80, 0x01)</td>\n<td>2097151 (0xFF, 0xFF, 0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>\n<td>268435455 (0xFF, 0xFF, 0xFF, 0x7F)</td>\n</tr>\n</tbody>\n</table>\n<p>变长编码方案代码：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">do</span>\n    encodedByte <span class=\"token operator\">=</span> X MOD <span class=\"token number\">128</span>\n    X <span class=\"token operator\">=</span> X DIV <span class=\"token number\">128</span>\n    <span class=\"token comment\" spellcheck=\"true\">// if there are more data to encode, set the top bit of this byte</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> X <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span>\n        encodedByte <span class=\"token operator\">=</span> encodedByte OR <span class=\"token number\">128</span>\n    endif\n    <span class=\"token string\">'output'</span> encodedByte\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span> X <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>变长解码方案代码：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">multiplier <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\nvalue <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">do</span>\n    encodedByte <span class=\"token operator\">=</span> <span class=\"token string\">'next byte from stream'</span>\n    value <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>encodedByte AND <span class=\"token number\">127</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> multiplier\n    multiplier <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">128</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>multiplier <span class=\"token operator\">></span> <span class=\"token number\">128</span><span class=\"token operator\">*</span><span class=\"token number\">128</span><span class=\"token operator\">*</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span>\n        throw <span class=\"token function\">Error</span><span class=\"token punctuation\">(</span>Malformed Remaining Length<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>encodedByte AND <span class=\"token number\">128</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"可变报头-Variable-header\"><a href=\"#可变报头-Variable-header\" class=\"headerlink\" title=\"可变报头 Variable header\"></a>可变报头 Variable header</h3><blockquote>\n<p>某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。</p>\n</blockquote>\n<h3 id=\"报文标识符-Packet-Identifier\"><a href=\"#报文标识符-Packet-Identifier\" class=\"headerlink\" title=\"报文标识符 Packet Identifier\"></a>报文标识符 Packet Identifier</h3><p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是<code>PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）</code><br>控制报文必须包含一个非零的16位报文标识符（Packet Identifier）。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。<br>QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。</p>\n<blockquote>\n<p>QoS等于0的PUBLISH报文不能包含报文标识符。</p>\n</blockquote>\n<p>PUBACK, PUBREC, PUBREL报文必须包含与最初发送的PUBLISH报文相同的报文标识符。类似地，SUBACK和UNSUBACK必须包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符。</p>\n<h3 id=\"payload\"><a href=\"#payload\" class=\"headerlink\" title=\"payload\"></a>payload</h3><blockquote>\n<p>某些MQTT控制报文在报文的最后部分包含一个有效载荷<br>对于PUBLISH来说有效载荷就是应用消息。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>控制报文</th>\n<th>有效载荷</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CONNECT</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>CONNACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBLISH</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>PUBACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBREC</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBREL</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBCOMP</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>SUBSCRIBE</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>SUBACK</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>UNSUBSCRIBE</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>UNSUBACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PINGREQ</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PINGRESP</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>DISCONNECT</td>\n<td>不需要</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>RSP</p>\n<h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><blockquote>\n<p>HTTP协议永远都是客户端发起请求，服务器回送响应。</p>\n</blockquote>\n<ol>\n<li>GET<br> 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>\n<li>PUT<br> 向指定资源位置上传其最新内容。</li>\n<li>POST<br> 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li>\n<li>HEAD<br> 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li>\n<li>DELETE<br> 请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE<br> 回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT<br> HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>\n<li>OPTIONS<br> 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>\n</ol>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><h4 id=\"1-请求收到，继续处理\"><a href=\"#1-请求收到，继续处理\" class=\"headerlink\" title=\"1** 请求收到，继续处理\"></a>1** 请求收到，继续处理</h4><p>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本</p>\n<h4 id=\"2-操作成功收到，分析、接受\"><a href=\"#2-操作成功收到，分析、接受\" class=\"headerlink\" title=\"2** 操作成功收到，分析、接受\"></a>2** 操作成功收到，分析、接受</h4><p>200——交易成功<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求</p>\n<h4 id=\"3-完成此请求必须进一步处理\"><a href=\"#3-完成此请求必须进一步处理\" class=\"headerlink\" title=\"3** 完成此请求必须进一步处理\"></a>3** 完成此请求必须进一步处理</h4><p>300——请求的资源可在多处得到<br>301——删除请求数据<br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除</p>\n<h4 id=\"4-请求包含一个错误语法或不能完成\"><a href=\"#4-请求包含一个错误语法或不能完成\" class=\"headerlink\" title=\"4** 请求包含一个错误语法或不能完成\"></a>4** 请求包含一个错误语法或不能完成</h4><p>400——错误请求，如语法错误<br>401——未授权<br>　　HTTP 401.1 - 未授权：登录失败<br>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>　　HTTP 401.3 - ACL 禁止访问资源<br>　　HTTP 401.4 - 未授权：授权被筛选器拒绝<br>　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br>403——禁止访问<br>　　HTTP 403.1 禁止访问：禁止可执行访问<br>　　HTTP 403.2 - 禁止访问：禁止读访问<br>　　HTTP 403.3 - 禁止访问：禁止写访问<br>　　HTTP 403.4 - 禁止访问：要求 SSL<br>　　HTTP 403.5 - 禁止访问：要求 SSL 128<br>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>　　HTTP 403.7 - 禁止访问：要求客户证书<br>　　HTTP 403.8 - 禁止访问：禁止站点访问<br>　　HTTP 403.9 - 禁止访问：连接的用户过多<br>　　HTTP 403.10 - 禁止访问：配置无效<br>　　HTTP 403.11 - 禁止访问：密码更改<br>　　HTTP 403.12 - 禁止访问：映射器拒绝访问<br>　　HTTP 403.13 - 禁止访问：客户证书已被吊销<br>　　HTTP 403.15 - 禁止访问：客户访问许可过多<br>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br>404——没有发现文件、查询或URl<br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p>\n<h4 id=\"5-服务器执行一个完全有效请求失败\"><a href=\"#5-服务器执行一个完全有效请求失败\" class=\"headerlink\" title=\"5** 服务器执行一个完全有效请求失败\"></a>5** 服务器执行一个完全有效请求失败</h4><p>　　HTTP 500 - 内部服务器错误<br>　　HTTP 500.100 - 内部服务器错误 - ASP 错误<br>　　HTTP 500-11 服务器关闭<br>　　HTTP 500-12 应用程序重新启动<br>　　HTTP 500-13 - 服务器太忙<br>　　HTTP 500-14 - 应用程序无效<br>　　HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br>　　HTTP 502 - 网关错误</p>\n<h3 id=\"长连接-短连接\"><a href=\"#长连接-短连接\" class=\"headerlink\" title=\"长连接 短连接\"></a>长连接 短连接</h3><p>HTTP 1.0 使用短连接<br>HTTP 1.1版本默认使用长连接</p>\n<h3 id=\"HTTP-请求消息格式\"><a href=\"#HTTP-请求消息格式\" class=\"headerlink\" title=\"HTTP 请求消息格式\"></a>HTTP 请求消息格式</h3><p>请求行<br>通用信息头|请求头|实体头<br>CRLF(回车换行)</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">GET <span class=\"token operator\">/</span>hello<span class=\"token punctuation\">.</span>htm HTTP<span class=\"token operator\">/</span><span class=\"token number\">1.1</span>\nAccept<span class=\"token punctuation\">:</span> <span class=\"token operator\">*</span><span class=\"token operator\">/</span><span class=\"token operator\">*</span>\nAccept<span class=\"token operator\">-</span>Language<span class=\"token punctuation\">:</span> zh<span class=\"token operator\">-</span>cn\nAccept<span class=\"token operator\">-</span>Encoding<span class=\"token punctuation\">:</span> gzip<span class=\"token punctuation\">,</span> deflate\nIf<span class=\"token operator\">-</span>Modified<span class=\"token operator\">-</span>Since<span class=\"token punctuation\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">17</span> Oct <span class=\"token number\">2007</span> <span class=\"token number\">02</span><span class=\"token punctuation\">:</span><span class=\"token number\">15</span><span class=\"token punctuation\">:</span><span class=\"token number\">55</span> GMT\nIf<span class=\"token operator\">-</span>None<span class=\"token operator\">-</span>Match<span class=\"token punctuation\">:</span> W<span class=\"token operator\">/</span><span class=\"token string\">\"158-1192587355000\"</span>\nUser<span class=\"token operator\">-</span>Agent<span class=\"token punctuation\">:</span> Mozilla<span class=\"token operator\">/</span><span class=\"token number\">4</span><span class=\"token punctuation\">.</span><span class=\"token function\">0</span> <span class=\"token punctuation\">(</span>compatible<span class=\"token punctuation\">;</span> MSIE <span class=\"token number\">6.0</span><span class=\"token punctuation\">;</span> Windows NT <span class=\"token number\">5.1</span><span class=\"token punctuation\">;</span> SV1<span class=\"token punctuation\">)</span>\nHost<span class=\"token punctuation\">:</span> <span class=\"token number\">192.168</span><span class=\"token punctuation\">.</span><span class=\"token number\">2.162</span><span class=\"token punctuation\">:</span><span class=\"token number\">8080</span>\nConnection<span class=\"token punctuation\">:</span> Keep<span class=\"token operator\">-</span>Alive\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"HTTP-响应消息格式\"><a href=\"#HTTP-响应消息格式\" class=\"headerlink\" title=\"HTTP 响应消息格式\"></a>HTTP 响应消息格式</h3><p>状态行</p>\n<p>通用信息头|响应头|实体头</p>\n<p>CRLF</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">HTTP<span class=\"token operator\">/</span><span class=\"token number\">1.1</span> <span class=\"token number\">200</span> OK\nETag<span class=\"token punctuation\">:</span> W<span class=\"token operator\">/</span><span class=\"token string\">\"158-1192590101000\"</span>\nLast<span class=\"token operator\">-</span>Modified<span class=\"token punctuation\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">17</span> Oct <span class=\"token number\">2007</span> <span class=\"token number\">03</span><span class=\"token punctuation\">:</span><span class=\"token number\">01</span><span class=\"token punctuation\">:</span><span class=\"token number\">41</span> GMT\nContent<span class=\"token operator\">-</span>Type<span class=\"token punctuation\">:</span> text<span class=\"token operator\">/</span>html\nContent<span class=\"token operator\">-</span>Length<span class=\"token punctuation\">:</span> <span class=\"token number\">158</span>\nDate<span class=\"token punctuation\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">17</span> Oct <span class=\"token number\">2007</span> <span class=\"token number\">03</span><span class=\"token punctuation\">:</span><span class=\"token number\">01</span><span class=\"token punctuation\">:</span><span class=\"token number\">59</span> GMT\nServer<span class=\"token punctuation\">:</span> Apache<span class=\"token operator\">-</span>Coyote<span class=\"token operator\">/</span><span class=\"token number\">1.1</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"HTTP-post发送文件\"><a href=\"#HTTP-post发送文件\" class=\"headerlink\" title=\"HTTP post发送文件\"></a>HTTP post发送文件</h3><p>使用post方法发送文件内容</p>\n<h3 id=\"HTTP用户名密码机制\"><a href=\"#HTTP用户名密码机制\" class=\"headerlink\" title=\"HTTP用户名密码机制\"></a>HTTP用户名密码机制</h3><p>使用cookie的方式：<br>登录成功后用javascript调用cookie的相关接口，创建一个浏览器上的全局变量，变量名和值由你自己约定，然后每个页面载入时检查cookie是否存在，其值是否为你默认的那个值，如果不是的话就跳转到登录页面。</p>\n<h3 id=\"HTTPS的通信过程\"><a href=\"#HTTPS的通信过程\" class=\"headerlink\" title=\"HTTPS的通信过程\"></a>HTTPS的通信过程</h3><p><img src=\"res/https通讯过程.png\" alt=\"https通讯过程\"></p>\n<h3 id=\"HTTPS、SSH-公钥、秘钥、对称加密、非对称加密、hash算法\"><a href=\"#HTTPS、SSH-公钥、秘钥、对称加密、非对称加密、hash算法\" class=\"headerlink\" title=\"HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法\"></a>HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法</h3><ul>\n<li>非对称加密：<br>  DES 秘钥长度为56bit<br>  AES 秘钥长度支持128 196 256</li>\n<li>非对称加密：<br>  DSA 用于数字签名和认证中。和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多，DSA只能与SHA-1一起使用，而RSA可以与任何摘要算法一起使用。DSA主要依赖于整数有限域离散对数难题。</li>\n<li>HASH算法：<br>  MD5 SHA1 SHA256<blockquote>\n<p>DSA 用于签名，而 RSA 可用于签名和加密。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"数字签名和数字证书\"><a href=\"#数字签名和数字证书\" class=\"headerlink\" title=\"数字签名和数字证书\"></a>数字签名和数字证书</h3><h4 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h4><blockquote>\n<p>服务器把发送内容用hash算法生成摘要（就是校验码），然后用私钥加密这个摘要，就是数字签名。</p>\n</blockquote>\n<h4 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h4><blockquote>\n<p>证书中心把服务器的公钥和一些其他的必要信息通过证书中心的私钥加密生成一个证书，服务器每次把数字签名，内容，数字证书一起发送给客户端，客户端用证书中心的公钥验证数字证书是不是可信任的就可以了。</p>\n</blockquote>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p>WebSocket协议支持客户端与远程主机之间进行全双工通信。<br>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,比如：</p>\n<pre class=\"line-numbers language-sh\"><code class=\"language-sh\">ws://example.com:80/some/path`\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"websocket握手协议\"><a href=\"#websocket握手协议\" class=\"headerlink\" title=\"websocket握手协议\"></a>websocket握手协议</h4><ul>\n<li>浏览器请求<pre><code>GET /webfin/websocket/ HTTP/1.1\nHost: localhost\n　　Upgrade: websocket\nConnection: Upgrade\n　　Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==\n　　Origin: http://服务器地址\n　　Sec-WebSocket-Version: 13\n</code></pre></li>\n</ul>\n<blockquote>\n<p>WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中，<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code><br>表示希望将http协议升级到Websocket协议。<br><code>Sec-WebSocket-Key</code>是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。</p>\n</blockquote>\n<ul>\n<li><p>服务器回应</p>\n<pre><code>HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=\n</code></pre><blockquote>\n<p>服务器返回<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code><br>告诉浏览器即将升级的是Websocket协议</p>\n</blockquote>\n<h4 id=\"HTML5-Web-Socket-API\"><a href=\"#HTML5-Web-Socket-API\" class=\"headerlink\" title=\"HTML5 Web Socket API\"></a>HTML5 Web Socket API</h4></li>\n<li><p>创建对象</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> ws <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebSocket</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// url为WebSocket服务器的地址，name为发起握手的协议名称，为可选择项。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>发送文本消息<pre class=\"line-numbers language-js\"><code class=\"language-js\">ws<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// msg为文本消息，对于其他类型的可以通过二进制形式发送。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>接收消息<pre class=\"line-numbers language-js\"><code class=\"language-js\">ws<span class=\"token punctuation\">.</span>onmessage <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>错误处理<pre class=\"line-numbers language-js\"><code class=\"language-js\">ws<span class=\"token punctuation\">.</span>onerror <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>关闭连接<pre class=\"line-numbers language-js\"><code class=\"language-js\">ws<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"coap\"><a href=\"#coap\" class=\"headerlink\" title=\"coap\"></a>coap</h3></li>\n</ul>\n<p>HTTP 与 COAP协议都是通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。<br>两者之间明显的区别在于HTTP是通过文本描述方式描述协议包内容，协议包里面会包含一些空格符，换行符等,协议包可读性很强。<br>而COAP是通过定义二进制各位段功能来描述协议包内容。 因此COAP协议包大小更小，更紧凑。COAP协议最小的协议包只有4B。 协议包需要经过解析后才能知道里面具体内容</p>\n<h4 id=\"coap-特点\"><a href=\"#coap-特点\" class=\"headerlink\" title=\"coap 特点\"></a>coap 特点</h4><ul>\n<li>二进制通讯</li>\n<li>对云端设备资源操作都是通过请求与响应机制来完成，类似HTTP，设备端可通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。</li>\n<li>协议包轻量级，最小长度仅为4B。</li>\n<li>支持可靠传输，数据重传，块传输。 确保数据可靠到达。</li>\n<li>支持IP多播, 即可以同时向多个设备发送请求</li>\n<li>非长连接通信，适用于低功耗物联网场景</li>\n</ul>\n<h4 id=\"协议结构\"><a href=\"#协议结构\" class=\"headerlink\" title=\"协议结构\"></a>协议结构</h4><blockquote>\n<p>coap基于UDP之上</p>\n</blockquote>\n<p>UDP—&gt;Messages—&gt;request/response—&gt;payload</p>\n<h3 id=\"nb-iot\"><a href=\"#nb-iot\" class=\"headerlink\" title=\"nb-iot\"></a>nb-iot</h3><h3 id=\"freertos\"><a href=\"#freertos\" class=\"headerlink\" title=\"freertos\"></a>freertos</h3><h3 id=\"alios-things\"><a href=\"#alios-things\" class=\"headerlink\" title=\"alios-things\"></a>alios-things</h3><h3 id=\"meos\"><a href=\"#meos\" class=\"headerlink\" title=\"meos\"></a>meos</h3>","site":{"data":{}},"excerpt":"","more":"<p>嵌入式笔记：tcpip协议栈</p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\"#tcpip模型\">tcpip模型</a></li>\n<li><a href=\"#以太网协议\">以太网协议</a></li>\n<li><a href=\"#ARP地址解析协议\">ARP地址解析协议</a></li>\n<li><a href=\"#TCP协议\">TCP协议</a></li>\n</ul>\n<h2 id=\"tcpip模型\"><a href=\"#tcpip模型\" class=\"headerlink\" title=\"tcpip模型\"></a>tcpip模型</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>OSI模型</td><br>      <td>linux tcpip模型</td><br>      <td>常用协议</td><br>      <td>网络设备</td><br>   </tr><br>   <tr><br>      <td>网络层</td><br>      <td rowspan=\"3\">网络层</td><br>      <td rowspan=\"3\">telnet/DHCP/TFTP/FTP/MQTT/NFS/DNS/FTP/SNMP</td><br>      <td rowspan=\"3\"></td><br>   </tr><br>   <tr><br>      <td>表示层</td><br>   </tr><br>   <tr><br>      <td>会话层</td><br>   </tr><br>   <tr><br>      <td>传输层</td><br>      <td>传输层</td><br>      <td>TCP/UDP</td><br>      <td>四层交换机</td><br>   </tr><br>   <tr><br>      <td>网络层</td><br>      <td>网络层</td><br>      <td>IP/ICMP/IGMP/ARP</td><br>      <td>路由器，三层交换机</td><br>   </tr><br>   <tr><br>      <td>数据链路层</td><br>      <td rowspan=\"2\">网络接口层</td><br>      <td rowspan=\"2\">Ethernet/PPP/PPPoE</td><br>      <td>交换机（二层交换机），网桥，网卡（一半物理层，一半链路层）</td><br>   </tr><br>   <tr><br>      <td>物理层</td><br>      <td>中继器、集线器</td><br>   </tr><br></table>\n\n<h2 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>前导码</td><br>      <td>SFD</td><br>      <td>目标地址</td><br>      <td>源地址</td><br>      <td>长度/类型</td><br>      <td>数据</td><br>      <td>CRC校验</td><br>   </tr><br>   <tr><br>      <td>7字节</td><br>      <td>1字节</td><br>      <td>6字节</td><br>      <td>6字节</td><br>      <td>2字节</td><br>      <td>46~1500字节</td><br>      <td>4字节</td><br>   </tr><br></table>\n\n<blockquote>\n<ol>\n<li><strong>前导码和SFD：</strong> 不能算是以太网数据帧，是以太网在物理层上发送以太网数据时添加上去的。</li>\n<li><strong>长度/类型：</strong> 大于1518，表示该以太网帧中的数据属于哪个上层协议（0x0800:IP数据包；0x0806:ARP数据包）</li>\n<li><strong>单播地址、组播地址：</strong> 第一个字节的bit0为0代表单播地址，为1代表组播地址。</li>\n</ol>\n</blockquote>\n<h2 id=\"ARP地址解析协议\"><a href=\"#ARP地址解析协议\" class=\"headerlink\" title=\"ARP地址解析协议\"></a>ARP地址解析协议</h2><table style=\"text-align:center\"><br>   <tr><br>      <td>以太网首部</td><br>      <td>硬件类型</td><br>      <td>协议类型</td><br>      <td>MAC地址长度</td><br>      <td>协议地址长度</td><br>      <td>OP</td><br>      <td>源MAC地址</td><br>      <td>源IP地址</td><br>      <td>目标MAC地址</td><br>      <td>目标IP地址</td><br>   </tr><br>   <tr><br>      <td>14字节</td><br>      <td>2字节</td><br>      <td>2字节</td><br>      <td>1字节</td><br>      <td>1字节</td><br>      <td>2字节</td><br>      <td>6字节</td><br>      <td>4字节</td><br>      <td>6字节</td><br>      <td>4字节</td><br>   </tr><br></table>\n\n<blockquote>\n<ol>\n<li><strong>MAC地址长度和IP地址长度：</strong> 分别为6和4.</li>\n<li><strong>OP：</strong>ARP请求（值为1）、ARP应答（值为2）。</li>\n</ol>\n</blockquote>\n<h2 id=\"IP地址分类\"><a href=\"#IP地址分类\" class=\"headerlink\" title=\"IP地址分类\"></a>IP地址分类</h2><p>IP地址=网络地址＋主机地址</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th style=\"text-align:center\">开头</th>\n<th style=\"text-align:center\">第一个字节范围</th>\n<th>总体范围</th>\n<th style=\"text-align:center\">掩码地址</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A类</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1~126</td>\n<td>1.0.0.0 - 126.255.255.255</td>\n<td style=\"text-align:center\">255.0.0.0</td>\n<td>给规模特别大的网络使用</td>\n</tr>\n<tr>\n<td>B类</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">128~191</td>\n<td>128.0.0.0 - 191.255.255.255</td>\n<td style=\"text-align:center\">255.255.0.0</td>\n<td>给一般的中型网络</td>\n</tr>\n<tr>\n<td>C类</td>\n<td style=\"text-align:center\">110</td>\n<td style=\"text-align:center\">192~223</td>\n<td>192.0.0.0 - 223.255.255.255</td>\n<td style=\"text-align:center\">255.255.255.0</td>\n<td>给小型网络</td>\n</tr>\n<tr>\n<td>D类</td>\n<td style=\"text-align:center\">1110</td>\n<td style=\"text-align:center\">224~239</td>\n<td>224.0.0.0 - 239.255.255.255</td>\n<td style=\"text-align:center\">-</td>\n<td>用于多点广播（组播）</td>\n</tr>\n<tr>\n<td>E类</td>\n<td style=\"text-align:center\">11110</td>\n<td style=\"text-align:center\">240~255</td>\n<td>240.0.0.0 - 255.255.255.255</td>\n<td style=\"text-align:center\">-</td>\n<td>用于广播地址</td>\n</tr>\n</tbody>\n</table>\n<p>其他：</p>\n<blockquote>\n<ol>\n<li>主机号全为0表示本网络本身 主机号全为1表示本网络广播地址</li>\n<li>127.0.0.0 环路自检地址，表示任意主机本身</li>\n<li>0.0.0.0 表示本网络的本主机</li>\n<li>专用地址： A类：10.0.0.0—10.255.255.255，B类：172.16.0.0—172.31.255.255，C类：192.168.0.0—192.168.255.255。</li>\n<li>IP地址与子网掩码相与得到网络号</li>\n</ol>\n</blockquote>\n<h2 id=\"TCP与UDP的区别\"><a href=\"#TCP与UDP的区别\" class=\"headerlink\" title=\"TCP与UDP的区别\"></a>TCP与UDP的区别</h2><table>\n<thead>\n<tr>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向连接,需要三次握手，4次挥手</td>\n<td>不需要建立连接</td>\n</tr>\n<tr>\n<td>无差错，不丢失，不重复，且按序到达</td>\n<td>不保证数据可靠、按序到达</td>\n</tr>\n<tr>\n<td>面向字节流</td>\n<td>面向报文</td>\n</tr>\n<tr>\n<td>有拥塞控制,不会使源主机的发送速率降低</td>\n<td>没有拥塞控制</td>\n</tr>\n<tr>\n<td>连接只能是点到点</td>\n<td>支持一对一，一对多，多对一和多对多的交互通信</td>\n</tr>\n<tr>\n<td>首部开销20字节</td>\n<td>首部开销小，只有8个字节</td>\n</tr>\n<tr>\n<td>ftp telnet http https SMTP POP3</td>\n<td>DNS DHCP tftp IGMP RTP</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ICMP协议\"><a href=\"#ICMP协议\" class=\"headerlink\" title=\"ICMP协议\"></a>ICMP协议</h2><blockquote>\n<ol>\n<li>ICMP允许主机或路由报告差错情况和提供有关异常情况</li>\n<li>ICMP是因特网的标准协议，属于IP层的协议。</li>\n</ol>\n</blockquote>\n<h3 id=\"ping包\"><a href=\"#ping包\" class=\"headerlink\" title=\"ping包\"></a>ping包</h3><p>同一个局域网中： </p>\n<ol>\n<li>Pc1在应用层发起个目标IP位IP2的Ping请求。</li>\n<li>传输层接到上层请求的数据，将数据分段并加上UDP报头。下传到Internet层。</li>\n<li>网际层接收来处上层的数据后，根据ICMP协议进行封装，添加PC1的IP为源IP为和PC2IP为目标IP后封装成数据包。下传到网络接口层。</li>\n<li>网络接口层接收数据包后，进行封装，源MAC地址为PC1的MAC地址，目标MAC地址则查询自己的ARP缓存表获取。如果PC1 arp缓存表中没有目标IP对应的MAC地址，则PC1发出一个ARP广播报文。ARP报文中源MAC地址为Pc1mac地址，源IP地址为pc1 IP，所要请求的是PC2的IP对应的mac地址。</li>\n<li>PC2收到ARP广播后，进行解封装，发现所请求的MAC地址是自己的。则PC2将PC1的mac地址写入arp缓存表中。然后向PC1发送一个 ARP应答单播。该单播消息包括目标IP为PC1ip，目标Mac为pc1mac地址，源IP为PC2的IP，源Mac为pc2的Mac。</li>\n<li>Pc1接收到PC2的arp应答报文后，将Pc2的MAC地址存入arp缓存中，并将Pc2的Mac地址作为目标地址封装到数据帧中。发给下层进行网络传输。</li>\n<li>PC2接收这个帧后，在网络接口层查看目标mac地址是否指向自己。是，PC2则将帧头去掉，向上层传输。</li>\n<li>Pc2网际层接收到这个信息包，查看包头，发现目标IP和自己匹配，则解封装，将数据向上层传输。</li>\n<li>传输层接收来自下层的Ping请求的UDP报文，则去掉UDP报头，向应用层传送。</li>\n<li>应用层收到ping请求后，发送一个PIng回应报文给PC1</li>\n</ol>\n<h2 id=\"TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\"><a href=\"#TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\" class=\"headerlink\" title=\"TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用\"></a>TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用</h2><h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><ul>\n<li>第一次握手：客户机首先向服务器的TCP发送一个连接请求报文段，这个特殊的报文段不含应用层数据，其首部中同步位SYN被设置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号).</li>\n<li>第二次握手：服务器的TCP收到连接请求报文段后，如果同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y. 确认包同样不包含应用层数据。</li>\n<li>第三次握手：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的确认为ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。 理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。因为TCP提供全双工通信，因此双方任何时候都可以发送数据。<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3></li>\n<li>第一次挥手：客户机打算关闭连接，就向其TCP发送一个连接释放报文，并停止再发送数据，主动关闭TCP连接。该报文段的FIN标志位被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。</li>\n<li>第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1</li>\n<li>第三次挥手：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack= u+1,序号seq =w,已经发送过的数据最后一个字节加1。确认为ACK=1. (FIN = 1, ACK=1,seq = w, ack =u+1) 第四次挥手：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过实践等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。 (ACK=1,seq=u+1,ack=w+1)<br>如下图所示：</li>\n</ul>\n<h3 id=\"tcp协议图解\"><a href=\"#tcp协议图解\" class=\"headerlink\" title=\"tcp协议图解\"></a>tcp协议图解</h3><p><img src=\"res/tcp协议图解.jpg\" alt=\"tcp协议图解\"></p>\n<h2 id=\"为什么会采用三次握手，若采用二次握手可以吗？\"><a href=\"#为什么会采用三次握手，若采用二次握手可以吗？\" class=\"headerlink\" title=\"为什么会采用三次握手，若采用二次握手可以吗？\"></a>为什么会采用三次握手，若采用二次握手可以吗？</h2><p>采用三次握手是为了防止失效的连接请求报文段再次传到服务器，因而产生错误。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。 如果只采用一次的话，客户端不知道服务端是否已经收到自己发送的数据，则会不断地发送数据。为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手</p>\n<h2 id=\"为什么四次挥手，主动方要等待２MSL后才关闭连接．\"><a href=\"#为什么四次挥手，主动方要等待２MSL后才关闭连接．\" class=\"headerlink\" title=\"为什么四次挥手，主动方要等待２MSL后才关闭连接．\"></a>为什么四次挥手，主动方要等待２MSL后才关闭连接．</h2><p>一、保证TCP协议的全双工连接能够可靠关闭． 主要为了确保对方能受到ACK信息. 如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。所以，Client不是直接进入CLOSED，而是要保持2MSL,如果在这个时间内又收到了server的关闭请求时可以进行重传，否则说明server已经受到确认包则可以关闭.</p>\n<h2 id=\"TCP拥塞控制\"><a href=\"#TCP拥塞控制\" class=\"headerlink\" title=\"TCP拥塞控制\"></a>TCP拥塞控制</h2><p>为了更好对TCP进行拥塞控制，因特网建议标准定义了以下四种算法：慢开始，拥塞避免，快重传，快恢复。 首先在TCP要求发送端维护两个窗口： 1） 接收窗口rwnd，接收方根据当前缓存大小锁许诺的最新窗口值。 2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。 发送窗口的上限是取这两者的最小值。 慢开始： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加1. Cwnd的大小呈指数增长。 拥塞避免算法： 当cwnd大于等于慢开始门限ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到超时事件的发生时，就将慢开始门限设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。 快重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快恢复：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，cwnd设置为慢开始门限减半后的数值（与慢开始不同）。</p>\n<h2 id=\"TCP滑动窗口与回退N针协议\"><a href=\"#TCP滑动窗口与回退N针协议\" class=\"headerlink\" title=\"TCP滑动窗口与回退N针协议\"></a>TCP滑动窗口与回退N针协议</h2><p>滑动窗口： 发送方都维持一组连续的允许发送的帧的序号称为发送窗口。同时接收方也维持一组连续的允许接收的帧序号，称为接收窗口。发送窗口是用来对发送方进行流量控制，接收窗口是用来控制接收那些数据帧不可以接收那些帧。 在发送端，收到一个确认帧，发送窗口就向前滑动一个帧位置，当发送窗口没有可以发送的帧时，发送方就停止发送。直到接收方发送的确认帧使发送窗口向前移动。 在接收端，只有收到数据帧的序号落在接收窗口内才将该帧收下，否则一律丢弃。每收到一个帧后就发送回确认帧。<br>后退N帧协议 发送窗口大于1，接收窗口等于1.在后退N帧中，发送方不需要收到上一帧的ACK后才能发送下一帧，而是可以连续发送帧。当接收方检测出失序信息帧后，要求发送方重发最后一个正确接收的帧之后的所有未被确认的帧。源站每发完一帧就要为该帧设置超时计时器，如果在超时时间内没有收到确认帧则进行重发。服务端会采用累积确认的方式，不是每个帧都发确认，可以连续收到好几个正确帧后发回一个确认信息。接收方因为窗口为1，所以必须按序接收数据帧，如果某个序大于当前所期望的序号时就会连续发送3个ACK确认帧，要求客户端重传失序帧。</p>\n<h2 id=\"TCP的可靠性如何保证\"><a href=\"#TCP的可靠性如何保证\" class=\"headerlink\" title=\"TCP的可靠性如何保证\"></a>TCP的可靠性如何保证</h2><p>在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。</p>\n<h2 id=\"各种协议对应的传输层协议\"><a href=\"#各种协议对应的传输层协议\" class=\"headerlink\" title=\"各种协议对应的传输层协议\"></a>各种协议对应的传输层协议</h2><table>\n<thead>\n<tr>\n<th>Ethernet应用</th>\n<th style=\"text-align:center\">IP</th>\n<th style=\"text-align:center\">ICMP</th>\n<th style=\"text-align:center\">UDP</th>\n<th style=\"text-align:center\">TCP</th>\n<th style=\"text-align:center\">SCIP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ping</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>traceroute</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>OSPF(路由协议)</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>RIP(路由协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>BGP(路由协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>BOOTP(引导协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DHCP</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NTP(时间协议)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>TFTP(低级FTP)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SNMP(网络管理)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>IGMP(组播管理)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SMTP(电子邮件)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>telnet(远程登录)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>SSH(安全远程登录)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>FTP(文件传输)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>HTTP(web)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NNTP(网络新闻)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>LPR(远程打印)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DNS(域名系统)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>NFS(网络文件系统)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>Sun RPC(远程过程调用)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>DCE RPC(远程过程调用)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td>IUA(ISDN)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>M2UA/M3UA(SS7电话信令)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.248(媒体网关控制)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.323(IP电话)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n<tr>\n<td>H.248(IP电话)</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n<td style=\"text-align:center\">●</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"MQTT协议\"><a href=\"#MQTT协议\" class=\"headerlink\" title=\"MQTT协议\"></a>MQTT协议</h2><p><a href=\"https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html\" target=\"_blank\" rel=\"noopener\">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html</a></p>\n<h3 id=\"MQTT有3种网络连接方式\"><a href=\"#MQTT有3种网络连接方式\" class=\"headerlink\" title=\"MQTT有3种网络连接方式\"></a>MQTT有3种网络连接方式</h3><p>tcp（1883端口） TLS（8883端口） websocket</p>\n<h3 id=\"主题过滤器-Topic-Filter\"><a href=\"#主题过滤器-Topic-Filter\" class=\"headerlink\" title=\"主题过滤器 Topic Filter\"></a>主题过滤器 Topic Filter</h3><p>订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。</p>\n<h3 id=\"控制报文-MQTT-Control-Packet\"><a href=\"#控制报文-MQTT-Control-Packet\" class=\"headerlink\" title=\"控制报文 MQTT Control Packet\"></a>控制报文 MQTT Control Packet</h3><p>通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文<br>名字    值    报文流动方向    描述<br>Reserved    0    禁止    保留<br>CONNECT    1    客户端到服务端    客户端请求连接服务端<br>CONNACK    2    服务端到客户端    连接报文确认<br>PUBLISH    3    两个方向都允许    发布消息<br>PUBACK    4    两个方向都允许    QoS 1消息发布收到确认<br>PUBREC    5    两个方向都允许    发布收到（保证交付第一步）<br>PUBREL    6    两个方向都允许    发布释放（保证交付第二步）<br>PUBCOMP    7    两个方向都允许    QoS 2消息发布完成（保证交互第三步）<br>SUBSCRIBE    8    客户端到服务端    客户端订阅请求<br>SUBACK    9    服务端到客户端    订阅请求报文确认<br>UNSUBSCRIBE    10    客户端到服务端    客户端取消订阅请求<br>UNSUBACK    11    服务端到客户端    取消订阅报文确认<br>PINGREQ    12    客户端到服务端    心跳请求<br>PINGRESP    13    服务端到客户端    心跳响应<br>DISCONNECT    14    客户端到服务端    客户端断开连接<br>Reserved    15    禁止    保留</p>\n<h3 id=\"大端模式\"><a href=\"#大端模式\" class=\"headerlink\" title=\"大端模式\"></a>大端模式</h3><blockquote>\n<p>MQTT数据格式使用大端模式存放</p>\n</blockquote>\n<h3 id=\"MQTT控制报文结构\"><a href=\"#MQTT控制报文结构\" class=\"headerlink\" title=\"MQTT控制报文结构\"></a>MQTT控制报文结构</h3><table><br>    <tr><br>    <td>固定报头</td><br>    <td>可变报头</td><br>    <td>payload</td><br>    </tr><br></table>\n\n<h4 id=\"固定报头\"><a href=\"#固定报头\" class=\"headerlink\" title=\"固定报头\"></a>固定报头</h4><blockquote>\n<p>总共是2-5个字节</p>\n<ul>\n<li>第1个字节</li>\n</ul>\n</blockquote>\n<table style=\"text-align:center\"><br>    <tr><br>    <td>7</td><br>    <td>6</td><br>    <td>5</td><br>    <td>4</td><br>    <td>3</td><br>    <td>2</td><br>    <td>1</td><br>    <td>0</td><br>    </tr><br>    <tr><br>    <td colspan=\"4\">表示控制报文类型</td><br>    <td colspan=\"4\">表示控制报文类型的标志位</td><br>    </tr><br></table>\n\n<ul>\n<li>第2-5字节<br>  剩余长度 表示当前报文剩余部分的字节数，包括可变报头和payload的数据。</li>\n</ul>\n<h4 id=\"剩余长度\"><a href=\"#剩余长度\" class=\"headerlink\" title=\"剩余长度\"></a>剩余长度</h4><blockquote>\n<p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个延续位（continuation bit）</p>\n</blockquote>\n<pre><code>剩余长度字段最大4个字节。\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">字节数</th>\n<th>最小值</th>\n<th>最大值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td>0 (0x00)</td>\n<td>127 (0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td>128 (0x80, 0x01)</td>\n<td>16383 (0xFF, 0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td>16 384 (0x80, 0x80, 0x01)</td>\n<td>2097151 (0xFF, 0xFF, 0x7F)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td>\n<td>268435455 (0xFF, 0xFF, 0xFF, 0x7F)</td>\n</tr>\n</tbody>\n</table>\n<p>变长编码方案代码：</p>\n<pre><code class=\"c\">do\n    encodedByte = X MOD 128\n    X = X DIV 128\n    // if there are more data to encode, set the top bit of this byte\n    if ( X &gt; 0 )\n        encodedByte = encodedByte OR 128\n    endif\n    &#39;output&#39; encodedByte\nwhile ( X &gt; 0 )\n</code></pre>\n<p>变长解码方案代码：</p>\n<pre><code class=\"c\">multiplier = 1\nvalue = 0\ndo\n    encodedByte = &#39;next byte from stream&#39;\n    value += (encodedByte AND 127) * multiplier\n    multiplier *= 128\n    if (multiplier &gt; 128*128*128)\n        throw Error(Malformed Remaining Length)\nwhile ((encodedByte AND 128) != 0)\n</code></pre>\n<h3 id=\"可变报头-Variable-header\"><a href=\"#可变报头-Variable-header\" class=\"headerlink\" title=\"可变报头 Variable header\"></a>可变报头 Variable header</h3><blockquote>\n<p>某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。</p>\n</blockquote>\n<h3 id=\"报文标识符-Packet-Identifier\"><a href=\"#报文标识符-Packet-Identifier\" class=\"headerlink\" title=\"报文标识符 Packet Identifier\"></a>报文标识符 Packet Identifier</h3><p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是<code>PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）</code><br>控制报文必须包含一个非零的16位报文标识符（Packet Identifier）。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。<br>QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。</p>\n<blockquote>\n<p>QoS等于0的PUBLISH报文不能包含报文标识符。</p>\n</blockquote>\n<p>PUBACK, PUBREC, PUBREL报文必须包含与最初发送的PUBLISH报文相同的报文标识符。类似地，SUBACK和UNSUBACK必须包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符。</p>\n<h3 id=\"payload\"><a href=\"#payload\" class=\"headerlink\" title=\"payload\"></a>payload</h3><blockquote>\n<p>某些MQTT控制报文在报文的最后部分包含一个有效载荷<br>对于PUBLISH来说有效载荷就是应用消息。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>控制报文</th>\n<th>有效载荷</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CONNECT</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>CONNACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBLISH</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>PUBACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBREC</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBREL</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PUBCOMP</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>SUBSCRIBE</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>SUBACK</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>UNSUBSCRIBE</td>\n<td>需要</td>\n</tr>\n<tr>\n<td>UNSUBACK</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PINGREQ</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>PINGRESP</td>\n<td>不需要</td>\n</tr>\n<tr>\n<td>DISCONNECT</td>\n<td>不需要</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p>RSP</p>\n<h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><blockquote>\n<p>HTTP协议永远都是客户端发起请求，服务器回送响应。</p>\n</blockquote>\n<ol>\n<li>GET<br> 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>\n<li>PUT<br> 向指定资源位置上传其最新内容。</li>\n<li>POST<br> 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li>\n<li>HEAD<br> 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li>\n<li>DELETE<br> 请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE<br> 回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT<br> HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>\n<li>OPTIONS<br> 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li>\n</ol>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><h4 id=\"1-请求收到，继续处理\"><a href=\"#1-请求收到，继续处理\" class=\"headerlink\" title=\"1** 请求收到，继续处理\"></a>1** 请求收到，继续处理</h4><p>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本</p>\n<h4 id=\"2-操作成功收到，分析、接受\"><a href=\"#2-操作成功收到，分析、接受\" class=\"headerlink\" title=\"2** 操作成功收到，分析、接受\"></a>2** 操作成功收到，分析、接受</h4><p>200——交易成功<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求</p>\n<h4 id=\"3-完成此请求必须进一步处理\"><a href=\"#3-完成此请求必须进一步处理\" class=\"headerlink\" title=\"3** 完成此请求必须进一步处理\"></a>3** 完成此请求必须进一步处理</h4><p>300——请求的资源可在多处得到<br>301——删除请求数据<br>302——在其他地址发现了请求数据<br>303——建议客户访问其他URL或访问方式<br>304——客户端已经执行了GET，但文件未变化<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除</p>\n<h4 id=\"4-请求包含一个错误语法或不能完成\"><a href=\"#4-请求包含一个错误语法或不能完成\" class=\"headerlink\" title=\"4** 请求包含一个错误语法或不能完成\"></a>4** 请求包含一个错误语法或不能完成</h4><p>400——错误请求，如语法错误<br>401——未授权<br>　　HTTP 401.1 - 未授权：登录失败<br>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>　　HTTP 401.3 - ACL 禁止访问资源<br>　　HTTP 401.4 - 未授权：授权被筛选器拒绝<br>　　HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br>403——禁止访问<br>　　HTTP 403.1 禁止访问：禁止可执行访问<br>　　HTTP 403.2 - 禁止访问：禁止读访问<br>　　HTTP 403.3 - 禁止访问：禁止写访问<br>　　HTTP 403.4 - 禁止访问：要求 SSL<br>　　HTTP 403.5 - 禁止访问：要求 SSL 128<br>　　HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>　　HTTP 403.7 - 禁止访问：要求客户证书<br>　　HTTP 403.8 - 禁止访问：禁止站点访问<br>　　HTTP 403.9 - 禁止访问：连接的用户过多<br>　　HTTP 403.10 - 禁止访问：配置无效<br>　　HTTP 403.11 - 禁止访问：密码更改<br>　　HTTP 403.12 - 禁止访问：映射器拒绝访问<br>　　HTTP 403.13 - 禁止访问：客户证书已被吊销<br>　　HTTP 403.15 - 禁止访问：客户访问许可过多<br>　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>　　HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效<br>404——没有发现文件、查询或URl<br>405——用户在Request-Line字段定义的方法不允许<br>406——根据用户发送的Accept拖，请求资源不可访问<br>407——类似401，用户必须首先在代理服务器上得到授权<br>408——客户端没有在用户指定的饿时间内完成请求<br>409——对当前资源状态，请求不能完成<br>410——服务器上不再有此资源且无进一步的参考地址<br>411——服务器拒绝用户定义的Content-Length属性请求<br>412——一个或多个请求头字段在当前请求中错误<br>413——请求的资源大于服务器允许的大小<br>414——请求的资源URL长于服务器允许的长度<br>415——请求资源不支持请求项目格式<br>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p>\n<h4 id=\"5-服务器执行一个完全有效请求失败\"><a href=\"#5-服务器执行一个完全有效请求失败\" class=\"headerlink\" title=\"5** 服务器执行一个完全有效请求失败\"></a>5** 服务器执行一个完全有效请求失败</h4><p>　　HTTP 500 - 内部服务器错误<br>　　HTTP 500.100 - 内部服务器错误 - ASP 错误<br>　　HTTP 500-11 服务器关闭<br>　　HTTP 500-12 应用程序重新启动<br>　　HTTP 500-13 - 服务器太忙<br>　　HTTP 500-14 - 应用程序无效<br>　　HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br>　　HTTP 502 - 网关错误</p>\n<h3 id=\"长连接-短连接\"><a href=\"#长连接-短连接\" class=\"headerlink\" title=\"长连接 短连接\"></a>长连接 短连接</h3><p>HTTP 1.0 使用短连接<br>HTTP 1.1版本默认使用长连接</p>\n<h3 id=\"HTTP-请求消息格式\"><a href=\"#HTTP-请求消息格式\" class=\"headerlink\" title=\"HTTP 请求消息格式\"></a>HTTP 请求消息格式</h3><p>请求行<br>通用信息头|请求头|实体头<br>CRLF(回车换行)</p>\n<p>比如：</p>\n<pre><code class=\"c\">GET /hello.htm HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nIf-Modified-Since: Wed, 17 Oct 2007 02:15:55 GMT\nIf-None-Match: W/&quot;158-1192587355000&quot;\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\nHost: 192.168.2.162:8080\nConnection: Keep-Alive\n</code></pre>\n<h3 id=\"HTTP-响应消息格式\"><a href=\"#HTTP-响应消息格式\" class=\"headerlink\" title=\"HTTP 响应消息格式\"></a>HTTP 响应消息格式</h3><p>状态行</p>\n<p>通用信息头|响应头|实体头</p>\n<p>CRLF</p>\n<pre><code class=\"c\">HTTP/1.1 200 OK\nETag: W/&quot;158-1192590101000&quot;\nLast-Modified: Wed, 17 Oct 2007 03:01:41 GMT\nContent-Type: text/html\nContent-Length: 158\nDate: Wed, 17 Oct 2007 03:01:59 GMT\nServer: Apache-Coyote/1.1\n</code></pre>\n<h3 id=\"HTTP-post发送文件\"><a href=\"#HTTP-post发送文件\" class=\"headerlink\" title=\"HTTP post发送文件\"></a>HTTP post发送文件</h3><p>使用post方法发送文件内容</p>\n<h3 id=\"HTTP用户名密码机制\"><a href=\"#HTTP用户名密码机制\" class=\"headerlink\" title=\"HTTP用户名密码机制\"></a>HTTP用户名密码机制</h3><p>使用cookie的方式：<br>登录成功后用javascript调用cookie的相关接口，创建一个浏览器上的全局变量，变量名和值由你自己约定，然后每个页面载入时检查cookie是否存在，其值是否为你默认的那个值，如果不是的话就跳转到登录页面。</p>\n<h3 id=\"HTTPS的通信过程\"><a href=\"#HTTPS的通信过程\" class=\"headerlink\" title=\"HTTPS的通信过程\"></a>HTTPS的通信过程</h3><p><img src=\"res/https通讯过程.png\" alt=\"https通讯过程\"></p>\n<h3 id=\"HTTPS、SSH-公钥、秘钥、对称加密、非对称加密、hash算法\"><a href=\"#HTTPS、SSH-公钥、秘钥、对称加密、非对称加密、hash算法\" class=\"headerlink\" title=\"HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法\"></a>HTTPS、SSH 公钥、秘钥、对称加密、非对称加密、hash算法</h3><ul>\n<li>非对称加密：<br>  DES 秘钥长度为56bit<br>  AES 秘钥长度支持128 196 256</li>\n<li>非对称加密：<br>  DSA 用于数字签名和认证中。和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多，DSA只能与SHA-1一起使用，而RSA可以与任何摘要算法一起使用。DSA主要依赖于整数有限域离散对数难题。</li>\n<li>HASH算法：<br>  MD5 SHA1 SHA256<blockquote>\n<p>DSA 用于签名，而 RSA 可用于签名和加密。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"数字签名和数字证书\"><a href=\"#数字签名和数字证书\" class=\"headerlink\" title=\"数字签名和数字证书\"></a>数字签名和数字证书</h3><h4 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h4><blockquote>\n<p>服务器把发送内容用hash算法生成摘要（就是校验码），然后用私钥加密这个摘要，就是数字签名。</p>\n</blockquote>\n<h4 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h4><blockquote>\n<p>证书中心把服务器的公钥和一些其他的必要信息通过证书中心的私钥加密生成一个证书，服务器每次把数字签名，内容，数字证书一起发送给客户端，客户端用证书中心的公钥验证数字证书是不是可信任的就可以了。</p>\n</blockquote>\n<h3 id=\"websocket\"><a href=\"#websocket\" class=\"headerlink\" title=\"websocket\"></a>websocket</h3><p>WebSocket协议支持客户端与远程主机之间进行全双工通信。<br>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,比如：</p>\n<pre><code class=\"sh\">ws://example.com:80/some/path`\n</code></pre>\n<h4 id=\"websocket握手协议\"><a href=\"#websocket握手协议\" class=\"headerlink\" title=\"websocket握手协议\"></a>websocket握手协议</h4><ul>\n<li>浏览器请求<pre><code>GET /webfin/websocket/ HTTP/1.1\nHost: localhost\n　　Upgrade: websocket\nConnection: Upgrade\n　　Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==\n　　Origin: http://服务器地址\n　　Sec-WebSocket-Version: 13\n</code></pre></li>\n</ul>\n<blockquote>\n<p>WebSocket借用http请求进行握手，相比正常的http请求，多了一些内容。其中，<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code><br>表示希望将http协议升级到Websocket协议。<br><code>Sec-WebSocket-Key</code>是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。</p>\n</blockquote>\n<ul>\n<li><p>服务器回应</p>\n<pre><code>HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=\n</code></pre><blockquote>\n<p>服务器返回<br><code>Upgrade: websocket</code><br><code>Connection: Upgrade</code><br>告诉浏览器即将升级的是Websocket协议</p>\n</blockquote>\n<h4 id=\"HTML5-Web-Socket-API\"><a href=\"#HTML5-Web-Socket-API\" class=\"headerlink\" title=\"HTML5 Web Socket API\"></a>HTML5 Web Socket API</h4></li>\n<li><p>创建对象</p>\n<pre><code class=\"js\">var ws = new WebSocket(url,name);\n// url为WebSocket服务器的地址，name为发起握手的协议名称，为可选择项。\n</code></pre>\n</li>\n<li>发送文本消息<pre><code class=\"js\">ws.send(msg);\n// msg为文本消息，对于其他类型的可以通过二进制形式发送。\n</code></pre>\n</li>\n<li>接收消息<pre><code class=\"js\">ws.onmessage = (function(){...})();\n</code></pre>\n</li>\n<li>错误处理<pre><code class=\"js\">ws.onerror = (function(){...})();\n</code></pre>\n</li>\n<li>关闭连接<pre><code class=\"js\">ws.close();\n</code></pre>\n<h3 id=\"coap\"><a href=\"#coap\" class=\"headerlink\" title=\"coap\"></a>coap</h3></li>\n</ul>\n<p>HTTP 与 COAP协议都是通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。<br>两者之间明显的区别在于HTTP是通过文本描述方式描述协议包内容，协议包里面会包含一些空格符，换行符等,协议包可读性很强。<br>而COAP是通过定义二进制各位段功能来描述协议包内容。 因此COAP协议包大小更小，更紧凑。COAP协议最小的协议包只有4B。 协议包需要经过解析后才能知道里面具体内容</p>\n<h4 id=\"coap-特点\"><a href=\"#coap-特点\" class=\"headerlink\" title=\"coap 特点\"></a>coap 特点</h4><ul>\n<li>二进制通讯</li>\n<li>对云端设备资源操作都是通过请求与响应机制来完成，类似HTTP，设备端可通过4个请求方法（GET, PUT, POST, DELETE）对服务器端资源进行操作。</li>\n<li>协议包轻量级，最小长度仅为4B。</li>\n<li>支持可靠传输，数据重传，块传输。 确保数据可靠到达。</li>\n<li>支持IP多播, 即可以同时向多个设备发送请求</li>\n<li>非长连接通信，适用于低功耗物联网场景</li>\n</ul>\n<h4 id=\"协议结构\"><a href=\"#协议结构\" class=\"headerlink\" title=\"协议结构\"></a>协议结构</h4><blockquote>\n<p>coap基于UDP之上</p>\n</blockquote>\n<p>UDP—&gt;Messages—&gt;request/response—&gt;payload</p>\n<h3 id=\"nb-iot\"><a href=\"#nb-iot\" class=\"headerlink\" title=\"nb-iot\"></a>nb-iot</h3><h3 id=\"freertos\"><a href=\"#freertos\" class=\"headerlink\" title=\"freertos\"></a>freertos</h3><h3 id=\"alios-things\"><a href=\"#alios-things\" class=\"headerlink\" title=\"alios-things\"></a>alios-things</h3><h3 id=\"meos\"><a href=\"#meos\" class=\"headerlink\" title=\"meos\"></a>meos</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}