---
created: 2023-09-26T12:11
updated: 2023-10-12T13:32
---
# 一、系统概论
## 层次结构
### 加法器的实现 ALU
- 与门(A<sub>i</sub>B<sub>i</sub>)与异或门(A<sub>i</sub>⊕B<sub>i</sub>)
- 多个加法器串联，或门(A<sub>i</sub>+B<sub>i</sub>)
### 存储器的实现
- MAR, MDR （现代计算机已经改成设计在 CPU 中了）[[计算机组成原理#Cache 概述]]
- 存储基元(bit)，存储单元/存储字长(word)，字节(byte)
### 运算器的和控制器
运算器：ALU、ACC、MQ、X
控制器：CU、IR(OP,Ad)、PC；
#### 加法指令操作流程
```
(PC)->MAR
(MDR)->IR
OP(IR)->CU
Ad(IR)->MAR
(MDR)->X
(ACC)+(X)->ACC
(PC)+1->PC // (PC)；程序一般顺序执行，所以自增 1
```
### IO 设备和组织方式
计算机的五大组成部分；
冯诺依曼计算机结构以运算器为中心。

### 计算机五层虚拟机
高级语言机 M4: 将高级语言翻译为汇编语言
汇编机器 M3: 将汇编语言翻译成机器指令
操作系统 M2: 用机器语言解释操作系统
传统机器 M1: 将机器指令翻译为微程序
微程序机 M0: 将微程序翻译成微指令并执行，微指令为计算机操作中的最小单元。

## 性能指标
吞吐量、响应速度、时钟周期、主频、CPI(cycle per instruction)、MIPS、GFLOPS、TFLOPS
### 几种周期
时钟周期：由晶振频率（CPU 主频）算出，等于脉冲周期，节拍周期。
机器周期：一般取 CPU 从内存中读取一个指令字的最短时间（等于存储周期），也是 CPU 完成一个基本操作所需要的时间。如平均为两个时钟周期。
指令周期：包括多个机器周期。

# 二、数据的表示和运算
## 进制的转换
十进制与十六进制间的转换，二进制与所有进制的转换
### 十进制转为其他进制

| 整数                    | 小数 |
| :-----------------------: | :----: |
| ![[十进制转换整数.png]] | ![[十进制转换小数.png]]     |

## 定点数的加减
### 补码
#### 时钟（十二进制）
6-3=(6+(-3+12))%12，减一个数可以转成加被减数的补码（3的补码等于其模减去3等于9），补码所用的**模是这个数字位数所能表示的最大无符号数加一**，时钟的（十二进制）位数为 1 位，能表示的最大无符号数为 ⅺ，加一为 ⅻ，也即（十进制） 12
#### 二进制

##### 二进制补码为什么方便负数运算？
补码能将减法转成加法，而求负数二进制补码的过程实际上做了一种很特殊的减法，这种减法的结果恰可以通过取反得到，所以二进制补码既满足了减法运算，又有转换规则简单的优点，很适合计算机。

###### 计算机易求补码
随便找一个数10110010求补码：
100000000-10110010
= 11111111 + 1 - 10110010
= 11111111 - 10110010 + 1
= 01001101 + 1 (减法结果是直接通过取反得到的)
= 01001110

###### 补码减法转加法原理
十进制，对于二位数的减法：
50-30
-30 的 补码为 100-30 = 70
50+70=120
120%100=20

###### 补码运算中，为什么符号位参与运算却不会损坏结果？
[计算机补码运算背后的数学原理是什么？ - 知乎](https://www.zhihu.com/question/30395946)

![[求补码规则的由来.jpg]]
##### 机器数的补码表示和运算
![[机器数的补码表示.png]]
![[补码计算.png]]
##### 补码电路实现
![补码电路实现](https://iknow-pic.cdn.bcebos.com/b999a9014c086e06a95c57ad0c087bf40bd1cb64)
#### 补码性质[^1]
8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 将 -128 的补码特殊定义为 1000 0000，该补码没有对应的原码（或者说对应的原码是 -0 的原码）。
#### 补码转原码
[正数]<sub>原</sub> = [正数]<sub>补</sub>
[负数]<sub>原</sub> = [负数]<sub>补</sub> 符号位不变，数值位取反加一

## ALU
并行进位的并行加法器：4 位 ALU 74181；
组内并行组间串行的并行加法器；（多个 74181 串行连接）
组内并行组间并行的并行加法器；（多个 74181 和一个 74182 相连实现组间并行）
组成更多位数并行的加法器；（多个 74182 再连接一个 74182）

# 三、存储系统
## 存储芯片
### 构造
地址线（与字线的关系）、数据线、读写控制线（ $\overline{\text{WE}}$ ）、片选线（ $\overline{\text{CS}}$ )、
### 位扩展
两个 1k x 4 位的存储芯片各线如何连接，能拓展成一个 1k x 8位的存储芯片。
### 字扩展
两个 1k x 4 位的存储芯片各线如何连接，能拓展成一个 2k x 4位的存储芯片。增加一条地址线连接到两片选线，利用非门实现片选。
四个 1k x 4 位的存储芯片各线如何连接，能拓展成一个 4k x 4位的存储芯片。增加两条地址线连接到四片选线，利用 2 到 4 译码电路连接到四片选线实现片选。
### 字位扩展
先进行位扩展，再进行字扩展
## 存储器和 CPU 的连接
与非门、非门、负逻辑的与非门（全零出零）
### 74138 译码器
![[74138 译码器.png|268]]
在 G<sub>1</sub> 接高电平，G<sub>2A</sub> 和 G<sub>2B</sub> 接低电平，译码器打开并进行译码。
### CPU
CPU 访存控制引脚 $\overline{\text{MREQ}}$ 和读写控制引脚  $\overline{\text{WR}}$ 。
地址线、数据线

### 双端口 RAM 
#### 含义
同一个存储器有两套独立的读写控制电路，提高访问速度。
#### 双端口读写控制出现冲突的场景
1. 两个端口同时同地址写
2. 两个端口同时同地址一读一写
#### 冲突解决
置  $\overline{\text{busy}}$ 位为零代表某一端口正在访问某一位置，禁止另一端口在同一时间访问该位置。
### 多模块存储器
### 存储器层次结构划分
![[存储层次图.png]]
### Cache 概述
- 程序访问的局部性（在较短的时间内很可能再次被访问，在相邻的内存单元也很可能被访问）
- CPU 进行访存时，CPU 会先检查该地址的数据是否已经被导入 Cache 中，如果已经被导入在 Cache 中，则将这个地址**转化**成在 Cache 中的地址，从 Cache 中访问数据，否则从主存中访问数据。
![[cache概述.png]]
### 主存到 Cache 的地址映射方式
#### 直接相联映射
主存中的任意一个块只可能映射到 Cache 中的一个块；
#### 全相联映射
主存中的任意一个块可能映射到 Cache 中的任意一个块；
#### 组相联映射
主存中的块相对组间（组块）来说是直接相联映射方式，相对组内的块来说是全相联映射方式。
主存中的任意块只可能映射到 Cache 中的一个组块，但映射到组块内的具体哪个块是任意的。
### Cache 命中率和替换策略和一致性问题
命中率 = 访问 Cache 的次数 / （访问 Cache 的次数 + 访问主存的次数）
替换策略：FIFO、LRU、LFU、Random
#### 如何保证主存和 Cache 中数据的一致性？
##### 全写法
###### 策略
命中时，同时写到 Cache 和主存中；
不命中时，可只写入主存；也可写入主存后直接覆盖掉 Cache；
###### 优缺点
该方法一般会在 Cache 和主存中加一个缓冲队列以减少内存的写入开销，在 CPU 写入 Cache 的同时，也会写入缓冲队列，然后由存储控制器将缓冲队列写入内存，在写操作不频繁的情况下，效果很好，但写操作频繁会导致队列饱和而阻塞。
##### 写回法
###### 策略
如果 Cache 命中，则只更新 Cache ，不更新内存；
如果 Cache 不命中，则从主存中复制内容到 Cache 进行修改，等需要从 Cache 中换出此块时，再将其写回到主存。
###### 优缺点
该方法可以减少对主存的写次数，降低内存带宽需求，但存在延迟更新问题，在某个时间点，主存的数据和 Cache 的数据可能不一致。
### 虚拟存储器
虚地址、实地址
页式虚拟存储器、段式虚拟存储器、段页式虚拟存储器
快表（TLB - Translation lookaside buffer）和慢表（快表类比 Cache，提升访存速度）

# 四、指令系统
## 地址码
### 四地址指令
(A1)OP(A2) -> A3，PC = A4
指令太长
### 三地址指令
(A1)OP(A2) -> A3，PC ++
四次访存
### 二地址指令
(A1)OP(A2) -> A1，PC++
四次访存
### 一地址指令
(Acc)OP(A1) -> Acc, PC++
一次访存
### 零地址指令
堆栈计算机
操作数从栈中弹出，运算后结果压入栈中。
## 操作码
### 定长编码
操作码占指令的固定长度位数。
#### 优点
硬件设计简单，指令译码和执行速度快；
#### 缺点
指令数量多时，操作码占指令字的位数很多，严重挤压操作数地址的位数。所以一般只适用于字长较长的计算机系统，如 32 位及以上。
### 变长编码
#### 优点
在比较短的指令字中，即能表示较多的指令，又尽量满足操作数地址的要求。
#### 缺点
硬件设计复杂，指令译码和执行速度慢；
适用于字长较短的计算机系统，如 16 位及以下。
#### 实现
扩展操作码
扩展操作码的窗口可以不只留一位
![[操作码变长编码拓展窗口.png]]

## 寻址方式
### 指令寻址
顺序寻址：（PC ) + 1 = PC
跳跃寻址：JMP 7，PC=7
### 数据寻址
数据寻址方式有很多，所以将地址码切分出一部分记录寻址特征，地址码中余下的部分称为形式地址 A。
#### 立即寻址
若 A 为立即数，则寻址特征为立即寻址特征。如 JMP 7，JMP 存的是操作数本身，为立即寻址。
#### 直接寻址
若 A 为操作数的真实地址，则为直接寻址特征。
#### 隐含寻址
操作数存在专用寄存器（如 ~~Acc~~ ACC 的功能通用寄存器也能代替，已经不算作专用寄存器了）中，不需要显式指出操作数的地址，则为隐含寻址特征。

>[!note] 
> 专用寄存器有：PC 程序计数器、SP 栈指针、FP 帧指针、Flag Register 、Status Register 、Timer Register、Counter Register 、Vector Register、浮点数数据寄存器和浮点数控制寄存器、IR 指令寄存器、MDR 、MAR、PSWR（溢出、中断、进位等状态）。
#### 间接寻址
若 (A) = EA ，EA 为操作数的实际地址，则为间接寻址特征。 
#### 寄存器寻址
若 A 为通用寄存器编号，则为寄存器寻址特征。
#### 寄存器间接寻址
若 A 为通用寄存器编号，而该寄存器 R<sub>i</sub> 存的是操作数的实际地址 EA，则为寄存器间接寻址特征。
#### 基址寻址
1. 若 A 和基址寄存器 BR 的内容（通过 ALU）相加得到操作数的实际地址
##### 优点
- 基址寄存器的位数大于形式地址 A 的位数，可以扩大寻址范围
- 用户不必考虑程序存储在内存中的具体位置，有利于多道程序设计；
- 由操作系统维护基址寄存器的内容。
#### 变址寻址
2. 若 A 和通用寄存器 R<sub>i</sub> 的内容相加得到操作数的实际地址，R<sub>i</sub> 的编号存在 A 前。
##### 优点
- 通用寄存器的位数大于形式地址 A 的位数，可以扩大寻址范围
- 一般 A 不变而 R<sub>i</sub> 的内容变化。将 A 设为数组首地址，改变 R<sub>i</sub> 的内容可以很方便的获得数组任意数据的地址。有利于循环程序编写。
- 由用户改变变址寄存器的内容。
#### 相对寻址
若 A 是一个相对立即数，A 和 PC 相加后得到操作数的真实地址则寻址特征为相对寻址。常用于跳转指令，如 JMP \*4 （跳到相对当前四条指令后）, JMP 存的是 PC 相对位移量。有利于浮动程序（整体程序需要在内存中移位）编写。
##### 例题
![[内存和数据的高字节与低字节.png]]
![[相对寻址例题.png]]
#### 堆栈寻址
类似隐含寻址，操作数靠栈指针获得，栈指针有特定的名称，为隐式已知。
硬堆栈：栈顶指针指向通用寄存器；
软堆栈：栈顶指针指向主存；存储体在主存中。

## CISC 和 RISC
CISC: Complex Instruction Set Computer，可理解为指令以「话」为基本单元，集成度较高，指令间差异较大。
RISC: Reduced Instruction Set Computer，可理解为指令以「字」为单位单元，集成度较低，容易优化编译，指令差异较为均衡。
![[CISCO 和 RISC 对比.png]]
- 组合逻辑电路比微程序电路的占地面积小很多，所以有更多的空间可以用来设计寄存器。
- 指令流水线需要指令耗时相近格式相近才好运用，故适合 RISC ![[指令流水线.png]]

# 五、CPU 
## CPU 的功能和结构
![[CPU 的功能.png]]
指令控制、时间控制、中断控制、数据加工、操作控制。
### CU 和 ALU 的功能
![[CU 和 ALU 的功能.png]]
CU 功能：
- 取指令，并指出下一条指令的位置；
- 指令译码，产生操作信号；
- 指挥 CPU 、主存、IO设备间的数据流向；
ALU 的功能：
- 执行算术和逻辑运算；
## 指令的执行过程
### 指令周期
![[Pasted image 20230929105905.png]]
![[Pasted image 20230929110029.png]]
取指周期 ——› （间址周期） ——› 执行周期 ——› （中断周期）
### 各周期中的数据流
#### 取指周期
![[Pasted image 20230929110711.png]]
2️⃣：CU 向主存发出读命令，启动主存进行**读**操作，记作 1 - > R ，R 代表 read。
```
(PC)->MAR
1->R
M(MAR)->MDR
(MDR)->IR
(PC)+1->PC
```
#### 间址周期
![[Pasted image 20230929111050.png]]
```
Ad(IR)->MAR
1->R
M(MAR)->MDR
(MDR)->Ad(IR)
```
#### 中断周期
![[Pasted image 20230929111547.png]]
1️⃣：a -> MAR，主存发送读命令；若第一步的端点要存在堆栈中，则进栈需先修改栈指针后存入数据，(SP)-1 -> SP, ~~(~~ SP ~~)~~ -> MAR，（SP - 1 对应小地址是栈顶）
2️⃣：向主存发送**写**命令，1 -> W, 启动主存执行读操作；
3️⃣：将断点内容送入 MDR ，记作 PC -> MDR；
>[!Caution]
> (PC) -> MAR 指将指令地址（PC 的内容）复制到 MAR
> (PC) -> MDR 指将指令地址复制到 MDR 
> ~~(PC) -> MDR 指将由指令地址取出的指令复制到 MDR ~~

4️⃣：将 MDR 的内容通过数据总线写入到 MAR 所指示的存储单元，记作 MDR -> M(MAR)
5️⃣：在 CU 的控制下，将描述新任务的程序的第一条程序的地址送入 PC 。**向量地址**（跳转到的目的程序的首指令地址）形成部件。
```
a->MAR //若想存入堆栈，(SP)-1->SP, SP->MAR
1->W
(PC)->MDR // 保存断点
MDR->M(MAR)
向量地址->PC
```
## 控制器和数据通路
### 控制器的输入输出 （CU）
输入：IR，时钟，状态标志（当 CPU 的状态），来自系统总线的控制信号（中断请求）（**即：动作，时序，初态，反馈输入**）
输出：到系统总线的控制信号（主存读/写、I/O操作，中断响应），到 CPU 内部的控制信号（寄存器，ALU）（**即：外部输出，内部输出**）
### CPU 内部采用总线方式的控制信号与数据传输
#### 取指周期
![[Pasted image 20230929163750.png]]
#### 间址周期
#### 执行周期
### CPU 内部不采用总线方式的控制信号和数据传输 （即组合逻辑控制）
![[Pasted image 20230929203005.png]]
### 数据通路加上时间控制
[[计算机组成原理#几种周期]]
#### 组合逻辑（硬布线）控制
不同部件的操作控制需要安排在一个节拍周期内并行。所需时间短无需消耗一个节拍周期的操作也可以挤在同一个节拍周期内，如 (PC) + 1 的操作，以及 OP(IR) -> CU 译码操作。
组合逻辑控制：像是用硬件的方式实现控制
![[Pasted image 20230929205109.png]]
#### 微程序控制
微程序控制：像是用软件的方式实现控制，由运行在微小计算机上的微程序来发出控制信号。
CMDR 的存放的就是一条**微指令**，微指令产生微信号控制微操作。
![[Pasted image 20230929210929.png]]
##### 取指周期
![[Pasted image 20230929213815.png]]
##### 执行周期
![[Pasted image 20230929214235.png]]
###### 微地址形成部件
输入：操作码
输出：微程序首地址，具体的讲是微程序（如 LDA、STA ）首条微指令在**控制存储器**中的地址（也即微指令的**下地址**字段）；并将地址送入 CMAR 。
```
OP(IR)->微地址形成部件->CMAR
```
### 微指令编码方式
![[Pasted image 20230930094650.png]]
![[Pasted image 20230930095051.png]]
微指令**操作控制字段**的编码方式有：
- 直接编码方式、
- 字段直接编码方式、
- 字段间接编码方式、
- 混合编码方式（前三种都有使用）
每种编码方式都需要满足留一种状态表不发出任何控制信号。
### 微指令序列地址形成
![[Pasted image 20230930100001.png]]
### 微指令序格式

>[!Note] 机器指令和微指令
> 机器指令：由 <u>CPU</u> 执行，这些指令由指令集架构 ISA（x86 x64 arm） 定义，每个指令对应一个基本操作，如加法、乘法、加载数据等。是由高级语言汇编语言翻译出的<u>二进制结果</u>，机器指令相对微指令更抽象。
> 微指令：<u>控制单元</u>内部更底层的一种指令，用于<u>控制</u>硬件进行<u>微操作，微操作组合起来，执行一个或多个机器指令</u>。微指令的执行过程更底层更细粒度。
> 总的来说，高级语言翻译成机器指令，这些机器指令通过控制单元的微程序执行。
> - 机器指令（汇编表示）举例：
> 	- (x86) `mov [eax], ebx` 将 ebx 寄存器的内容存储到 eax 寄存器内容所寻址出的内存位置
> 	- (x86) `jmp label`
> 	- (ARM) `ADD R0,R1,R2` 将寄存器 `R1` 和 `R2` 中的数据相加，并将结果存放到寄存器 `R0` 中
> - 通用微指令简化举例：
> 	- `READ_REG A` 将寄存器 A 的内容读取到总线上
> 	- `MEM_WRITE` 
> 	- `ALU_ADD` 执行加法操作
 
![[Pasted image 20230930101659.png]]
![[Pasted image 20230930101648.png]]
微指令设计例题 ![[Pasted image 20230930104658.png]] 
## 指令流水线
### 三功能段指令的流水线时空图
![[Pasted image 20230930144114.png]]
![[Pasted image 20230930144338.png]]
![[Pasted image 20230930144527.png]]
### 超标量流水线
通过增加功能部件来进一步提高并行性。
![[Pasted image 20230930144705.png]]
### 例题
![[Pasted image 20230930144940.png]]
流水线的实际吞吐量（多少条指令每秒）、加速比（非流水线和流水线耗时比）、效率（有工作的时空区和总时空区比）

# 六、总线和 IO 系统
## 总线概述
### 性质
共享性和分时性
### 分类
#### 按功能
- 片内总线
- 系统总线
	- 数据总线：用来传输各部件间的信息。位数和存储字长相同，且机器字长是数据总线位数的整数倍。数据总线是双向的。
	- 地址总线：用来指出数据总线上源数据或目的数据所在的主存单元或者I /O端口的地址。位数决定了主存地址空间的上限；地址总线是单向的。
	- 控制总线：用来传输控制信息；局部看单向整体看双向。
- 通信总线/外部总线：计算机系统之间的总线。
#### 按时序控制
- 同步：总线上数据传输与时钟同步。
- 异步：总线上数据传输与时钟不同步。
#### 按数据传输格式
- 串行：数据一位一位地在总线上传输；
- 并行：数据多位地在总线上同时传输；
### 总线结构
#### 单总线结构
简便但带宽低；
#### 双总线结构
![[Pasted image 20230930151118.png]]
高速设备挂在存储器总线上，低速设备挂在I/O总线上，但通道访存仍经过主存总线，对高速设备还是有一定影响，通道的引入也使得硬件设计更复杂。
#### 三总线结构
![[Pasted image 20230930151943.png]]
DMA 总线的引入使得部分高速I/O设备可以直接访问主存，使得传输速率进一步提高。DMA 控制器是硬件设计更复杂。
### 系统总线性能指标
- 总线周期：一次总线操作所需的时间
- 时钟周期：机器时钟周期
- 总线频率/工作频率：总线周期的倒数
- 时钟频率
- 总线宽度：可同时传输的位数
- 总线带宽：单位时间传输的数据位数
- 总线复用：一条信号线上分时传输两种信号
- 信号线数：地址总线、数据总线和控制总线的总和
- 总线猝发传输方式：根据数据首址传输地址连续的数据
## 总线仲裁
### 集中仲裁方式
#### 链式查询方式
需要一条设备线 BG ，设备扩展方便
会有饥饿现象
![[Pasted image 20230930155703.png]]
#### 计数器定时查询方式
设备地址线有 $\log_{2} n$ (n 为I/O接口数量)条，可以编程设定查询的接口的起点，优先级设置比链式查询灵活，但仍然是单一方向查询。
![[Pasted image 20230930155621.png]]
#### 独立请求方式
需要 2n 条设备线
![[Pasted image 20230930155501.png]]
#### 总结
![[Pasted image 20230930155601.png]]
## 总线操作和定时
### 总线传输的四个阶段
![[Pasted image 20230930160356.png]]
申请分配-寻址（查找）-传输-结束
### 定时
#### 同步定时方式
系统采用统一的时钟信号来协调发送接受双方的传送定时关系。
优点：简单统一
缺点：这种方式成立的前提是从设备能在规定的时间内完成预期任务，这就要求系统必须按最慢的部件来设计公共时钟，灵活性差。
#### 异步定时方式
没有统一时钟，没有固定时间间隔，双方“握手”相互制约实现定时控制。
##### 不互锁方式
主设备和从设备都只发送一段时间的请求。
##### 半互锁方式
对主设备加限制，主设备一直发送请求（黄信封），从设备发送一段时间响应请求（红信封），主设备若收到响应请求，握手完成。
##### 全互锁方式
在半互锁的基础上，主设备收到响应请求后再发送一个撤销响应请求的信号（黑信封）给从设备，从设备等到撤销信号或超时才停止发送响应请求。即主设备和从设备都一直发送请求，直到从设备得知握手完成。
### 比特率和波特率
波特率（Baud per second）：信号被调制后在单位时间内变化的次数，即信道中每秒传输的符号数量。单位 Bd。
比特率（bit per second）：每秒传送的比特数。
![[Pasted image 20230930163803.png]]
## 总线标准

## 外部设备
### 输入设备
### 输出设备
#### 显示器
- 灰度级
- 分辨率
- 刷新率
#### 打印机
- 喷墨
- 激光
- 针式
#### 硬磁盘存储器
##### 结构
- 碟片
- 磁盘控制器（现代计算机中集成在硬盘本体上）：主轴、定位驱动、数据控制器；它接收主机的命令，转换成磁盘驱动器的控制命令，控制驱动器读/写；它同时负责主机和驱动器之间的数据格式转换和数据传输。
![[Pasted image 20230930165532.png]]
##### 硬磁盘轨道记录格式
- 磁头数：10 张碟片有 18 个磁头，磁盘记录面数也是 18
- 柱面数：每一面盘面有多少个磁道
- 扇区数：饼扇数
##### 磁记录原理
磁表面存储器通过磁头和记录介质的相对运动完成读/写操作；
编码方法，按某种规律，把一连串的二进制信息变成存储介质磁层中磁化的反转状态的序列。
方式有调频式和改进调频式
##### 磁盘地址
驱动器号：柱面号：盘面号：扇区号
##### 独立磁盘冗余阵列（Redundant Arrays of Independent Disks）
RAID 是将多个独立物理磁盘组成一个独立逻辑磁盘，数据会在多个物理盘上交叉存储、并行访问，存储性能，可靠性和安全性高。
有六个分级，RAID1~RAID5 随时可以拔出插入，数据不会丢失。
RAID0: 无冗余，无校验（保存的数据可能出错）；
RAID1: 镜像磁盘阵列；
RAID2: 含可纠错的海明码校验；
RAID3: 位交叉奇偶校验；
RAID4: 块交叉奇偶校验；
RAID5: 无独立校验的奇偶校验；
##### 磁盘访问时间
1）寻道时间：磁头移动到指定磁道的时间；
2）旋转延迟时间：扇区移动到磁头下面的时间，估算为磁盘自转周期的一半；
3）传输时间：写/读数据的时间；
##### 磁盘调度
磁盘处理请求先后的策略
- FCFS
- SSTF：shortest seek time first，先将任务排序，然后找离当前磁道最近的任务进行，缺点是可能有饥饿现象。
- SCAN： curdir->4999, 0<-
- LOOK：会往前看，curdir->REndpoint···4999,0···LEndpoint<-
- C-SCAN：cycle scan, SCAN 和 LOOK 都不能及时响应身后新来的任务。规定磁头只往一个方向移动
![[Pasted image 20230930174201.png]]
- NStepSCAN
- FSCAN
#### 光盘
存储密度高，成本低，便携，存储期长。CD-ROM(compact disc), CD-R, CD-RW, DVD-ROM(digital video disc)
## I/O 接口
### 功能
- 实现主机和外部设备间的通讯控制；
- 地址译码和设备选择；（可能连接多个外设）
- 数据缓冲；（外设速度低）
- 数据格式转换（外设的输出多样）
- 传输控制命令和状态信息（控制外设）
### 分类
#### 按数据传输
- 并行
- 串行
#### 按主机访问 I/O 设备的控制方式
- 程序查询接口
- 中断接口
- DMA 接口
#### 灵活性
- 可编程接口
- 不可编程接口
### I/O端口编址
>[!attention]
> I/O 端口是 I/O 接口电路中的寄存器

I/O 端口编址有两种:
- 存储器统一编址
	- 无需专门的输入/输出指令，CPU 访问 I/O 端口操作灵活但是速度低。
	- 端口编址空间大，但同时占用存储器地址
- 独立编址
	- 有专门的指令，访问端口速度高但命令少；CPU 控制主存或端口读写时需要使用两套控制信号，复杂。
	- 不占用存储器地址。
## I/O 方式（主机访问 I/O 设备的控制方式）
### 程序查询接口方式
![[Pasted image 20231001100032.png]]
### 程序中断方式
![[Pasted image 20231001100254.png]]
#### 中断请求分类
中断源向 CPU 发送中断请求信号
##### 中断源
- 内中断：来自 CPU 和内存的中断，如除数为零的运算错误，内存不足分配失败错误
- 外中断：来自 CPU 和内存以外的中断，如 I/O 设备的中断
##### 硬中断和软中断
- 硬中断：通过外部硬件产生的中断，属外中断
- 软中断：通过指令产生的中断，可编程实现，属内中断
##### 非屏蔽中断和可屏蔽中断
都是外中断
#### 中断判优
若某时刻有多个中断请求，中断系统只能响应其中一个中断源的请求，此时通过中断判优规则选择一个请求进行响应。
硬中断高于软中断；非屏蔽中断高于屏蔽中断；DMA 请求高于 I/O 设备，高速设备高于低速设备，输入设备高于输出设备，实时设备高于普通设备；
#### 中断响应和处理
响应条件：必须满足 CPU 中的允许中断触发器 EINT 为真；
响应时间：CPU 在每条指令执行阶段的结束时刻会响应中断
##### 中断处理：
保护现场和恢复现场都不能被中断
![[Pasted image 20231001103453.png]]
#### 多重中断和中断屏蔽
不是所有 CPU 都有多重中断功能
![[Pasted image 20231001103903.png]]
##### 中断源屏蔽字
![[Pasted image 20231001105154.png]]
每个中断源发出中断请求后要将自己屏蔽掉 ，否则自己能无限中断自己。
##### 例题
![[Pasted image 20231001104625.png]]
### DMA 方式 (Direct Memory Access)
#### 含义
主存和 DMA 接口中间有一条专用的数据通路，I/O 设备可与主存直接交换信息（无需经由 CPU ）。该方式使得 I/O 与主机并行工作，程序和数据传输并行工作，无需 CPU 暂停现行程序（保护现场和恢复现场）去为设备服务，速度快。
#### DMA 与主存交换信息的方法
##### CPU 停止访问主存法
![[Pasted image 20231001110453.png]]
##### 交替访存法
![[Pasted image 20231001110713.png]]
##### 周期挪用法(cycle stealing)
DMA 控制器只在总线空闲时偷取一两个总线周期进行数据传输，主体时间还是CPU 在控制总线，适合传输小量数据，大块数据会对 CPU 产生较大影响。
![[Pasted image 20231001111258.png]]
#### DMA 控制器
##### 预处理
![[Pasted image 20231001113239.png]]
##### 传输
DMA 控制器相当于一个简单的 CPU ，专门用来处理数据传输。
![[Pasted image 20231001113838.png]]
![[Pasted image 20231001114437.png]]
![[Pasted image 20231001114452.png]]
##### 后处理
![[Pasted image 20231001114947.png]]
#### 特点
![[Pasted image 20231001115209.png]]
#### DMA 方式和中断的区别
![[Pasted image 20231001115641.png]]

# Footnotes

[^1]: [【数电】(一) 进制转换编码 原码，反码，补码\_数电原码反码补码-CSDN博客](https://blog.csdn.net/as480133937/article/details/104501256)
